// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapCharacteristicCharacteristicDatum is an object representing the database table.
type SapCharacteristicCharacteristicDatum struct {
	CharcInternalID               string      `boil:"CharcInternalID" json:"CharcInternalID" toml:"CharcInternalID" yaml:"CharcInternalID"`
	DeleteMC                      null.Bool   `boil:"Delete_mc" json:"Delete_mc,omitempty" toml:"Delete_mc" yaml:"Delete_mc,omitempty"`
	UpdateMC                      null.Bool   `boil:"Update_mc" json:"Update_mc,omitempty" toml:"Update_mc" yaml:"Update_mc,omitempty"`
	ToCharacteristicDescOc        null.Bool   `boil:"to_CharacteristicDesc_oc" json:"to_CharacteristicDesc_oc,omitempty" toml:"to_CharacteristicDesc_oc" yaml:"to_CharacteristicDesc_oc,omitempty"`
	ToCharacteristicReferenceOc   null.Bool   `boil:"to_CharacteristicReference_oc" json:"to_CharacteristicReference_oc,omitempty" toml:"to_CharacteristicReference_oc" yaml:"to_CharacteristicReference_oc,omitempty"`
	ToCharacteristicRestrictionOc null.Bool   `boil:"to_CharacteristicRestriction_oc" json:"to_CharacteristicRestriction_oc,omitempty" toml:"to_CharacteristicRestriction_oc" yaml:"to_CharacteristicRestriction_oc,omitempty"`
	ToCharacteristicValueOc       null.Bool   `boil:"to_CharacteristicValue_oc" json:"to_CharacteristicValue_oc,omitempty" toml:"to_CharacteristicValue_oc" yaml:"to_CharacteristicValue_oc,omitempty"`
	Characteristic                null.String `boil:"Characteristic" json:"Characteristic,omitempty" toml:"Characteristic" yaml:"Characteristic,omitempty"`
	CharcStatus                   null.String `boil:"CharcStatus" json:"CharcStatus,omitempty" toml:"CharcStatus" yaml:"CharcStatus,omitempty"`
	CharcStatusName               null.String `boil:"CharcStatusName" json:"CharcStatusName,omitempty" toml:"CharcStatusName" yaml:"CharcStatusName,omitempty"`
	CharcDataType                 null.String `boil:"CharcDataType" json:"CharcDataType,omitempty" toml:"CharcDataType" yaml:"CharcDataType,omitempty"`
	CharcLength                   null.Int    `boil:"CharcLength" json:"CharcLength,omitempty" toml:"CharcLength" yaml:"CharcLength,omitempty"`
	CharcDecimals                 null.Int    `boil:"CharcDecimals" json:"CharcDecimals,omitempty" toml:"CharcDecimals" yaml:"CharcDecimals,omitempty"`
	CharcTemplate                 null.String `boil:"CharcTemplate" json:"CharcTemplate,omitempty" toml:"CharcTemplate" yaml:"CharcTemplate,omitempty"`
	ValueIsCaseSensitive          null.Bool   `boil:"ValueIsCaseSensitive" json:"ValueIsCaseSensitive,omitempty" toml:"ValueIsCaseSensitive" yaml:"ValueIsCaseSensitive,omitempty"`
	CharcGroup                    null.String `boil:"CharcGroup" json:"CharcGroup,omitempty" toml:"CharcGroup" yaml:"CharcGroup,omitempty"`
	CharcGroupName                null.String `boil:"CharcGroupName" json:"CharcGroupName,omitempty" toml:"CharcGroupName" yaml:"CharcGroupName,omitempty"`
	EntryIsRequired               null.Bool   `boil:"EntryIsRequired" json:"EntryIsRequired,omitempty" toml:"EntryIsRequired" yaml:"EntryIsRequired,omitempty"`
	MultipleValuesAreAllowed      null.Bool   `boil:"MultipleValuesAreAllowed" json:"MultipleValuesAreAllowed,omitempty" toml:"MultipleValuesAreAllowed" yaml:"MultipleValuesAreAllowed,omitempty"`
	CharcValueUnit                null.String `boil:"CharcValueUnit" json:"CharcValueUnit,omitempty" toml:"CharcValueUnit" yaml:"CharcValueUnit,omitempty"`
	Currency                      null.String `boil:"Currency" json:"Currency,omitempty" toml:"Currency" yaml:"Currency,omitempty"`
	CharcExponentValue            null.Int    `boil:"CharcExponentValue" json:"CharcExponentValue,omitempty" toml:"CharcExponentValue" yaml:"CharcExponentValue,omitempty"`
	ValueIntervalIsAllowed        null.Bool   `boil:"ValueIntervalIsAllowed" json:"ValueIntervalIsAllowed,omitempty" toml:"ValueIntervalIsAllowed" yaml:"ValueIntervalIsAllowed,omitempty"`
	AdditionalValueIsAllowed      null.Bool   `boil:"AdditionalValueIsAllowed" json:"AdditionalValueIsAllowed,omitempty" toml:"AdditionalValueIsAllowed" yaml:"AdditionalValueIsAllowed,omitempty"`
	NegativeValueIsAllowed        null.Bool   `boil:"NegativeValueIsAllowed" json:"NegativeValueIsAllowed,omitempty" toml:"NegativeValueIsAllowed" yaml:"NegativeValueIsAllowed,omitempty"`
	ValidityStartDate             null.String `boil:"ValidityStartDate" json:"ValidityStartDate,omitempty" toml:"ValidityStartDate" yaml:"ValidityStartDate,omitempty"`
	ValidityEndDate               null.String `boil:"ValidityEndDate" json:"ValidityEndDate,omitempty" toml:"ValidityEndDate" yaml:"ValidityEndDate,omitempty"`
	ChangeNumber                  null.String `boil:"ChangeNumber" json:"ChangeNumber,omitempty" toml:"ChangeNumber" yaml:"ChangeNumber,omitempty"`
	DocumentType                  null.String `boil:"DocumentType" json:"DocumentType,omitempty" toml:"DocumentType" yaml:"DocumentType,omitempty"`
	DocNumber                     null.String `boil:"DocNumber" json:"DocNumber,omitempty" toml:"DocNumber" yaml:"DocNumber,omitempty"`
	DocumentVersion               null.String `boil:"DocumentVersion" json:"DocumentVersion,omitempty" toml:"DocumentVersion" yaml:"DocumentVersion,omitempty"`
	DocumentPart                  null.String `boil:"DocumentPart" json:"DocumentPart,omitempty" toml:"DocumentPart" yaml:"DocumentPart,omitempty"`
	CharcMaintAuthGrp             null.String `boil:"CharcMaintAuthGrp" json:"CharcMaintAuthGrp,omitempty" toml:"CharcMaintAuthGrp" yaml:"CharcMaintAuthGrp,omitempty"`
	CharcIsReadOnly               null.Bool   `boil:"CharcIsReadOnly" json:"CharcIsReadOnly,omitempty" toml:"CharcIsReadOnly" yaml:"CharcIsReadOnly,omitempty"`
	CharcIsHidden                 null.Bool   `boil:"CharcIsHidden" json:"CharcIsHidden,omitempty" toml:"CharcIsHidden" yaml:"CharcIsHidden,omitempty"`
	CharcIsRestrictable           null.Bool   `boil:"CharcIsRestrictable" json:"CharcIsRestrictable,omitempty" toml:"CharcIsRestrictable" yaml:"CharcIsRestrictable,omitempty"`
	CharcExponentFormat           null.String `boil:"CharcExponentFormat" json:"CharcExponentFormat,omitempty" toml:"CharcExponentFormat" yaml:"CharcExponentFormat,omitempty"`
	CharcEntryIsNotFormatCtrld    null.Bool   `boil:"CharcEntryIsNotFormatCtrld" json:"CharcEntryIsNotFormatCtrld,omitempty" toml:"CharcEntryIsNotFormatCtrld" yaml:"CharcEntryIsNotFormatCtrld,omitempty"`
	CharcTemplateIsDisplayed      null.Bool   `boil:"CharcTemplateIsDisplayed" json:"CharcTemplateIsDisplayed,omitempty" toml:"CharcTemplateIsDisplayed" yaml:"CharcTemplateIsDisplayed,omitempty"`
	CreationDate                  null.String `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	LastChangeDate                null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	CharcLastChangedDateTime      null.String `boil:"CharcLastChangedDateTime" json:"CharcLastChangedDateTime,omitempty" toml:"CharcLastChangedDateTime" yaml:"CharcLastChangedDateTime,omitempty"`
	KeyDate                       null.String `boil:"KeyDate" json:"KeyDate,omitempty" toml:"KeyDate" yaml:"KeyDate,omitempty"`

	R *sapCharacteristicCharacteristicDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapCharacteristicCharacteristicDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapCharacteristicCharacteristicDatumColumns = struct {
	CharcInternalID               string
	DeleteMC                      string
	UpdateMC                      string
	ToCharacteristicDescOc        string
	ToCharacteristicReferenceOc   string
	ToCharacteristicRestrictionOc string
	ToCharacteristicValueOc       string
	Characteristic                string
	CharcStatus                   string
	CharcStatusName               string
	CharcDataType                 string
	CharcLength                   string
	CharcDecimals                 string
	CharcTemplate                 string
	ValueIsCaseSensitive          string
	CharcGroup                    string
	CharcGroupName                string
	EntryIsRequired               string
	MultipleValuesAreAllowed      string
	CharcValueUnit                string
	Currency                      string
	CharcExponentValue            string
	ValueIntervalIsAllowed        string
	AdditionalValueIsAllowed      string
	NegativeValueIsAllowed        string
	ValidityStartDate             string
	ValidityEndDate               string
	ChangeNumber                  string
	DocumentType                  string
	DocNumber                     string
	DocumentVersion               string
	DocumentPart                  string
	CharcMaintAuthGrp             string
	CharcIsReadOnly               string
	CharcIsHidden                 string
	CharcIsRestrictable           string
	CharcExponentFormat           string
	CharcEntryIsNotFormatCtrld    string
	CharcTemplateIsDisplayed      string
	CreationDate                  string
	LastChangeDate                string
	CharcLastChangedDateTime      string
	KeyDate                       string
}{
	CharcInternalID:               "CharcInternalID",
	DeleteMC:                      "Delete_mc",
	UpdateMC:                      "Update_mc",
	ToCharacteristicDescOc:        "to_CharacteristicDesc_oc",
	ToCharacteristicReferenceOc:   "to_CharacteristicReference_oc",
	ToCharacteristicRestrictionOc: "to_CharacteristicRestriction_oc",
	ToCharacteristicValueOc:       "to_CharacteristicValue_oc",
	Characteristic:                "Characteristic",
	CharcStatus:                   "CharcStatus",
	CharcStatusName:               "CharcStatusName",
	CharcDataType:                 "CharcDataType",
	CharcLength:                   "CharcLength",
	CharcDecimals:                 "CharcDecimals",
	CharcTemplate:                 "CharcTemplate",
	ValueIsCaseSensitive:          "ValueIsCaseSensitive",
	CharcGroup:                    "CharcGroup",
	CharcGroupName:                "CharcGroupName",
	EntryIsRequired:               "EntryIsRequired",
	MultipleValuesAreAllowed:      "MultipleValuesAreAllowed",
	CharcValueUnit:                "CharcValueUnit",
	Currency:                      "Currency",
	CharcExponentValue:            "CharcExponentValue",
	ValueIntervalIsAllowed:        "ValueIntervalIsAllowed",
	AdditionalValueIsAllowed:      "AdditionalValueIsAllowed",
	NegativeValueIsAllowed:        "NegativeValueIsAllowed",
	ValidityStartDate:             "ValidityStartDate",
	ValidityEndDate:               "ValidityEndDate",
	ChangeNumber:                  "ChangeNumber",
	DocumentType:                  "DocumentType",
	DocNumber:                     "DocNumber",
	DocumentVersion:               "DocumentVersion",
	DocumentPart:                  "DocumentPart",
	CharcMaintAuthGrp:             "CharcMaintAuthGrp",
	CharcIsReadOnly:               "CharcIsReadOnly",
	CharcIsHidden:                 "CharcIsHidden",
	CharcIsRestrictable:           "CharcIsRestrictable",
	CharcExponentFormat:           "CharcExponentFormat",
	CharcEntryIsNotFormatCtrld:    "CharcEntryIsNotFormatCtrld",
	CharcTemplateIsDisplayed:      "CharcTemplateIsDisplayed",
	CreationDate:                  "CreationDate",
	LastChangeDate:                "LastChangeDate",
	CharcLastChangedDateTime:      "CharcLastChangedDateTime",
	KeyDate:                       "KeyDate",
}

var SapCharacteristicCharacteristicDatumTableColumns = struct {
	CharcInternalID               string
	DeleteMC                      string
	UpdateMC                      string
	ToCharacteristicDescOc        string
	ToCharacteristicReferenceOc   string
	ToCharacteristicRestrictionOc string
	ToCharacteristicValueOc       string
	Characteristic                string
	CharcStatus                   string
	CharcStatusName               string
	CharcDataType                 string
	CharcLength                   string
	CharcDecimals                 string
	CharcTemplate                 string
	ValueIsCaseSensitive          string
	CharcGroup                    string
	CharcGroupName                string
	EntryIsRequired               string
	MultipleValuesAreAllowed      string
	CharcValueUnit                string
	Currency                      string
	CharcExponentValue            string
	ValueIntervalIsAllowed        string
	AdditionalValueIsAllowed      string
	NegativeValueIsAllowed        string
	ValidityStartDate             string
	ValidityEndDate               string
	ChangeNumber                  string
	DocumentType                  string
	DocNumber                     string
	DocumentVersion               string
	DocumentPart                  string
	CharcMaintAuthGrp             string
	CharcIsReadOnly               string
	CharcIsHidden                 string
	CharcIsRestrictable           string
	CharcExponentFormat           string
	CharcEntryIsNotFormatCtrld    string
	CharcTemplateIsDisplayed      string
	CreationDate                  string
	LastChangeDate                string
	CharcLastChangedDateTime      string
	KeyDate                       string
}{
	CharcInternalID:               "sap_characteristic_characteristic_data.CharcInternalID",
	DeleteMC:                      "sap_characteristic_characteristic_data.Delete_mc",
	UpdateMC:                      "sap_characteristic_characteristic_data.Update_mc",
	ToCharacteristicDescOc:        "sap_characteristic_characteristic_data.to_CharacteristicDesc_oc",
	ToCharacteristicReferenceOc:   "sap_characteristic_characteristic_data.to_CharacteristicReference_oc",
	ToCharacteristicRestrictionOc: "sap_characteristic_characteristic_data.to_CharacteristicRestriction_oc",
	ToCharacteristicValueOc:       "sap_characteristic_characteristic_data.to_CharacteristicValue_oc",
	Characteristic:                "sap_characteristic_characteristic_data.Characteristic",
	CharcStatus:                   "sap_characteristic_characteristic_data.CharcStatus",
	CharcStatusName:               "sap_characteristic_characteristic_data.CharcStatusName",
	CharcDataType:                 "sap_characteristic_characteristic_data.CharcDataType",
	CharcLength:                   "sap_characteristic_characteristic_data.CharcLength",
	CharcDecimals:                 "sap_characteristic_characteristic_data.CharcDecimals",
	CharcTemplate:                 "sap_characteristic_characteristic_data.CharcTemplate",
	ValueIsCaseSensitive:          "sap_characteristic_characteristic_data.ValueIsCaseSensitive",
	CharcGroup:                    "sap_characteristic_characteristic_data.CharcGroup",
	CharcGroupName:                "sap_characteristic_characteristic_data.CharcGroupName",
	EntryIsRequired:               "sap_characteristic_characteristic_data.EntryIsRequired",
	MultipleValuesAreAllowed:      "sap_characteristic_characteristic_data.MultipleValuesAreAllowed",
	CharcValueUnit:                "sap_characteristic_characteristic_data.CharcValueUnit",
	Currency:                      "sap_characteristic_characteristic_data.Currency",
	CharcExponentValue:            "sap_characteristic_characteristic_data.CharcExponentValue",
	ValueIntervalIsAllowed:        "sap_characteristic_characteristic_data.ValueIntervalIsAllowed",
	AdditionalValueIsAllowed:      "sap_characteristic_characteristic_data.AdditionalValueIsAllowed",
	NegativeValueIsAllowed:        "sap_characteristic_characteristic_data.NegativeValueIsAllowed",
	ValidityStartDate:             "sap_characteristic_characteristic_data.ValidityStartDate",
	ValidityEndDate:               "sap_characteristic_characteristic_data.ValidityEndDate",
	ChangeNumber:                  "sap_characteristic_characteristic_data.ChangeNumber",
	DocumentType:                  "sap_characteristic_characteristic_data.DocumentType",
	DocNumber:                     "sap_characteristic_characteristic_data.DocNumber",
	DocumentVersion:               "sap_characteristic_characteristic_data.DocumentVersion",
	DocumentPart:                  "sap_characteristic_characteristic_data.DocumentPart",
	CharcMaintAuthGrp:             "sap_characteristic_characteristic_data.CharcMaintAuthGrp",
	CharcIsReadOnly:               "sap_characteristic_characteristic_data.CharcIsReadOnly",
	CharcIsHidden:                 "sap_characteristic_characteristic_data.CharcIsHidden",
	CharcIsRestrictable:           "sap_characteristic_characteristic_data.CharcIsRestrictable",
	CharcExponentFormat:           "sap_characteristic_characteristic_data.CharcExponentFormat",
	CharcEntryIsNotFormatCtrld:    "sap_characteristic_characteristic_data.CharcEntryIsNotFormatCtrld",
	CharcTemplateIsDisplayed:      "sap_characteristic_characteristic_data.CharcTemplateIsDisplayed",
	CreationDate:                  "sap_characteristic_characteristic_data.CreationDate",
	LastChangeDate:                "sap_characteristic_characteristic_data.LastChangeDate",
	CharcLastChangedDateTime:      "sap_characteristic_characteristic_data.CharcLastChangedDateTime",
	KeyDate:                       "sap_characteristic_characteristic_data.KeyDate",
}

// Generated where

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var SapCharacteristicCharacteristicDatumWhere = struct {
	CharcInternalID               whereHelperstring
	DeleteMC                      whereHelpernull_Bool
	UpdateMC                      whereHelpernull_Bool
	ToCharacteristicDescOc        whereHelpernull_Bool
	ToCharacteristicReferenceOc   whereHelpernull_Bool
	ToCharacteristicRestrictionOc whereHelpernull_Bool
	ToCharacteristicValueOc       whereHelpernull_Bool
	Characteristic                whereHelpernull_String
	CharcStatus                   whereHelpernull_String
	CharcStatusName               whereHelpernull_String
	CharcDataType                 whereHelpernull_String
	CharcLength                   whereHelpernull_Int
	CharcDecimals                 whereHelpernull_Int
	CharcTemplate                 whereHelpernull_String
	ValueIsCaseSensitive          whereHelpernull_Bool
	CharcGroup                    whereHelpernull_String
	CharcGroupName                whereHelpernull_String
	EntryIsRequired               whereHelpernull_Bool
	MultipleValuesAreAllowed      whereHelpernull_Bool
	CharcValueUnit                whereHelpernull_String
	Currency                      whereHelpernull_String
	CharcExponentValue            whereHelpernull_Int
	ValueIntervalIsAllowed        whereHelpernull_Bool
	AdditionalValueIsAllowed      whereHelpernull_Bool
	NegativeValueIsAllowed        whereHelpernull_Bool
	ValidityStartDate             whereHelpernull_String
	ValidityEndDate               whereHelpernull_String
	ChangeNumber                  whereHelpernull_String
	DocumentType                  whereHelpernull_String
	DocNumber                     whereHelpernull_String
	DocumentVersion               whereHelpernull_String
	DocumentPart                  whereHelpernull_String
	CharcMaintAuthGrp             whereHelpernull_String
	CharcIsReadOnly               whereHelpernull_Bool
	CharcIsHidden                 whereHelpernull_Bool
	CharcIsRestrictable           whereHelpernull_Bool
	CharcExponentFormat           whereHelpernull_String
	CharcEntryIsNotFormatCtrld    whereHelpernull_Bool
	CharcTemplateIsDisplayed      whereHelpernull_Bool
	CreationDate                  whereHelpernull_String
	LastChangeDate                whereHelpernull_String
	CharcLastChangedDateTime      whereHelpernull_String
	KeyDate                       whereHelpernull_String
}{
	CharcInternalID:               whereHelperstring{field: "`sap_characteristic_characteristic_data`.`CharcInternalID`"},
	DeleteMC:                      whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`Delete_mc`"},
	UpdateMC:                      whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`Update_mc`"},
	ToCharacteristicDescOc:        whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`to_CharacteristicDesc_oc`"},
	ToCharacteristicReferenceOc:   whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`to_CharacteristicReference_oc`"},
	ToCharacteristicRestrictionOc: whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`to_CharacteristicRestriction_oc`"},
	ToCharacteristicValueOc:       whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`to_CharacteristicValue_oc`"},
	Characteristic:                whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`Characteristic`"},
	CharcStatus:                   whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcStatus`"},
	CharcStatusName:               whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcStatusName`"},
	CharcDataType:                 whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcDataType`"},
	CharcLength:                   whereHelpernull_Int{field: "`sap_characteristic_characteristic_data`.`CharcLength`"},
	CharcDecimals:                 whereHelpernull_Int{field: "`sap_characteristic_characteristic_data`.`CharcDecimals`"},
	CharcTemplate:                 whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcTemplate`"},
	ValueIsCaseSensitive:          whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`ValueIsCaseSensitive`"},
	CharcGroup:                    whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcGroup`"},
	CharcGroupName:                whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcGroupName`"},
	EntryIsRequired:               whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`EntryIsRequired`"},
	MultipleValuesAreAllowed:      whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`MultipleValuesAreAllowed`"},
	CharcValueUnit:                whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcValueUnit`"},
	Currency:                      whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`Currency`"},
	CharcExponentValue:            whereHelpernull_Int{field: "`sap_characteristic_characteristic_data`.`CharcExponentValue`"},
	ValueIntervalIsAllowed:        whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`ValueIntervalIsAllowed`"},
	AdditionalValueIsAllowed:      whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`AdditionalValueIsAllowed`"},
	NegativeValueIsAllowed:        whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`NegativeValueIsAllowed`"},
	ValidityStartDate:             whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`ValidityStartDate`"},
	ValidityEndDate:               whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`ValidityEndDate`"},
	ChangeNumber:                  whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`ChangeNumber`"},
	DocumentType:                  whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`DocumentType`"},
	DocNumber:                     whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`DocNumber`"},
	DocumentVersion:               whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`DocumentVersion`"},
	DocumentPart:                  whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`DocumentPart`"},
	CharcMaintAuthGrp:             whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcMaintAuthGrp`"},
	CharcIsReadOnly:               whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`CharcIsReadOnly`"},
	CharcIsHidden:                 whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`CharcIsHidden`"},
	CharcIsRestrictable:           whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`CharcIsRestrictable`"},
	CharcExponentFormat:           whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcExponentFormat`"},
	CharcEntryIsNotFormatCtrld:    whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`CharcEntryIsNotFormatCtrld`"},
	CharcTemplateIsDisplayed:      whereHelpernull_Bool{field: "`sap_characteristic_characteristic_data`.`CharcTemplateIsDisplayed`"},
	CreationDate:                  whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CreationDate`"},
	LastChangeDate:                whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`LastChangeDate`"},
	CharcLastChangedDateTime:      whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`CharcLastChangedDateTime`"},
	KeyDate:                       whereHelpernull_String{field: "`sap_characteristic_characteristic_data`.`KeyDate`"},
}

// SapCharacteristicCharacteristicDatumRels is where relationship names are stored.
var SapCharacteristicCharacteristicDatumRels = struct {
	CharcInternalIDSapCharacteristicCharcDescriptionData string
	CharcInternalIDSapCharacteristicValueData            string
	CharcInternalIDSapCharacteristicValueDescriptionData string
}{
	CharcInternalIDSapCharacteristicCharcDescriptionData: "CharcInternalIDSapCharacteristicCharcDescriptionData",
	CharcInternalIDSapCharacteristicValueData:            "CharcInternalIDSapCharacteristicValueData",
	CharcInternalIDSapCharacteristicValueDescriptionData: "CharcInternalIDSapCharacteristicValueDescriptionData",
}

// sapCharacteristicCharacteristicDatumR is where relationships are stored.
type sapCharacteristicCharacteristicDatumR struct {
	CharcInternalIDSapCharacteristicCharcDescriptionData SapCharacteristicCharcDescriptionDatumSlice `boil:"CharcInternalIDSapCharacteristicCharcDescriptionData" json:"CharcInternalIDSapCharacteristicCharcDescriptionData" toml:"CharcInternalIDSapCharacteristicCharcDescriptionData" yaml:"CharcInternalIDSapCharacteristicCharcDescriptionData"`
	CharcInternalIDSapCharacteristicValueData            SapCharacteristicValueDatumSlice            `boil:"CharcInternalIDSapCharacteristicValueData" json:"CharcInternalIDSapCharacteristicValueData" toml:"CharcInternalIDSapCharacteristicValueData" yaml:"CharcInternalIDSapCharacteristicValueData"`
	CharcInternalIDSapCharacteristicValueDescriptionData SapCharacteristicValueDescriptionDatumSlice `boil:"CharcInternalIDSapCharacteristicValueDescriptionData" json:"CharcInternalIDSapCharacteristicValueDescriptionData" toml:"CharcInternalIDSapCharacteristicValueDescriptionData" yaml:"CharcInternalIDSapCharacteristicValueDescriptionData"`
}

// NewStruct creates a new relationship struct
func (*sapCharacteristicCharacteristicDatumR) NewStruct() *sapCharacteristicCharacteristicDatumR {
	return &sapCharacteristicCharacteristicDatumR{}
}

// sapCharacteristicCharacteristicDatumL is where Load methods for each relationship are stored.
type sapCharacteristicCharacteristicDatumL struct{}

var (
	sapCharacteristicCharacteristicDatumAllColumns            = []string{"CharcInternalID", "Delete_mc", "Update_mc", "to_CharacteristicDesc_oc", "to_CharacteristicReference_oc", "to_CharacteristicRestriction_oc", "to_CharacteristicValue_oc", "Characteristic", "CharcStatus", "CharcStatusName", "CharcDataType", "CharcLength", "CharcDecimals", "CharcTemplate", "ValueIsCaseSensitive", "CharcGroup", "CharcGroupName", "EntryIsRequired", "MultipleValuesAreAllowed", "CharcValueUnit", "Currency", "CharcExponentValue", "ValueIntervalIsAllowed", "AdditionalValueIsAllowed", "NegativeValueIsAllowed", "ValidityStartDate", "ValidityEndDate", "ChangeNumber", "DocumentType", "DocNumber", "DocumentVersion", "DocumentPart", "CharcMaintAuthGrp", "CharcIsReadOnly", "CharcIsHidden", "CharcIsRestrictable", "CharcExponentFormat", "CharcEntryIsNotFormatCtrld", "CharcTemplateIsDisplayed", "CreationDate", "LastChangeDate", "CharcLastChangedDateTime", "KeyDate"}
	sapCharacteristicCharacteristicDatumColumnsWithoutDefault = []string{"CharcInternalID", "Delete_mc", "Update_mc", "to_CharacteristicDesc_oc", "to_CharacteristicReference_oc", "to_CharacteristicRestriction_oc", "to_CharacteristicValue_oc", "Characteristic", "CharcStatus", "CharcStatusName", "CharcDataType", "CharcLength", "CharcDecimals", "CharcTemplate", "ValueIsCaseSensitive", "CharcGroup", "CharcGroupName", "EntryIsRequired", "MultipleValuesAreAllowed", "CharcValueUnit", "Currency", "CharcExponentValue", "ValueIntervalIsAllowed", "AdditionalValueIsAllowed", "NegativeValueIsAllowed", "ValidityStartDate", "ValidityEndDate", "ChangeNumber", "DocumentType", "DocNumber", "DocumentVersion", "DocumentPart", "CharcMaintAuthGrp", "CharcIsReadOnly", "CharcIsHidden", "CharcIsRestrictable", "CharcExponentFormat", "CharcEntryIsNotFormatCtrld", "CharcTemplateIsDisplayed", "CreationDate", "LastChangeDate", "CharcLastChangedDateTime", "KeyDate"}
	sapCharacteristicCharacteristicDatumColumnsWithDefault    = []string{}
	sapCharacteristicCharacteristicDatumPrimaryKeyColumns     = []string{"CharcInternalID"}
	sapCharacteristicCharacteristicDatumGeneratedColumns      = []string{}
)

type (
	// SapCharacteristicCharacteristicDatumSlice is an alias for a slice of pointers to SapCharacteristicCharacteristicDatum.
	// This should almost always be used instead of []SapCharacteristicCharacteristicDatum.
	SapCharacteristicCharacteristicDatumSlice []*SapCharacteristicCharacteristicDatum
	// SapCharacteristicCharacteristicDatumHook is the signature for custom SapCharacteristicCharacteristicDatum hook methods
	SapCharacteristicCharacteristicDatumHook func(context.Context, boil.ContextExecutor, *SapCharacteristicCharacteristicDatum) error

	sapCharacteristicCharacteristicDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapCharacteristicCharacteristicDatumType                 = reflect.TypeOf(&SapCharacteristicCharacteristicDatum{})
	sapCharacteristicCharacteristicDatumMapping              = queries.MakeStructMapping(sapCharacteristicCharacteristicDatumType)
	sapCharacteristicCharacteristicDatumPrimaryKeyMapping, _ = queries.BindMapping(sapCharacteristicCharacteristicDatumType, sapCharacteristicCharacteristicDatumMapping, sapCharacteristicCharacteristicDatumPrimaryKeyColumns)
	sapCharacteristicCharacteristicDatumInsertCacheMut       sync.RWMutex
	sapCharacteristicCharacteristicDatumInsertCache          = make(map[string]insertCache)
	sapCharacteristicCharacteristicDatumUpdateCacheMut       sync.RWMutex
	sapCharacteristicCharacteristicDatumUpdateCache          = make(map[string]updateCache)
	sapCharacteristicCharacteristicDatumUpsertCacheMut       sync.RWMutex
	sapCharacteristicCharacteristicDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapCharacteristicCharacteristicDatumAfterSelectHooks []SapCharacteristicCharacteristicDatumHook

var sapCharacteristicCharacteristicDatumBeforeInsertHooks []SapCharacteristicCharacteristicDatumHook
var sapCharacteristicCharacteristicDatumAfterInsertHooks []SapCharacteristicCharacteristicDatumHook

var sapCharacteristicCharacteristicDatumBeforeUpdateHooks []SapCharacteristicCharacteristicDatumHook
var sapCharacteristicCharacteristicDatumAfterUpdateHooks []SapCharacteristicCharacteristicDatumHook

var sapCharacteristicCharacteristicDatumBeforeDeleteHooks []SapCharacteristicCharacteristicDatumHook
var sapCharacteristicCharacteristicDatumAfterDeleteHooks []SapCharacteristicCharacteristicDatumHook

var sapCharacteristicCharacteristicDatumBeforeUpsertHooks []SapCharacteristicCharacteristicDatumHook
var sapCharacteristicCharacteristicDatumAfterUpsertHooks []SapCharacteristicCharacteristicDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapCharacteristicCharacteristicDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapCharacteristicCharacteristicDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapCharacteristicCharacteristicDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapCharacteristicCharacteristicDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapCharacteristicCharacteristicDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapCharacteristicCharacteristicDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapCharacteristicCharacteristicDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapCharacteristicCharacteristicDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapCharacteristicCharacteristicDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapCharacteristicCharacteristicDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapCharacteristicCharacteristicDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapCharacteristicCharacteristicDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapCharacteristicCharacteristicDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapCharacteristicCharacteristicDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapCharacteristicCharacteristicDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapCharacteristicCharacteristicDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapCharacteristicCharacteristicDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapCharacteristicCharacteristicDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapCharacteristicCharacteristicDatumHook registers your hook function for all future operations.
func AddSapCharacteristicCharacteristicDatumHook(hookPoint boil.HookPoint, sapCharacteristicCharacteristicDatumHook SapCharacteristicCharacteristicDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapCharacteristicCharacteristicDatumAfterSelectHooks = append(sapCharacteristicCharacteristicDatumAfterSelectHooks, sapCharacteristicCharacteristicDatumHook)
	case boil.BeforeInsertHook:
		sapCharacteristicCharacteristicDatumBeforeInsertHooks = append(sapCharacteristicCharacteristicDatumBeforeInsertHooks, sapCharacteristicCharacteristicDatumHook)
	case boil.AfterInsertHook:
		sapCharacteristicCharacteristicDatumAfterInsertHooks = append(sapCharacteristicCharacteristicDatumAfterInsertHooks, sapCharacteristicCharacteristicDatumHook)
	case boil.BeforeUpdateHook:
		sapCharacteristicCharacteristicDatumBeforeUpdateHooks = append(sapCharacteristicCharacteristicDatumBeforeUpdateHooks, sapCharacteristicCharacteristicDatumHook)
	case boil.AfterUpdateHook:
		sapCharacteristicCharacteristicDatumAfterUpdateHooks = append(sapCharacteristicCharacteristicDatumAfterUpdateHooks, sapCharacteristicCharacteristicDatumHook)
	case boil.BeforeDeleteHook:
		sapCharacteristicCharacteristicDatumBeforeDeleteHooks = append(sapCharacteristicCharacteristicDatumBeforeDeleteHooks, sapCharacteristicCharacteristicDatumHook)
	case boil.AfterDeleteHook:
		sapCharacteristicCharacteristicDatumAfterDeleteHooks = append(sapCharacteristicCharacteristicDatumAfterDeleteHooks, sapCharacteristicCharacteristicDatumHook)
	case boil.BeforeUpsertHook:
		sapCharacteristicCharacteristicDatumBeforeUpsertHooks = append(sapCharacteristicCharacteristicDatumBeforeUpsertHooks, sapCharacteristicCharacteristicDatumHook)
	case boil.AfterUpsertHook:
		sapCharacteristicCharacteristicDatumAfterUpsertHooks = append(sapCharacteristicCharacteristicDatumAfterUpsertHooks, sapCharacteristicCharacteristicDatumHook)
	}
}

// One returns a single sapCharacteristicCharacteristicDatum record from the query.
func (q sapCharacteristicCharacteristicDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapCharacteristicCharacteristicDatum, error) {
	o := &SapCharacteristicCharacteristicDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_characteristic_characteristic_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapCharacteristicCharacteristicDatum records from the query.
func (q sapCharacteristicCharacteristicDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapCharacteristicCharacteristicDatumSlice, error) {
	var o []*SapCharacteristicCharacteristicDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapCharacteristicCharacteristicDatum slice")
	}

	if len(sapCharacteristicCharacteristicDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapCharacteristicCharacteristicDatum records in the query.
func (q sapCharacteristicCharacteristicDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_characteristic_characteristic_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapCharacteristicCharacteristicDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_characteristic_characteristic_data exists")
	}

	return count > 0, nil
}

// CharcInternalIDSapCharacteristicCharcDescriptionData retrieves all the sap_characteristic_charc_description_datum's SapCharacteristicCharcDescriptionData with an executor via CharcInternalID column.
func (o *SapCharacteristicCharacteristicDatum) CharcInternalIDSapCharacteristicCharcDescriptionData(mods ...qm.QueryMod) sapCharacteristicCharcDescriptionDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_characteristic_charc_description_data`.`CharcInternalID`=?", o.CharcInternalID),
	)

	query := SapCharacteristicCharcDescriptionData(queryMods...)
	queries.SetFrom(query.Query, "`sap_characteristic_charc_description_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_characteristic_charc_description_data`.*"})
	}

	return query
}

// CharcInternalIDSapCharacteristicValueData retrieves all the sap_characteristic_value_datum's SapCharacteristicValueData with an executor via CharcInternalID column.
func (o *SapCharacteristicCharacteristicDatum) CharcInternalIDSapCharacteristicValueData(mods ...qm.QueryMod) sapCharacteristicValueDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_characteristic_value_data`.`CharcInternalID`=?", o.CharcInternalID),
	)

	query := SapCharacteristicValueData(queryMods...)
	queries.SetFrom(query.Query, "`sap_characteristic_value_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_characteristic_value_data`.*"})
	}

	return query
}

// CharcInternalIDSapCharacteristicValueDescriptionData retrieves all the sap_characteristic_value_description_datum's SapCharacteristicValueDescriptionData with an executor via CharcInternalID column.
func (o *SapCharacteristicCharacteristicDatum) CharcInternalIDSapCharacteristicValueDescriptionData(mods ...qm.QueryMod) sapCharacteristicValueDescriptionDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_characteristic_value_description_data`.`CharcInternalID`=?", o.CharcInternalID),
	)

	query := SapCharacteristicValueDescriptionData(queryMods...)
	queries.SetFrom(query.Query, "`sap_characteristic_value_description_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_characteristic_value_description_data`.*"})
	}

	return query
}

// LoadCharcInternalIDSapCharacteristicCharcDescriptionData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapCharacteristicCharacteristicDatumL) LoadCharcInternalIDSapCharacteristicCharcDescriptionData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapCharacteristicCharacteristicDatum interface{}, mods queries.Applicator) error {
	var slice []*SapCharacteristicCharacteristicDatum
	var object *SapCharacteristicCharacteristicDatum

	if singular {
		object = maybeSapCharacteristicCharacteristicDatum.(*SapCharacteristicCharacteristicDatum)
	} else {
		slice = *maybeSapCharacteristicCharacteristicDatum.(*[]*SapCharacteristicCharacteristicDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapCharacteristicCharacteristicDatumR{}
		}
		args = append(args, object.CharcInternalID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapCharacteristicCharacteristicDatumR{}
			}

			for _, a := range args {
				if a == obj.CharcInternalID {
					continue Outer
				}
			}

			args = append(args, obj.CharcInternalID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_characteristic_charc_description_data`),
		qm.WhereIn(`sap_characteristic_charc_description_data.CharcInternalID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_characteristic_charc_description_data")
	}

	var resultSlice []*SapCharacteristicCharcDescriptionDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_characteristic_charc_description_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_characteristic_charc_description_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_characteristic_charc_description_data")
	}

	if len(sapCharacteristicCharcDescriptionDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CharcInternalIDSapCharacteristicCharcDescriptionData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapCharacteristicCharcDescriptionDatumR{}
			}
			foreign.R.CharcInternalIDSapCharacteristicCharacteristicDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.CharcInternalID == foreign.CharcInternalID {
				local.R.CharcInternalIDSapCharacteristicCharcDescriptionData = append(local.R.CharcInternalIDSapCharacteristicCharcDescriptionData, foreign)
				if foreign.R == nil {
					foreign.R = &sapCharacteristicCharcDescriptionDatumR{}
				}
				foreign.R.CharcInternalIDSapCharacteristicCharacteristicDatum = local
				break
			}
		}
	}

	return nil
}

// LoadCharcInternalIDSapCharacteristicValueData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapCharacteristicCharacteristicDatumL) LoadCharcInternalIDSapCharacteristicValueData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapCharacteristicCharacteristicDatum interface{}, mods queries.Applicator) error {
	var slice []*SapCharacteristicCharacteristicDatum
	var object *SapCharacteristicCharacteristicDatum

	if singular {
		object = maybeSapCharacteristicCharacteristicDatum.(*SapCharacteristicCharacteristicDatum)
	} else {
		slice = *maybeSapCharacteristicCharacteristicDatum.(*[]*SapCharacteristicCharacteristicDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapCharacteristicCharacteristicDatumR{}
		}
		args = append(args, object.CharcInternalID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapCharacteristicCharacteristicDatumR{}
			}

			for _, a := range args {
				if a == obj.CharcInternalID {
					continue Outer
				}
			}

			args = append(args, obj.CharcInternalID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_characteristic_value_data`),
		qm.WhereIn(`sap_characteristic_value_data.CharcInternalID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_characteristic_value_data")
	}

	var resultSlice []*SapCharacteristicValueDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_characteristic_value_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_characteristic_value_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_characteristic_value_data")
	}

	if len(sapCharacteristicValueDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CharcInternalIDSapCharacteristicValueData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapCharacteristicValueDatumR{}
			}
			foreign.R.CharcInternalIDSapCharacteristicCharacteristicDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.CharcInternalID == foreign.CharcInternalID {
				local.R.CharcInternalIDSapCharacteristicValueData = append(local.R.CharcInternalIDSapCharacteristicValueData, foreign)
				if foreign.R == nil {
					foreign.R = &sapCharacteristicValueDatumR{}
				}
				foreign.R.CharcInternalIDSapCharacteristicCharacteristicDatum = local
				break
			}
		}
	}

	return nil
}

// LoadCharcInternalIDSapCharacteristicValueDescriptionData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapCharacteristicCharacteristicDatumL) LoadCharcInternalIDSapCharacteristicValueDescriptionData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapCharacteristicCharacteristicDatum interface{}, mods queries.Applicator) error {
	var slice []*SapCharacteristicCharacteristicDatum
	var object *SapCharacteristicCharacteristicDatum

	if singular {
		object = maybeSapCharacteristicCharacteristicDatum.(*SapCharacteristicCharacteristicDatum)
	} else {
		slice = *maybeSapCharacteristicCharacteristicDatum.(*[]*SapCharacteristicCharacteristicDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapCharacteristicCharacteristicDatumR{}
		}
		args = append(args, object.CharcInternalID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapCharacteristicCharacteristicDatumR{}
			}

			for _, a := range args {
				if a == obj.CharcInternalID {
					continue Outer
				}
			}

			args = append(args, obj.CharcInternalID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_characteristic_value_description_data`),
		qm.WhereIn(`sap_characteristic_value_description_data.CharcInternalID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_characteristic_value_description_data")
	}

	var resultSlice []*SapCharacteristicValueDescriptionDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_characteristic_value_description_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_characteristic_value_description_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_characteristic_value_description_data")
	}

	if len(sapCharacteristicValueDescriptionDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CharcInternalIDSapCharacteristicValueDescriptionData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapCharacteristicValueDescriptionDatumR{}
			}
			foreign.R.CharcInternalIDSapCharacteristicCharacteristicDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.CharcInternalID == foreign.CharcInternalID {
				local.R.CharcInternalIDSapCharacteristicValueDescriptionData = append(local.R.CharcInternalIDSapCharacteristicValueDescriptionData, foreign)
				if foreign.R == nil {
					foreign.R = &sapCharacteristicValueDescriptionDatumR{}
				}
				foreign.R.CharcInternalIDSapCharacteristicCharacteristicDatum = local
				break
			}
		}
	}

	return nil
}

// AddCharcInternalIDSapCharacteristicCharcDescriptionData adds the given related objects to the existing relationships
// of the sap_characteristic_characteristic_datum, optionally inserting them as new records.
// Appends related to o.R.CharcInternalIDSapCharacteristicCharcDescriptionData.
// Sets related.R.CharcInternalIDSapCharacteristicCharacteristicDatum appropriately.
func (o *SapCharacteristicCharacteristicDatum) AddCharcInternalIDSapCharacteristicCharcDescriptionData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapCharacteristicCharcDescriptionDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CharcInternalID = o.CharcInternalID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_characteristic_charc_description_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"CharcInternalID"}),
				strmangle.WhereClause("`", "`", 0, sapCharacteristicCharcDescriptionDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.CharcInternalID, rel.CharcInternalID, rel.Language}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CharcInternalID = o.CharcInternalID
		}
	}

	if o.R == nil {
		o.R = &sapCharacteristicCharacteristicDatumR{
			CharcInternalIDSapCharacteristicCharcDescriptionData: related,
		}
	} else {
		o.R.CharcInternalIDSapCharacteristicCharcDescriptionData = append(o.R.CharcInternalIDSapCharacteristicCharcDescriptionData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapCharacteristicCharcDescriptionDatumR{
				CharcInternalIDSapCharacteristicCharacteristicDatum: o,
			}
		} else {
			rel.R.CharcInternalIDSapCharacteristicCharacteristicDatum = o
		}
	}
	return nil
}

// AddCharcInternalIDSapCharacteristicValueData adds the given related objects to the existing relationships
// of the sap_characteristic_characteristic_datum, optionally inserting them as new records.
// Appends related to o.R.CharcInternalIDSapCharacteristicValueData.
// Sets related.R.CharcInternalIDSapCharacteristicCharacteristicDatum appropriately.
func (o *SapCharacteristicCharacteristicDatum) AddCharcInternalIDSapCharacteristicValueData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapCharacteristicValueDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CharcInternalID = o.CharcInternalID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_characteristic_value_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"CharcInternalID"}),
				strmangle.WhereClause("`", "`", 0, sapCharacteristicValueDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.CharcInternalID, rel.CharcInternalID, rel.CharcValuePositionNumber}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CharcInternalID = o.CharcInternalID
		}
	}

	if o.R == nil {
		o.R = &sapCharacteristicCharacteristicDatumR{
			CharcInternalIDSapCharacteristicValueData: related,
		}
	} else {
		o.R.CharcInternalIDSapCharacteristicValueData = append(o.R.CharcInternalIDSapCharacteristicValueData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapCharacteristicValueDatumR{
				CharcInternalIDSapCharacteristicCharacteristicDatum: o,
			}
		} else {
			rel.R.CharcInternalIDSapCharacteristicCharacteristicDatum = o
		}
	}
	return nil
}

// AddCharcInternalIDSapCharacteristicValueDescriptionData adds the given related objects to the existing relationships
// of the sap_characteristic_characteristic_datum, optionally inserting them as new records.
// Appends related to o.R.CharcInternalIDSapCharacteristicValueDescriptionData.
// Sets related.R.CharcInternalIDSapCharacteristicCharacteristicDatum appropriately.
func (o *SapCharacteristicCharacteristicDatum) AddCharcInternalIDSapCharacteristicValueDescriptionData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapCharacteristicValueDescriptionDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CharcInternalID = o.CharcInternalID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_characteristic_value_description_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"CharcInternalID"}),
				strmangle.WhereClause("`", "`", 0, sapCharacteristicValueDescriptionDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.CharcInternalID, rel.CharcInternalID, rel.CharcValuePositionNumber, rel.Language}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CharcInternalID = o.CharcInternalID
		}
	}

	if o.R == nil {
		o.R = &sapCharacteristicCharacteristicDatumR{
			CharcInternalIDSapCharacteristicValueDescriptionData: related,
		}
	} else {
		o.R.CharcInternalIDSapCharacteristicValueDescriptionData = append(o.R.CharcInternalIDSapCharacteristicValueDescriptionData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapCharacteristicValueDescriptionDatumR{
				CharcInternalIDSapCharacteristicCharacteristicDatum: o,
			}
		} else {
			rel.R.CharcInternalIDSapCharacteristicCharacteristicDatum = o
		}
	}
	return nil
}

// SapCharacteristicCharacteristicData retrieves all the records using an executor.
func SapCharacteristicCharacteristicData(mods ...qm.QueryMod) sapCharacteristicCharacteristicDatumQuery {
	mods = append(mods, qm.From("`sap_characteristic_characteristic_data`"))
	return sapCharacteristicCharacteristicDatumQuery{NewQuery(mods...)}
}

// FindSapCharacteristicCharacteristicDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapCharacteristicCharacteristicDatum(ctx context.Context, exec boil.ContextExecutor, charcInternalID string, selectCols ...string) (*SapCharacteristicCharacteristicDatum, error) {
	sapCharacteristicCharacteristicDatumObj := &SapCharacteristicCharacteristicDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_characteristic_characteristic_data` where `CharcInternalID`=?", sel,
	)

	q := queries.Raw(query, charcInternalID)

	err := q.Bind(ctx, exec, sapCharacteristicCharacteristicDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_characteristic_characteristic_data")
	}

	if err = sapCharacteristicCharacteristicDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapCharacteristicCharacteristicDatumObj, err
	}

	return sapCharacteristicCharacteristicDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapCharacteristicCharacteristicDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_characteristic_characteristic_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapCharacteristicCharacteristicDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapCharacteristicCharacteristicDatumInsertCacheMut.RLock()
	cache, cached := sapCharacteristicCharacteristicDatumInsertCache[key]
	sapCharacteristicCharacteristicDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapCharacteristicCharacteristicDatumAllColumns,
			sapCharacteristicCharacteristicDatumColumnsWithDefault,
			sapCharacteristicCharacteristicDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapCharacteristicCharacteristicDatumType, sapCharacteristicCharacteristicDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapCharacteristicCharacteristicDatumType, sapCharacteristicCharacteristicDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_characteristic_characteristic_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_characteristic_characteristic_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_characteristic_characteristic_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapCharacteristicCharacteristicDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_characteristic_characteristic_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.CharcInternalID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_characteristic_characteristic_data")
	}

CacheNoHooks:
	if !cached {
		sapCharacteristicCharacteristicDatumInsertCacheMut.Lock()
		sapCharacteristicCharacteristicDatumInsertCache[key] = cache
		sapCharacteristicCharacteristicDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapCharacteristicCharacteristicDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapCharacteristicCharacteristicDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapCharacteristicCharacteristicDatumUpdateCacheMut.RLock()
	cache, cached := sapCharacteristicCharacteristicDatumUpdateCache[key]
	sapCharacteristicCharacteristicDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapCharacteristicCharacteristicDatumAllColumns,
			sapCharacteristicCharacteristicDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_characteristic_characteristic_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_characteristic_characteristic_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapCharacteristicCharacteristicDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapCharacteristicCharacteristicDatumType, sapCharacteristicCharacteristicDatumMapping, append(wl, sapCharacteristicCharacteristicDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_characteristic_characteristic_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_characteristic_characteristic_data")
	}

	if !cached {
		sapCharacteristicCharacteristicDatumUpdateCacheMut.Lock()
		sapCharacteristicCharacteristicDatumUpdateCache[key] = cache
		sapCharacteristicCharacteristicDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapCharacteristicCharacteristicDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_characteristic_characteristic_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_characteristic_characteristic_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapCharacteristicCharacteristicDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapCharacteristicCharacteristicDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_characteristic_characteristic_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapCharacteristicCharacteristicDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapCharacteristicCharacteristicDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapCharacteristicCharacteristicDatum")
	}
	return rowsAff, nil
}

var mySQLSapCharacteristicCharacteristicDatumUniqueColumns = []string{
	"CharcInternalID",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapCharacteristicCharacteristicDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_characteristic_characteristic_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapCharacteristicCharacteristicDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapCharacteristicCharacteristicDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapCharacteristicCharacteristicDatumUpsertCacheMut.RLock()
	cache, cached := sapCharacteristicCharacteristicDatumUpsertCache[key]
	sapCharacteristicCharacteristicDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapCharacteristicCharacteristicDatumAllColumns,
			sapCharacteristicCharacteristicDatumColumnsWithDefault,
			sapCharacteristicCharacteristicDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapCharacteristicCharacteristicDatumAllColumns,
			sapCharacteristicCharacteristicDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_characteristic_characteristic_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_characteristic_characteristic_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_characteristic_characteristic_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapCharacteristicCharacteristicDatumType, sapCharacteristicCharacteristicDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapCharacteristicCharacteristicDatumType, sapCharacteristicCharacteristicDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_characteristic_characteristic_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapCharacteristicCharacteristicDatumType, sapCharacteristicCharacteristicDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_characteristic_characteristic_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_characteristic_characteristic_data")
	}

CacheNoHooks:
	if !cached {
		sapCharacteristicCharacteristicDatumUpsertCacheMut.Lock()
		sapCharacteristicCharacteristicDatumUpsertCache[key] = cache
		sapCharacteristicCharacteristicDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapCharacteristicCharacteristicDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapCharacteristicCharacteristicDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapCharacteristicCharacteristicDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapCharacteristicCharacteristicDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_characteristic_characteristic_data` WHERE `CharcInternalID`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_characteristic_characteristic_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_characteristic_characteristic_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapCharacteristicCharacteristicDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapCharacteristicCharacteristicDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_characteristic_characteristic_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_characteristic_characteristic_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapCharacteristicCharacteristicDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapCharacteristicCharacteristicDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapCharacteristicCharacteristicDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_characteristic_characteristic_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapCharacteristicCharacteristicDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapCharacteristicCharacteristicDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_characteristic_characteristic_data")
	}

	if len(sapCharacteristicCharacteristicDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapCharacteristicCharacteristicDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapCharacteristicCharacteristicDatum(ctx, exec, o.CharcInternalID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapCharacteristicCharacteristicDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapCharacteristicCharacteristicDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapCharacteristicCharacteristicDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_characteristic_characteristic_data`.* FROM `sap_characteristic_characteristic_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapCharacteristicCharacteristicDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapCharacteristicCharacteristicDatumSlice")
	}

	*o = slice

	return nil
}

// SapCharacteristicCharacteristicDatumExists checks if the SapCharacteristicCharacteristicDatum row exists.
func SapCharacteristicCharacteristicDatumExists(ctx context.Context, exec boil.ContextExecutor, charcInternalID string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_characteristic_characteristic_data` where `CharcInternalID`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, charcInternalID)
	}
	row := exec.QueryRowContext(ctx, sql, charcInternalID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_characteristic_characteristic_data exists")
	}

	return exists, nil
}
