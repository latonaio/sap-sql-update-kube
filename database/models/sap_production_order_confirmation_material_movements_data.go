// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapProductionOrderConfirmationMaterialMovementsDatum is an object representing the database table.
type SapProductionOrderConfirmationMaterialMovementsDatum struct {
	ConfirmationGroup          string      `boil:"ConfirmationGroup" json:"ConfirmationGroup" toml:"ConfirmationGroup" yaml:"ConfirmationGroup"`
	ConfirmationCount          string      `boil:"ConfirmationCount" json:"ConfirmationCount" toml:"ConfirmationCount" yaml:"ConfirmationCount"`
	MaterialDocument           string      `boil:"MaterialDocument" json:"MaterialDocument" toml:"MaterialDocument" yaml:"MaterialDocument"`
	MaterialDocumentItem       string      `boil:"MaterialDocumentItem" json:"MaterialDocumentItem" toml:"MaterialDocumentItem" yaml:"MaterialDocumentItem"`
	MaterialDocumentYear       string      `boil:"MaterialDocumentYear" json:"MaterialDocumentYear" toml:"MaterialDocumentYear" yaml:"MaterialDocumentYear"`
	OrderType                  null.String `boil:"OrderType" json:"OrderType,omitempty" toml:"OrderType" yaml:"OrderType,omitempty"`
	OrderID                    null.String `boil:"OrderID" json:"OrderID,omitempty" toml:"OrderID" yaml:"OrderID,omitempty"`
	OrderItem                  null.String `boil:"OrderItem" json:"OrderItem,omitempty" toml:"OrderItem" yaml:"OrderItem,omitempty"`
	ManufacturingOrderCategory null.String `boil:"ManufacturingOrderCategory" json:"ManufacturingOrderCategory,omitempty" toml:"ManufacturingOrderCategory" yaml:"ManufacturingOrderCategory,omitempty"`
	Material                   null.String `boil:"Material" json:"Material,omitempty" toml:"Material" yaml:"Material,omitempty"`
	Plant                      null.String `boil:"Plant" json:"Plant,omitempty" toml:"Plant" yaml:"Plant,omitempty"`
	Reservation                null.String `boil:"Reservation" json:"Reservation,omitempty" toml:"Reservation" yaml:"Reservation,omitempty"`
	ReservationItem            null.String `boil:"ReservationItem" json:"ReservationItem,omitempty" toml:"ReservationItem" yaml:"ReservationItem,omitempty"`
	StorageLocation            null.String `boil:"StorageLocation" json:"StorageLocation,omitempty" toml:"StorageLocation" yaml:"StorageLocation,omitempty"`
	ProductionSupplyArea       null.String `boil:"ProductionSupplyArea" json:"ProductionSupplyArea,omitempty" toml:"ProductionSupplyArea" yaml:"ProductionSupplyArea,omitempty"`
	Batch                      null.String `boil:"Batch" json:"Batch,omitempty" toml:"Batch" yaml:"Batch,omitempty"`
	InventoryValuationType     null.String `boil:"InventoryValuationType" json:"InventoryValuationType,omitempty" toml:"InventoryValuationType" yaml:"InventoryValuationType,omitempty"`
	GoodsMovementType          null.String `boil:"GoodsMovementType" json:"GoodsMovementType,omitempty" toml:"GoodsMovementType" yaml:"GoodsMovementType,omitempty"`
	GoodsMovementRefDocType    null.String `boil:"GoodsMovementRefDocType" json:"GoodsMovementRefDocType,omitempty" toml:"GoodsMovementRefDocType" yaml:"GoodsMovementRefDocType,omitempty"`
	InventoryUsabilityCode     null.String `boil:"InventoryUsabilityCode" json:"InventoryUsabilityCode,omitempty" toml:"InventoryUsabilityCode" yaml:"InventoryUsabilityCode,omitempty"`
	InventorySpecialStockType  null.String `boil:"InventorySpecialStockType" json:"InventorySpecialStockType,omitempty" toml:"InventorySpecialStockType" yaml:"InventorySpecialStockType,omitempty"`
	SalesOrder                 null.String `boil:"SalesOrder" json:"SalesOrder,omitempty" toml:"SalesOrder" yaml:"SalesOrder,omitempty"`
	SalesOrderItem             null.String `boil:"SalesOrderItem" json:"SalesOrderItem,omitempty" toml:"SalesOrderItem" yaml:"SalesOrderItem,omitempty"`
	WBSElementExternalID       null.String `boil:"WBSElementExternalID" json:"WBSElementExternalID,omitempty" toml:"WBSElementExternalID" yaml:"WBSElementExternalID,omitempty"`
	Supplier                   null.String `boil:"Supplier" json:"Supplier,omitempty" toml:"Supplier" yaml:"Supplier,omitempty"`
	Customer                   null.String `boil:"Customer" json:"Customer,omitempty" toml:"Customer" yaml:"Customer,omitempty"`
	ReservationIsFinallyIssued null.Bool   `boil:"ReservationIsFinallyIssued" json:"ReservationIsFinallyIssued,omitempty" toml:"ReservationIsFinallyIssued" yaml:"ReservationIsFinallyIssued,omitempty"`
	IsCompletelyDelivered      null.Bool   `boil:"IsCompletelyDelivered" json:"IsCompletelyDelivered,omitempty" toml:"IsCompletelyDelivered" yaml:"IsCompletelyDelivered,omitempty"`
	ShelfLifeExpirationDate    null.String `boil:"ShelfLifeExpirationDate" json:"ShelfLifeExpirationDate,omitempty" toml:"ShelfLifeExpirationDate" yaml:"ShelfLifeExpirationDate,omitempty"`
	ManufactureDate            null.String `boil:"ManufactureDate" json:"ManufactureDate,omitempty" toml:"ManufactureDate" yaml:"ManufactureDate,omitempty"`
	StorageType                null.String `boil:"StorageType" json:"StorageType,omitempty" toml:"StorageType" yaml:"StorageType,omitempty"`
	StorageBin                 null.String `boil:"StorageBin" json:"StorageBin,omitempty" toml:"StorageBin" yaml:"StorageBin,omitempty"`
	MaterialDocumentItemText   null.String `boil:"MaterialDocumentItemText" json:"MaterialDocumentItemText,omitempty" toml:"MaterialDocumentItemText" yaml:"MaterialDocumentItemText,omitempty"`
	EntryUnit                  null.String `boil:"EntryUnit" json:"EntryUnit,omitempty" toml:"EntryUnit" yaml:"EntryUnit,omitempty"`
	QuantityInEntryUnit        null.String `boil:"QuantityInEntryUnit" json:"QuantityInEntryUnit,omitempty" toml:"QuantityInEntryUnit" yaml:"QuantityInEntryUnit,omitempty"`

	R *sapProductionOrderConfirmationMaterialMovementsDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapProductionOrderConfirmationMaterialMovementsDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapProductionOrderConfirmationMaterialMovementsDatumColumns = struct {
	ConfirmationGroup          string
	ConfirmationCount          string
	MaterialDocument           string
	MaterialDocumentItem       string
	MaterialDocumentYear       string
	OrderType                  string
	OrderID                    string
	OrderItem                  string
	ManufacturingOrderCategory string
	Material                   string
	Plant                      string
	Reservation                string
	ReservationItem            string
	StorageLocation            string
	ProductionSupplyArea       string
	Batch                      string
	InventoryValuationType     string
	GoodsMovementType          string
	GoodsMovementRefDocType    string
	InventoryUsabilityCode     string
	InventorySpecialStockType  string
	SalesOrder                 string
	SalesOrderItem             string
	WBSElementExternalID       string
	Supplier                   string
	Customer                   string
	ReservationIsFinallyIssued string
	IsCompletelyDelivered      string
	ShelfLifeExpirationDate    string
	ManufactureDate            string
	StorageType                string
	StorageBin                 string
	MaterialDocumentItemText   string
	EntryUnit                  string
	QuantityInEntryUnit        string
}{
	ConfirmationGroup:          "ConfirmationGroup",
	ConfirmationCount:          "ConfirmationCount",
	MaterialDocument:           "MaterialDocument",
	MaterialDocumentItem:       "MaterialDocumentItem",
	MaterialDocumentYear:       "MaterialDocumentYear",
	OrderType:                  "OrderType",
	OrderID:                    "OrderID",
	OrderItem:                  "OrderItem",
	ManufacturingOrderCategory: "ManufacturingOrderCategory",
	Material:                   "Material",
	Plant:                      "Plant",
	Reservation:                "Reservation",
	ReservationItem:            "ReservationItem",
	StorageLocation:            "StorageLocation",
	ProductionSupplyArea:       "ProductionSupplyArea",
	Batch:                      "Batch",
	InventoryValuationType:     "InventoryValuationType",
	GoodsMovementType:          "GoodsMovementType",
	GoodsMovementRefDocType:    "GoodsMovementRefDocType",
	InventoryUsabilityCode:     "InventoryUsabilityCode",
	InventorySpecialStockType:  "InventorySpecialStockType",
	SalesOrder:                 "SalesOrder",
	SalesOrderItem:             "SalesOrderItem",
	WBSElementExternalID:       "WBSElementExternalID",
	Supplier:                   "Supplier",
	Customer:                   "Customer",
	ReservationIsFinallyIssued: "ReservationIsFinallyIssued",
	IsCompletelyDelivered:      "IsCompletelyDelivered",
	ShelfLifeExpirationDate:    "ShelfLifeExpirationDate",
	ManufactureDate:            "ManufactureDate",
	StorageType:                "StorageType",
	StorageBin:                 "StorageBin",
	MaterialDocumentItemText:   "MaterialDocumentItemText",
	EntryUnit:                  "EntryUnit",
	QuantityInEntryUnit:        "QuantityInEntryUnit",
}

var SapProductionOrderConfirmationMaterialMovementsDatumTableColumns = struct {
	ConfirmationGroup          string
	ConfirmationCount          string
	MaterialDocument           string
	MaterialDocumentItem       string
	MaterialDocumentYear       string
	OrderType                  string
	OrderID                    string
	OrderItem                  string
	ManufacturingOrderCategory string
	Material                   string
	Plant                      string
	Reservation                string
	ReservationItem            string
	StorageLocation            string
	ProductionSupplyArea       string
	Batch                      string
	InventoryValuationType     string
	GoodsMovementType          string
	GoodsMovementRefDocType    string
	InventoryUsabilityCode     string
	InventorySpecialStockType  string
	SalesOrder                 string
	SalesOrderItem             string
	WBSElementExternalID       string
	Supplier                   string
	Customer                   string
	ReservationIsFinallyIssued string
	IsCompletelyDelivered      string
	ShelfLifeExpirationDate    string
	ManufactureDate            string
	StorageType                string
	StorageBin                 string
	MaterialDocumentItemText   string
	EntryUnit                  string
	QuantityInEntryUnit        string
}{
	ConfirmationGroup:          "sap_production_order_confirmation_material_movements_data.ConfirmationGroup",
	ConfirmationCount:          "sap_production_order_confirmation_material_movements_data.ConfirmationCount",
	MaterialDocument:           "sap_production_order_confirmation_material_movements_data.MaterialDocument",
	MaterialDocumentItem:       "sap_production_order_confirmation_material_movements_data.MaterialDocumentItem",
	MaterialDocumentYear:       "sap_production_order_confirmation_material_movements_data.MaterialDocumentYear",
	OrderType:                  "sap_production_order_confirmation_material_movements_data.OrderType",
	OrderID:                    "sap_production_order_confirmation_material_movements_data.OrderID",
	OrderItem:                  "sap_production_order_confirmation_material_movements_data.OrderItem",
	ManufacturingOrderCategory: "sap_production_order_confirmation_material_movements_data.ManufacturingOrderCategory",
	Material:                   "sap_production_order_confirmation_material_movements_data.Material",
	Plant:                      "sap_production_order_confirmation_material_movements_data.Plant",
	Reservation:                "sap_production_order_confirmation_material_movements_data.Reservation",
	ReservationItem:            "sap_production_order_confirmation_material_movements_data.ReservationItem",
	StorageLocation:            "sap_production_order_confirmation_material_movements_data.StorageLocation",
	ProductionSupplyArea:       "sap_production_order_confirmation_material_movements_data.ProductionSupplyArea",
	Batch:                      "sap_production_order_confirmation_material_movements_data.Batch",
	InventoryValuationType:     "sap_production_order_confirmation_material_movements_data.InventoryValuationType",
	GoodsMovementType:          "sap_production_order_confirmation_material_movements_data.GoodsMovementType",
	GoodsMovementRefDocType:    "sap_production_order_confirmation_material_movements_data.GoodsMovementRefDocType",
	InventoryUsabilityCode:     "sap_production_order_confirmation_material_movements_data.InventoryUsabilityCode",
	InventorySpecialStockType:  "sap_production_order_confirmation_material_movements_data.InventorySpecialStockType",
	SalesOrder:                 "sap_production_order_confirmation_material_movements_data.SalesOrder",
	SalesOrderItem:             "sap_production_order_confirmation_material_movements_data.SalesOrderItem",
	WBSElementExternalID:       "sap_production_order_confirmation_material_movements_data.WBSElementExternalID",
	Supplier:                   "sap_production_order_confirmation_material_movements_data.Supplier",
	Customer:                   "sap_production_order_confirmation_material_movements_data.Customer",
	ReservationIsFinallyIssued: "sap_production_order_confirmation_material_movements_data.ReservationIsFinallyIssued",
	IsCompletelyDelivered:      "sap_production_order_confirmation_material_movements_data.IsCompletelyDelivered",
	ShelfLifeExpirationDate:    "sap_production_order_confirmation_material_movements_data.ShelfLifeExpirationDate",
	ManufactureDate:            "sap_production_order_confirmation_material_movements_data.ManufactureDate",
	StorageType:                "sap_production_order_confirmation_material_movements_data.StorageType",
	StorageBin:                 "sap_production_order_confirmation_material_movements_data.StorageBin",
	MaterialDocumentItemText:   "sap_production_order_confirmation_material_movements_data.MaterialDocumentItemText",
	EntryUnit:                  "sap_production_order_confirmation_material_movements_data.EntryUnit",
	QuantityInEntryUnit:        "sap_production_order_confirmation_material_movements_data.QuantityInEntryUnit",
}

// Generated where

var SapProductionOrderConfirmationMaterialMovementsDatumWhere = struct {
	ConfirmationGroup          whereHelperstring
	ConfirmationCount          whereHelperstring
	MaterialDocument           whereHelperstring
	MaterialDocumentItem       whereHelperstring
	MaterialDocumentYear       whereHelperstring
	OrderType                  whereHelpernull_String
	OrderID                    whereHelpernull_String
	OrderItem                  whereHelpernull_String
	ManufacturingOrderCategory whereHelpernull_String
	Material                   whereHelpernull_String
	Plant                      whereHelpernull_String
	Reservation                whereHelpernull_String
	ReservationItem            whereHelpernull_String
	StorageLocation            whereHelpernull_String
	ProductionSupplyArea       whereHelpernull_String
	Batch                      whereHelpernull_String
	InventoryValuationType     whereHelpernull_String
	GoodsMovementType          whereHelpernull_String
	GoodsMovementRefDocType    whereHelpernull_String
	InventoryUsabilityCode     whereHelpernull_String
	InventorySpecialStockType  whereHelpernull_String
	SalesOrder                 whereHelpernull_String
	SalesOrderItem             whereHelpernull_String
	WBSElementExternalID       whereHelpernull_String
	Supplier                   whereHelpernull_String
	Customer                   whereHelpernull_String
	ReservationIsFinallyIssued whereHelpernull_Bool
	IsCompletelyDelivered      whereHelpernull_Bool
	ShelfLifeExpirationDate    whereHelpernull_String
	ManufactureDate            whereHelpernull_String
	StorageType                whereHelpernull_String
	StorageBin                 whereHelpernull_String
	MaterialDocumentItemText   whereHelpernull_String
	EntryUnit                  whereHelpernull_String
	QuantityInEntryUnit        whereHelpernull_String
}{
	ConfirmationGroup:          whereHelperstring{field: "`sap_production_order_confirmation_material_movements_data`.`ConfirmationGroup`"},
	ConfirmationCount:          whereHelperstring{field: "`sap_production_order_confirmation_material_movements_data`.`ConfirmationCount`"},
	MaterialDocument:           whereHelperstring{field: "`sap_production_order_confirmation_material_movements_data`.`MaterialDocument`"},
	MaterialDocumentItem:       whereHelperstring{field: "`sap_production_order_confirmation_material_movements_data`.`MaterialDocumentItem`"},
	MaterialDocumentYear:       whereHelperstring{field: "`sap_production_order_confirmation_material_movements_data`.`MaterialDocumentYear`"},
	OrderType:                  whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`OrderType`"},
	OrderID:                    whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`OrderID`"},
	OrderItem:                  whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`OrderItem`"},
	ManufacturingOrderCategory: whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`ManufacturingOrderCategory`"},
	Material:                   whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`Material`"},
	Plant:                      whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`Plant`"},
	Reservation:                whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`Reservation`"},
	ReservationItem:            whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`ReservationItem`"},
	StorageLocation:            whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`StorageLocation`"},
	ProductionSupplyArea:       whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`ProductionSupplyArea`"},
	Batch:                      whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`Batch`"},
	InventoryValuationType:     whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`InventoryValuationType`"},
	GoodsMovementType:          whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`GoodsMovementType`"},
	GoodsMovementRefDocType:    whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`GoodsMovementRefDocType`"},
	InventoryUsabilityCode:     whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`InventoryUsabilityCode`"},
	InventorySpecialStockType:  whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`InventorySpecialStockType`"},
	SalesOrder:                 whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`SalesOrder`"},
	SalesOrderItem:             whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`SalesOrderItem`"},
	WBSElementExternalID:       whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`WBSElementExternalID`"},
	Supplier:                   whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`Supplier`"},
	Customer:                   whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`Customer`"},
	ReservationIsFinallyIssued: whereHelpernull_Bool{field: "`sap_production_order_confirmation_material_movements_data`.`ReservationIsFinallyIssued`"},
	IsCompletelyDelivered:      whereHelpernull_Bool{field: "`sap_production_order_confirmation_material_movements_data`.`IsCompletelyDelivered`"},
	ShelfLifeExpirationDate:    whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`ShelfLifeExpirationDate`"},
	ManufactureDate:            whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`ManufactureDate`"},
	StorageType:                whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`StorageType`"},
	StorageBin:                 whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`StorageBin`"},
	MaterialDocumentItemText:   whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`MaterialDocumentItemText`"},
	EntryUnit:                  whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`EntryUnit`"},
	QuantityInEntryUnit:        whereHelpernull_String{field: "`sap_production_order_confirmation_material_movements_data`.`QuantityInEntryUnit`"},
}

// SapProductionOrderConfirmationMaterialMovementsDatumRels is where relationship names are stored.
var SapProductionOrderConfirmationMaterialMovementsDatumRels = struct {
}{}

// sapProductionOrderConfirmationMaterialMovementsDatumR is where relationships are stored.
type sapProductionOrderConfirmationMaterialMovementsDatumR struct {
}

// NewStruct creates a new relationship struct
func (*sapProductionOrderConfirmationMaterialMovementsDatumR) NewStruct() *sapProductionOrderConfirmationMaterialMovementsDatumR {
	return &sapProductionOrderConfirmationMaterialMovementsDatumR{}
}

// sapProductionOrderConfirmationMaterialMovementsDatumL is where Load methods for each relationship are stored.
type sapProductionOrderConfirmationMaterialMovementsDatumL struct{}

var (
	sapProductionOrderConfirmationMaterialMovementsDatumAllColumns            = []string{"ConfirmationGroup", "ConfirmationCount", "MaterialDocument", "MaterialDocumentItem", "MaterialDocumentYear", "OrderType", "OrderID", "OrderItem", "ManufacturingOrderCategory", "Material", "Plant", "Reservation", "ReservationItem", "StorageLocation", "ProductionSupplyArea", "Batch", "InventoryValuationType", "GoodsMovementType", "GoodsMovementRefDocType", "InventoryUsabilityCode", "InventorySpecialStockType", "SalesOrder", "SalesOrderItem", "WBSElementExternalID", "Supplier", "Customer", "ReservationIsFinallyIssued", "IsCompletelyDelivered", "ShelfLifeExpirationDate", "ManufactureDate", "StorageType", "StorageBin", "MaterialDocumentItemText", "EntryUnit", "QuantityInEntryUnit"}
	sapProductionOrderConfirmationMaterialMovementsDatumColumnsWithoutDefault = []string{"ConfirmationGroup", "ConfirmationCount", "MaterialDocument", "MaterialDocumentItem", "MaterialDocumentYear", "OrderType", "OrderID", "OrderItem", "ManufacturingOrderCategory", "Material", "Plant", "Reservation", "ReservationItem", "StorageLocation", "ProductionSupplyArea", "Batch", "InventoryValuationType", "GoodsMovementType", "GoodsMovementRefDocType", "InventoryUsabilityCode", "InventorySpecialStockType", "SalesOrder", "SalesOrderItem", "WBSElementExternalID", "Supplier", "Customer", "ReservationIsFinallyIssued", "IsCompletelyDelivered", "ShelfLifeExpirationDate", "ManufactureDate", "StorageType", "StorageBin", "MaterialDocumentItemText", "EntryUnit", "QuantityInEntryUnit"}
	sapProductionOrderConfirmationMaterialMovementsDatumColumnsWithDefault    = []string{}
	sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns     = []string{"ConfirmationGroup", "ConfirmationCount", "MaterialDocument", "MaterialDocumentItem", "MaterialDocumentYear"}
	sapProductionOrderConfirmationMaterialMovementsDatumGeneratedColumns      = []string{}
)

type (
	// SapProductionOrderConfirmationMaterialMovementsDatumSlice is an alias for a slice of pointers to SapProductionOrderConfirmationMaterialMovementsDatum.
	// This should almost always be used instead of []SapProductionOrderConfirmationMaterialMovementsDatum.
	SapProductionOrderConfirmationMaterialMovementsDatumSlice []*SapProductionOrderConfirmationMaterialMovementsDatum
	// SapProductionOrderConfirmationMaterialMovementsDatumHook is the signature for custom SapProductionOrderConfirmationMaterialMovementsDatum hook methods
	SapProductionOrderConfirmationMaterialMovementsDatumHook func(context.Context, boil.ContextExecutor, *SapProductionOrderConfirmationMaterialMovementsDatum) error

	sapProductionOrderConfirmationMaterialMovementsDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapProductionOrderConfirmationMaterialMovementsDatumType                 = reflect.TypeOf(&SapProductionOrderConfirmationMaterialMovementsDatum{})
	sapProductionOrderConfirmationMaterialMovementsDatumMapping              = queries.MakeStructMapping(sapProductionOrderConfirmationMaterialMovementsDatumType)
	sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyMapping, _ = queries.BindMapping(sapProductionOrderConfirmationMaterialMovementsDatumType, sapProductionOrderConfirmationMaterialMovementsDatumMapping, sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns)
	sapProductionOrderConfirmationMaterialMovementsDatumInsertCacheMut       sync.RWMutex
	sapProductionOrderConfirmationMaterialMovementsDatumInsertCache          = make(map[string]insertCache)
	sapProductionOrderConfirmationMaterialMovementsDatumUpdateCacheMut       sync.RWMutex
	sapProductionOrderConfirmationMaterialMovementsDatumUpdateCache          = make(map[string]updateCache)
	sapProductionOrderConfirmationMaterialMovementsDatumUpsertCacheMut       sync.RWMutex
	sapProductionOrderConfirmationMaterialMovementsDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapProductionOrderConfirmationMaterialMovementsDatumAfterSelectHooks []SapProductionOrderConfirmationMaterialMovementsDatumHook

var sapProductionOrderConfirmationMaterialMovementsDatumBeforeInsertHooks []SapProductionOrderConfirmationMaterialMovementsDatumHook
var sapProductionOrderConfirmationMaterialMovementsDatumAfterInsertHooks []SapProductionOrderConfirmationMaterialMovementsDatumHook

var sapProductionOrderConfirmationMaterialMovementsDatumBeforeUpdateHooks []SapProductionOrderConfirmationMaterialMovementsDatumHook
var sapProductionOrderConfirmationMaterialMovementsDatumAfterUpdateHooks []SapProductionOrderConfirmationMaterialMovementsDatumHook

var sapProductionOrderConfirmationMaterialMovementsDatumBeforeDeleteHooks []SapProductionOrderConfirmationMaterialMovementsDatumHook
var sapProductionOrderConfirmationMaterialMovementsDatumAfterDeleteHooks []SapProductionOrderConfirmationMaterialMovementsDatumHook

var sapProductionOrderConfirmationMaterialMovementsDatumBeforeUpsertHooks []SapProductionOrderConfirmationMaterialMovementsDatumHook
var sapProductionOrderConfirmationMaterialMovementsDatumAfterUpsertHooks []SapProductionOrderConfirmationMaterialMovementsDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductionOrderConfirmationMaterialMovementsDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductionOrderConfirmationMaterialMovementsDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductionOrderConfirmationMaterialMovementsDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductionOrderConfirmationMaterialMovementsDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductionOrderConfirmationMaterialMovementsDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductionOrderConfirmationMaterialMovementsDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductionOrderConfirmationMaterialMovementsDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductionOrderConfirmationMaterialMovementsDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductionOrderConfirmationMaterialMovementsDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapProductionOrderConfirmationMaterialMovementsDatumHook registers your hook function for all future operations.
func AddSapProductionOrderConfirmationMaterialMovementsDatumHook(hookPoint boil.HookPoint, sapProductionOrderConfirmationMaterialMovementsDatumHook SapProductionOrderConfirmationMaterialMovementsDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapProductionOrderConfirmationMaterialMovementsDatumAfterSelectHooks = append(sapProductionOrderConfirmationMaterialMovementsDatumAfterSelectHooks, sapProductionOrderConfirmationMaterialMovementsDatumHook)
	case boil.BeforeInsertHook:
		sapProductionOrderConfirmationMaterialMovementsDatumBeforeInsertHooks = append(sapProductionOrderConfirmationMaterialMovementsDatumBeforeInsertHooks, sapProductionOrderConfirmationMaterialMovementsDatumHook)
	case boil.AfterInsertHook:
		sapProductionOrderConfirmationMaterialMovementsDatumAfterInsertHooks = append(sapProductionOrderConfirmationMaterialMovementsDatumAfterInsertHooks, sapProductionOrderConfirmationMaterialMovementsDatumHook)
	case boil.BeforeUpdateHook:
		sapProductionOrderConfirmationMaterialMovementsDatumBeforeUpdateHooks = append(sapProductionOrderConfirmationMaterialMovementsDatumBeforeUpdateHooks, sapProductionOrderConfirmationMaterialMovementsDatumHook)
	case boil.AfterUpdateHook:
		sapProductionOrderConfirmationMaterialMovementsDatumAfterUpdateHooks = append(sapProductionOrderConfirmationMaterialMovementsDatumAfterUpdateHooks, sapProductionOrderConfirmationMaterialMovementsDatumHook)
	case boil.BeforeDeleteHook:
		sapProductionOrderConfirmationMaterialMovementsDatumBeforeDeleteHooks = append(sapProductionOrderConfirmationMaterialMovementsDatumBeforeDeleteHooks, sapProductionOrderConfirmationMaterialMovementsDatumHook)
	case boil.AfterDeleteHook:
		sapProductionOrderConfirmationMaterialMovementsDatumAfterDeleteHooks = append(sapProductionOrderConfirmationMaterialMovementsDatumAfterDeleteHooks, sapProductionOrderConfirmationMaterialMovementsDatumHook)
	case boil.BeforeUpsertHook:
		sapProductionOrderConfirmationMaterialMovementsDatumBeforeUpsertHooks = append(sapProductionOrderConfirmationMaterialMovementsDatumBeforeUpsertHooks, sapProductionOrderConfirmationMaterialMovementsDatumHook)
	case boil.AfterUpsertHook:
		sapProductionOrderConfirmationMaterialMovementsDatumAfterUpsertHooks = append(sapProductionOrderConfirmationMaterialMovementsDatumAfterUpsertHooks, sapProductionOrderConfirmationMaterialMovementsDatumHook)
	}
}

// One returns a single sapProductionOrderConfirmationMaterialMovementsDatum record from the query.
func (q sapProductionOrderConfirmationMaterialMovementsDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapProductionOrderConfirmationMaterialMovementsDatum, error) {
	o := &SapProductionOrderConfirmationMaterialMovementsDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_production_order_confirmation_material_movements_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapProductionOrderConfirmationMaterialMovementsDatum records from the query.
func (q sapProductionOrderConfirmationMaterialMovementsDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapProductionOrderConfirmationMaterialMovementsDatumSlice, error) {
	var o []*SapProductionOrderConfirmationMaterialMovementsDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapProductionOrderConfirmationMaterialMovementsDatum slice")
	}

	if len(sapProductionOrderConfirmationMaterialMovementsDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapProductionOrderConfirmationMaterialMovementsDatum records in the query.
func (q sapProductionOrderConfirmationMaterialMovementsDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_production_order_confirmation_material_movements_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapProductionOrderConfirmationMaterialMovementsDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_production_order_confirmation_material_movements_data exists")
	}

	return count > 0, nil
}

// SapProductionOrderConfirmationMaterialMovementsData retrieves all the records using an executor.
func SapProductionOrderConfirmationMaterialMovementsData(mods ...qm.QueryMod) sapProductionOrderConfirmationMaterialMovementsDatumQuery {
	mods = append(mods, qm.From("`sap_production_order_confirmation_material_movements_data`"))
	return sapProductionOrderConfirmationMaterialMovementsDatumQuery{NewQuery(mods...)}
}

// FindSapProductionOrderConfirmationMaterialMovementsDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapProductionOrderConfirmationMaterialMovementsDatum(ctx context.Context, exec boil.ContextExecutor, confirmationGroup string, confirmationCount string, materialDocument string, materialDocumentItem string, materialDocumentYear string, selectCols ...string) (*SapProductionOrderConfirmationMaterialMovementsDatum, error) {
	sapProductionOrderConfirmationMaterialMovementsDatumObj := &SapProductionOrderConfirmationMaterialMovementsDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_production_order_confirmation_material_movements_data` where `ConfirmationGroup`=? AND `ConfirmationCount`=? AND `MaterialDocument`=? AND `MaterialDocumentItem`=? AND `MaterialDocumentYear`=?", sel,
	)

	q := queries.Raw(query, confirmationGroup, confirmationCount, materialDocument, materialDocumentItem, materialDocumentYear)

	err := q.Bind(ctx, exec, sapProductionOrderConfirmationMaterialMovementsDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_production_order_confirmation_material_movements_data")
	}

	if err = sapProductionOrderConfirmationMaterialMovementsDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapProductionOrderConfirmationMaterialMovementsDatumObj, err
	}

	return sapProductionOrderConfirmationMaterialMovementsDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_production_order_confirmation_material_movements_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapProductionOrderConfirmationMaterialMovementsDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapProductionOrderConfirmationMaterialMovementsDatumInsertCacheMut.RLock()
	cache, cached := sapProductionOrderConfirmationMaterialMovementsDatumInsertCache[key]
	sapProductionOrderConfirmationMaterialMovementsDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapProductionOrderConfirmationMaterialMovementsDatumAllColumns,
			sapProductionOrderConfirmationMaterialMovementsDatumColumnsWithDefault,
			sapProductionOrderConfirmationMaterialMovementsDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapProductionOrderConfirmationMaterialMovementsDatumType, sapProductionOrderConfirmationMaterialMovementsDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapProductionOrderConfirmationMaterialMovementsDatumType, sapProductionOrderConfirmationMaterialMovementsDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_production_order_confirmation_material_movements_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_production_order_confirmation_material_movements_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_production_order_confirmation_material_movements_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_production_order_confirmation_material_movements_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ConfirmationGroup,
		o.ConfirmationCount,
		o.MaterialDocument,
		o.MaterialDocumentItem,
		o.MaterialDocumentYear,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_production_order_confirmation_material_movements_data")
	}

CacheNoHooks:
	if !cached {
		sapProductionOrderConfirmationMaterialMovementsDatumInsertCacheMut.Lock()
		sapProductionOrderConfirmationMaterialMovementsDatumInsertCache[key] = cache
		sapProductionOrderConfirmationMaterialMovementsDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapProductionOrderConfirmationMaterialMovementsDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapProductionOrderConfirmationMaterialMovementsDatumUpdateCacheMut.RLock()
	cache, cached := sapProductionOrderConfirmationMaterialMovementsDatumUpdateCache[key]
	sapProductionOrderConfirmationMaterialMovementsDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapProductionOrderConfirmationMaterialMovementsDatumAllColumns,
			sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_production_order_confirmation_material_movements_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_production_order_confirmation_material_movements_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapProductionOrderConfirmationMaterialMovementsDatumType, sapProductionOrderConfirmationMaterialMovementsDatumMapping, append(wl, sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_production_order_confirmation_material_movements_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_production_order_confirmation_material_movements_data")
	}

	if !cached {
		sapProductionOrderConfirmationMaterialMovementsDatumUpdateCacheMut.Lock()
		sapProductionOrderConfirmationMaterialMovementsDatumUpdateCache[key] = cache
		sapProductionOrderConfirmationMaterialMovementsDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapProductionOrderConfirmationMaterialMovementsDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_production_order_confirmation_material_movements_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_production_order_confirmation_material_movements_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapProductionOrderConfirmationMaterialMovementsDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_production_order_confirmation_material_movements_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapProductionOrderConfirmationMaterialMovementsDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapProductionOrderConfirmationMaterialMovementsDatum")
	}
	return rowsAff, nil
}

var mySQLSapProductionOrderConfirmationMaterialMovementsDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_production_order_confirmation_material_movements_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapProductionOrderConfirmationMaterialMovementsDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapProductionOrderConfirmationMaterialMovementsDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapProductionOrderConfirmationMaterialMovementsDatumUpsertCacheMut.RLock()
	cache, cached := sapProductionOrderConfirmationMaterialMovementsDatumUpsertCache[key]
	sapProductionOrderConfirmationMaterialMovementsDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapProductionOrderConfirmationMaterialMovementsDatumAllColumns,
			sapProductionOrderConfirmationMaterialMovementsDatumColumnsWithDefault,
			sapProductionOrderConfirmationMaterialMovementsDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapProductionOrderConfirmationMaterialMovementsDatumAllColumns,
			sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_production_order_confirmation_material_movements_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_production_order_confirmation_material_movements_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_production_order_confirmation_material_movements_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapProductionOrderConfirmationMaterialMovementsDatumType, sapProductionOrderConfirmationMaterialMovementsDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapProductionOrderConfirmationMaterialMovementsDatumType, sapProductionOrderConfirmationMaterialMovementsDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_production_order_confirmation_material_movements_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapProductionOrderConfirmationMaterialMovementsDatumType, sapProductionOrderConfirmationMaterialMovementsDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_production_order_confirmation_material_movements_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_production_order_confirmation_material_movements_data")
	}

CacheNoHooks:
	if !cached {
		sapProductionOrderConfirmationMaterialMovementsDatumUpsertCacheMut.Lock()
		sapProductionOrderConfirmationMaterialMovementsDatumUpsertCache[key] = cache
		sapProductionOrderConfirmationMaterialMovementsDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapProductionOrderConfirmationMaterialMovementsDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapProductionOrderConfirmationMaterialMovementsDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_production_order_confirmation_material_movements_data` WHERE `ConfirmationGroup`=? AND `ConfirmationCount`=? AND `MaterialDocument`=? AND `MaterialDocumentItem`=? AND `MaterialDocumentYear`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_production_order_confirmation_material_movements_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_production_order_confirmation_material_movements_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapProductionOrderConfirmationMaterialMovementsDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapProductionOrderConfirmationMaterialMovementsDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_production_order_confirmation_material_movements_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_production_order_confirmation_material_movements_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapProductionOrderConfirmationMaterialMovementsDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapProductionOrderConfirmationMaterialMovementsDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_production_order_confirmation_material_movements_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapProductionOrderConfirmationMaterialMovementsDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_production_order_confirmation_material_movements_data")
	}

	if len(sapProductionOrderConfirmationMaterialMovementsDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapProductionOrderConfirmationMaterialMovementsDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapProductionOrderConfirmationMaterialMovementsDatum(ctx, exec, o.ConfirmationGroup, o.ConfirmationCount, o.MaterialDocument, o.MaterialDocumentItem, o.MaterialDocumentYear)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapProductionOrderConfirmationMaterialMovementsDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapProductionOrderConfirmationMaterialMovementsDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_production_order_confirmation_material_movements_data`.* FROM `sap_production_order_confirmation_material_movements_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapProductionOrderConfirmationMaterialMovementsDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapProductionOrderConfirmationMaterialMovementsDatumSlice")
	}

	*o = slice

	return nil
}

// SapProductionOrderConfirmationMaterialMovementsDatumExists checks if the SapProductionOrderConfirmationMaterialMovementsDatum row exists.
func SapProductionOrderConfirmationMaterialMovementsDatumExists(ctx context.Context, exec boil.ContextExecutor, confirmationGroup string, confirmationCount string, materialDocument string, materialDocumentItem string, materialDocumentYear string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_production_order_confirmation_material_movements_data` where `ConfirmationGroup`=? AND `ConfirmationCount`=? AND `MaterialDocument`=? AND `MaterialDocumentItem`=? AND `MaterialDocumentYear`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, confirmationGroup, confirmationCount, materialDocument, materialDocumentItem, materialDocumentYear)
	}
	row := exec.QueryRowContext(ctx, sql, confirmationGroup, confirmationCount, materialDocument, materialDocumentItem, materialDocumentYear)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_production_order_confirmation_material_movements_data exists")
	}

	return exists, nil
}
