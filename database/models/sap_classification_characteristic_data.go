// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapClassificationCharacteristicDatum is an object representing the database table.
type SapClassificationCharacteristicDatum struct {
	ClassInternalID          string      `boil:"ClassInternalID" json:"ClassInternalID" toml:"ClassInternalID" yaml:"ClassInternalID"`
	CharcInternalID          string      `boil:"CharcInternalID" json:"CharcInternalID" toml:"CharcInternalID" yaml:"CharcInternalID"`
	DeleteMc                 null.Bool   `boil:"DeleteMc" json:"DeleteMc,omitempty" toml:"DeleteMc" yaml:"DeleteMc,omitempty"`
	UpdateMc                 null.Bool   `boil:"UpdateMc" json:"UpdateMc,omitempty" toml:"UpdateMc" yaml:"UpdateMc,omitempty"`
	CharcPositionNumber      null.String `boil:"CharcPositionNumber" json:"CharcPositionNumber,omitempty" toml:"CharcPositionNumber" yaml:"CharcPositionNumber,omitempty"`
	Characteristic           null.String `boil:"Characteristic" json:"Characteristic,omitempty" toml:"Characteristic" yaml:"Characteristic,omitempty"`
	AncestorClassInternalID  null.String `boil:"AncestorClassInternalID" json:"AncestorClassInternalID,omitempty" toml:"AncestorClassInternalID" yaml:"AncestorClassInternalID,omitempty"`
	OriginalCharcInternalID  null.String `boil:"OriginalCharcInternalID" json:"OriginalCharcInternalID,omitempty" toml:"OriginalCharcInternalID" yaml:"OriginalCharcInternalID,omitempty"`
	ChangeNumber             null.String `boil:"ChangeNumber" json:"ChangeNumber,omitempty" toml:"ChangeNumber" yaml:"ChangeNumber,omitempty"`
	CharcIsPrintRelevant     null.String `boil:"CharcIsPrintRelevant" json:"CharcIsPrintRelevant,omitempty" toml:"CharcIsPrintRelevant" yaml:"CharcIsPrintRelevant,omitempty"`
	CharcIsSearchRelevant    null.String `boil:"CharcIsSearchRelevant" json:"CharcIsSearchRelevant,omitempty" toml:"CharcIsSearchRelevant" yaml:"CharcIsSearchRelevant,omitempty"`
	CharcIsDisplayRelevant   null.String `boil:"CharcIsDisplayRelevant" json:"CharcIsDisplayRelevant,omitempty" toml:"CharcIsDisplayRelevant" yaml:"CharcIsDisplayRelevant,omitempty"`
	ValidityStartDate        null.String `boil:"ValidityStartDate" json:"ValidityStartDate,omitempty" toml:"ValidityStartDate" yaml:"ValidityStartDate,omitempty"`
	ValidityEndDate          null.String `boil:"ValidityEndDate" json:"ValidityEndDate,omitempty" toml:"ValidityEndDate" yaml:"ValidityEndDate,omitempty"`
	KeyDate                  null.String `boil:"KeyDate" json:"KeyDate,omitempty" toml:"KeyDate" yaml:"KeyDate,omitempty"`
	ClassLastChangedDateTime null.String `boil:"ClassLastChangedDateTime" json:"ClassLastChangedDateTime,omitempty" toml:"ClassLastChangedDateTime" yaml:"ClassLastChangedDateTime,omitempty"`

	R *sapClassificationCharacteristicDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapClassificationCharacteristicDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapClassificationCharacteristicDatumColumns = struct {
	ClassInternalID          string
	CharcInternalID          string
	DeleteMc                 string
	UpdateMc                 string
	CharcPositionNumber      string
	Characteristic           string
	AncestorClassInternalID  string
	OriginalCharcInternalID  string
	ChangeNumber             string
	CharcIsPrintRelevant     string
	CharcIsSearchRelevant    string
	CharcIsDisplayRelevant   string
	ValidityStartDate        string
	ValidityEndDate          string
	KeyDate                  string
	ClassLastChangedDateTime string
}{
	ClassInternalID:          "ClassInternalID",
	CharcInternalID:          "CharcInternalID",
	DeleteMc:                 "DeleteMc",
	UpdateMc:                 "UpdateMc",
	CharcPositionNumber:      "CharcPositionNumber",
	Characteristic:           "Characteristic",
	AncestorClassInternalID:  "AncestorClassInternalID",
	OriginalCharcInternalID:  "OriginalCharcInternalID",
	ChangeNumber:             "ChangeNumber",
	CharcIsPrintRelevant:     "CharcIsPrintRelevant",
	CharcIsSearchRelevant:    "CharcIsSearchRelevant",
	CharcIsDisplayRelevant:   "CharcIsDisplayRelevant",
	ValidityStartDate:        "ValidityStartDate",
	ValidityEndDate:          "ValidityEndDate",
	KeyDate:                  "KeyDate",
	ClassLastChangedDateTime: "ClassLastChangedDateTime",
}

var SapClassificationCharacteristicDatumTableColumns = struct {
	ClassInternalID          string
	CharcInternalID          string
	DeleteMc                 string
	UpdateMc                 string
	CharcPositionNumber      string
	Characteristic           string
	AncestorClassInternalID  string
	OriginalCharcInternalID  string
	ChangeNumber             string
	CharcIsPrintRelevant     string
	CharcIsSearchRelevant    string
	CharcIsDisplayRelevant   string
	ValidityStartDate        string
	ValidityEndDate          string
	KeyDate                  string
	ClassLastChangedDateTime string
}{
	ClassInternalID:          "sap_classification_characteristic_data.ClassInternalID",
	CharcInternalID:          "sap_classification_characteristic_data.CharcInternalID",
	DeleteMc:                 "sap_classification_characteristic_data.DeleteMc",
	UpdateMc:                 "sap_classification_characteristic_data.UpdateMc",
	CharcPositionNumber:      "sap_classification_characteristic_data.CharcPositionNumber",
	Characteristic:           "sap_classification_characteristic_data.Characteristic",
	AncestorClassInternalID:  "sap_classification_characteristic_data.AncestorClassInternalID",
	OriginalCharcInternalID:  "sap_classification_characteristic_data.OriginalCharcInternalID",
	ChangeNumber:             "sap_classification_characteristic_data.ChangeNumber",
	CharcIsPrintRelevant:     "sap_classification_characteristic_data.CharcIsPrintRelevant",
	CharcIsSearchRelevant:    "sap_classification_characteristic_data.CharcIsSearchRelevant",
	CharcIsDisplayRelevant:   "sap_classification_characteristic_data.CharcIsDisplayRelevant",
	ValidityStartDate:        "sap_classification_characteristic_data.ValidityStartDate",
	ValidityEndDate:          "sap_classification_characteristic_data.ValidityEndDate",
	KeyDate:                  "sap_classification_characteristic_data.KeyDate",
	ClassLastChangedDateTime: "sap_classification_characteristic_data.ClassLastChangedDateTime",
}

// Generated where

var SapClassificationCharacteristicDatumWhere = struct {
	ClassInternalID          whereHelperstring
	CharcInternalID          whereHelperstring
	DeleteMc                 whereHelpernull_Bool
	UpdateMc                 whereHelpernull_Bool
	CharcPositionNumber      whereHelpernull_String
	Characteristic           whereHelpernull_String
	AncestorClassInternalID  whereHelpernull_String
	OriginalCharcInternalID  whereHelpernull_String
	ChangeNumber             whereHelpernull_String
	CharcIsPrintRelevant     whereHelpernull_String
	CharcIsSearchRelevant    whereHelpernull_String
	CharcIsDisplayRelevant   whereHelpernull_String
	ValidityStartDate        whereHelpernull_String
	ValidityEndDate          whereHelpernull_String
	KeyDate                  whereHelpernull_String
	ClassLastChangedDateTime whereHelpernull_String
}{
	ClassInternalID:          whereHelperstring{field: "`sap_classification_characteristic_data`.`ClassInternalID`"},
	CharcInternalID:          whereHelperstring{field: "`sap_classification_characteristic_data`.`CharcInternalID`"},
	DeleteMc:                 whereHelpernull_Bool{field: "`sap_classification_characteristic_data`.`DeleteMc`"},
	UpdateMc:                 whereHelpernull_Bool{field: "`sap_classification_characteristic_data`.`UpdateMc`"},
	CharcPositionNumber:      whereHelpernull_String{field: "`sap_classification_characteristic_data`.`CharcPositionNumber`"},
	Characteristic:           whereHelpernull_String{field: "`sap_classification_characteristic_data`.`Characteristic`"},
	AncestorClassInternalID:  whereHelpernull_String{field: "`sap_classification_characteristic_data`.`AncestorClassInternalID`"},
	OriginalCharcInternalID:  whereHelpernull_String{field: "`sap_classification_characteristic_data`.`OriginalCharcInternalID`"},
	ChangeNumber:             whereHelpernull_String{field: "`sap_classification_characteristic_data`.`ChangeNumber`"},
	CharcIsPrintRelevant:     whereHelpernull_String{field: "`sap_classification_characteristic_data`.`CharcIsPrintRelevant`"},
	CharcIsSearchRelevant:    whereHelpernull_String{field: "`sap_classification_characteristic_data`.`CharcIsSearchRelevant`"},
	CharcIsDisplayRelevant:   whereHelpernull_String{field: "`sap_classification_characteristic_data`.`CharcIsDisplayRelevant`"},
	ValidityStartDate:        whereHelpernull_String{field: "`sap_classification_characteristic_data`.`ValidityStartDate`"},
	ValidityEndDate:          whereHelpernull_String{field: "`sap_classification_characteristic_data`.`ValidityEndDate`"},
	KeyDate:                  whereHelpernull_String{field: "`sap_classification_characteristic_data`.`KeyDate`"},
	ClassLastChangedDateTime: whereHelpernull_String{field: "`sap_classification_characteristic_data`.`ClassLastChangedDateTime`"},
}

// SapClassificationCharacteristicDatumRels is where relationship names are stored.
var SapClassificationCharacteristicDatumRels = struct {
	ClassInternalIDSapClassificationClassDatum string
}{
	ClassInternalIDSapClassificationClassDatum: "ClassInternalIDSapClassificationClassDatum",
}

// sapClassificationCharacteristicDatumR is where relationships are stored.
type sapClassificationCharacteristicDatumR struct {
	ClassInternalIDSapClassificationClassDatum *SapClassificationClassDatum `boil:"ClassInternalIDSapClassificationClassDatum" json:"ClassInternalIDSapClassificationClassDatum" toml:"ClassInternalIDSapClassificationClassDatum" yaml:"ClassInternalIDSapClassificationClassDatum"`
}

// NewStruct creates a new relationship struct
func (*sapClassificationCharacteristicDatumR) NewStruct() *sapClassificationCharacteristicDatumR {
	return &sapClassificationCharacteristicDatumR{}
}

// sapClassificationCharacteristicDatumL is where Load methods for each relationship are stored.
type sapClassificationCharacteristicDatumL struct{}

var (
	sapClassificationCharacteristicDatumAllColumns            = []string{"ClassInternalID", "CharcInternalID", "DeleteMc", "UpdateMc", "CharcPositionNumber", "Characteristic", "AncestorClassInternalID", "OriginalCharcInternalID", "ChangeNumber", "CharcIsPrintRelevant", "CharcIsSearchRelevant", "CharcIsDisplayRelevant", "ValidityStartDate", "ValidityEndDate", "KeyDate", "ClassLastChangedDateTime"}
	sapClassificationCharacteristicDatumColumnsWithoutDefault = []string{"ClassInternalID", "CharcInternalID", "DeleteMc", "UpdateMc", "CharcPositionNumber", "Characteristic", "AncestorClassInternalID", "OriginalCharcInternalID", "ChangeNumber", "CharcIsPrintRelevant", "CharcIsSearchRelevant", "CharcIsDisplayRelevant", "ValidityStartDate", "ValidityEndDate", "KeyDate", "ClassLastChangedDateTime"}
	sapClassificationCharacteristicDatumColumnsWithDefault    = []string{}
	sapClassificationCharacteristicDatumPrimaryKeyColumns     = []string{"ClassInternalID", "CharcInternalID"}
	sapClassificationCharacteristicDatumGeneratedColumns      = []string{}
)

type (
	// SapClassificationCharacteristicDatumSlice is an alias for a slice of pointers to SapClassificationCharacteristicDatum.
	// This should almost always be used instead of []SapClassificationCharacteristicDatum.
	SapClassificationCharacteristicDatumSlice []*SapClassificationCharacteristicDatum
	// SapClassificationCharacteristicDatumHook is the signature for custom SapClassificationCharacteristicDatum hook methods
	SapClassificationCharacteristicDatumHook func(context.Context, boil.ContextExecutor, *SapClassificationCharacteristicDatum) error

	sapClassificationCharacteristicDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapClassificationCharacteristicDatumType                 = reflect.TypeOf(&SapClassificationCharacteristicDatum{})
	sapClassificationCharacteristicDatumMapping              = queries.MakeStructMapping(sapClassificationCharacteristicDatumType)
	sapClassificationCharacteristicDatumPrimaryKeyMapping, _ = queries.BindMapping(sapClassificationCharacteristicDatumType, sapClassificationCharacteristicDatumMapping, sapClassificationCharacteristicDatumPrimaryKeyColumns)
	sapClassificationCharacteristicDatumInsertCacheMut       sync.RWMutex
	sapClassificationCharacteristicDatumInsertCache          = make(map[string]insertCache)
	sapClassificationCharacteristicDatumUpdateCacheMut       sync.RWMutex
	sapClassificationCharacteristicDatumUpdateCache          = make(map[string]updateCache)
	sapClassificationCharacteristicDatumUpsertCacheMut       sync.RWMutex
	sapClassificationCharacteristicDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapClassificationCharacteristicDatumAfterSelectHooks []SapClassificationCharacteristicDatumHook

var sapClassificationCharacteristicDatumBeforeInsertHooks []SapClassificationCharacteristicDatumHook
var sapClassificationCharacteristicDatumAfterInsertHooks []SapClassificationCharacteristicDatumHook

var sapClassificationCharacteristicDatumBeforeUpdateHooks []SapClassificationCharacteristicDatumHook
var sapClassificationCharacteristicDatumAfterUpdateHooks []SapClassificationCharacteristicDatumHook

var sapClassificationCharacteristicDatumBeforeDeleteHooks []SapClassificationCharacteristicDatumHook
var sapClassificationCharacteristicDatumAfterDeleteHooks []SapClassificationCharacteristicDatumHook

var sapClassificationCharacteristicDatumBeforeUpsertHooks []SapClassificationCharacteristicDatumHook
var sapClassificationCharacteristicDatumAfterUpsertHooks []SapClassificationCharacteristicDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapClassificationCharacteristicDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationCharacteristicDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapClassificationCharacteristicDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationCharacteristicDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapClassificationCharacteristicDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationCharacteristicDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapClassificationCharacteristicDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationCharacteristicDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapClassificationCharacteristicDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationCharacteristicDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapClassificationCharacteristicDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationCharacteristicDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapClassificationCharacteristicDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationCharacteristicDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapClassificationCharacteristicDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationCharacteristicDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapClassificationCharacteristicDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationCharacteristicDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapClassificationCharacteristicDatumHook registers your hook function for all future operations.
func AddSapClassificationCharacteristicDatumHook(hookPoint boil.HookPoint, sapClassificationCharacteristicDatumHook SapClassificationCharacteristicDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapClassificationCharacteristicDatumAfterSelectHooks = append(sapClassificationCharacteristicDatumAfterSelectHooks, sapClassificationCharacteristicDatumHook)
	case boil.BeforeInsertHook:
		sapClassificationCharacteristicDatumBeforeInsertHooks = append(sapClassificationCharacteristicDatumBeforeInsertHooks, sapClassificationCharacteristicDatumHook)
	case boil.AfterInsertHook:
		sapClassificationCharacteristicDatumAfterInsertHooks = append(sapClassificationCharacteristicDatumAfterInsertHooks, sapClassificationCharacteristicDatumHook)
	case boil.BeforeUpdateHook:
		sapClassificationCharacteristicDatumBeforeUpdateHooks = append(sapClassificationCharacteristicDatumBeforeUpdateHooks, sapClassificationCharacteristicDatumHook)
	case boil.AfterUpdateHook:
		sapClassificationCharacteristicDatumAfterUpdateHooks = append(sapClassificationCharacteristicDatumAfterUpdateHooks, sapClassificationCharacteristicDatumHook)
	case boil.BeforeDeleteHook:
		sapClassificationCharacteristicDatumBeforeDeleteHooks = append(sapClassificationCharacteristicDatumBeforeDeleteHooks, sapClassificationCharacteristicDatumHook)
	case boil.AfterDeleteHook:
		sapClassificationCharacteristicDatumAfterDeleteHooks = append(sapClassificationCharacteristicDatumAfterDeleteHooks, sapClassificationCharacteristicDatumHook)
	case boil.BeforeUpsertHook:
		sapClassificationCharacteristicDatumBeforeUpsertHooks = append(sapClassificationCharacteristicDatumBeforeUpsertHooks, sapClassificationCharacteristicDatumHook)
	case boil.AfterUpsertHook:
		sapClassificationCharacteristicDatumAfterUpsertHooks = append(sapClassificationCharacteristicDatumAfterUpsertHooks, sapClassificationCharacteristicDatumHook)
	}
}

// One returns a single sapClassificationCharacteristicDatum record from the query.
func (q sapClassificationCharacteristicDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapClassificationCharacteristicDatum, error) {
	o := &SapClassificationCharacteristicDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_classification_characteristic_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapClassificationCharacteristicDatum records from the query.
func (q sapClassificationCharacteristicDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapClassificationCharacteristicDatumSlice, error) {
	var o []*SapClassificationCharacteristicDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapClassificationCharacteristicDatum slice")
	}

	if len(sapClassificationCharacteristicDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapClassificationCharacteristicDatum records in the query.
func (q sapClassificationCharacteristicDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_classification_characteristic_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapClassificationCharacteristicDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_classification_characteristic_data exists")
	}

	return count > 0, nil
}

// ClassInternalIDSapClassificationClassDatum pointed to by the foreign key.
func (o *SapClassificationCharacteristicDatum) ClassInternalIDSapClassificationClassDatum(mods ...qm.QueryMod) sapClassificationClassDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ClassInternalID` = ?", o.ClassInternalID),
	}

	queryMods = append(queryMods, mods...)

	query := SapClassificationClassData(queryMods...)
	queries.SetFrom(query.Query, "`sap_classification_class_data`")

	return query
}

// LoadClassInternalIDSapClassificationClassDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (sapClassificationCharacteristicDatumL) LoadClassInternalIDSapClassificationClassDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapClassificationCharacteristicDatum interface{}, mods queries.Applicator) error {
	var slice []*SapClassificationCharacteristicDatum
	var object *SapClassificationCharacteristicDatum

	if singular {
		object = maybeSapClassificationCharacteristicDatum.(*SapClassificationCharacteristicDatum)
	} else {
		slice = *maybeSapClassificationCharacteristicDatum.(*[]*SapClassificationCharacteristicDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapClassificationCharacteristicDatumR{}
		}
		args = append(args, object.ClassInternalID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapClassificationCharacteristicDatumR{}
			}

			for _, a := range args {
				if a == obj.ClassInternalID {
					continue Outer
				}
			}

			args = append(args, obj.ClassInternalID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_classification_class_data`),
		qm.WhereIn(`sap_classification_class_data.ClassInternalID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SapClassificationClassDatum")
	}

	var resultSlice []*SapClassificationClassDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SapClassificationClassDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for sap_classification_class_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_classification_class_data")
	}

	if len(sapClassificationCharacteristicDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ClassInternalIDSapClassificationClassDatum = foreign
		if foreign.R == nil {
			foreign.R = &sapClassificationClassDatumR{}
		}
		foreign.R.ClassInternalIDSapClassificationCharacteristicData = append(foreign.R.ClassInternalIDSapClassificationCharacteristicData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ClassInternalID == foreign.ClassInternalID {
				local.R.ClassInternalIDSapClassificationClassDatum = foreign
				if foreign.R == nil {
					foreign.R = &sapClassificationClassDatumR{}
				}
				foreign.R.ClassInternalIDSapClassificationCharacteristicData = append(foreign.R.ClassInternalIDSapClassificationCharacteristicData, local)
				break
			}
		}
	}

	return nil
}

// SetClassInternalIDSapClassificationClassDatum of the sapClassificationCharacteristicDatum to the related item.
// Sets o.R.ClassInternalIDSapClassificationClassDatum to related.
// Adds o to related.R.ClassInternalIDSapClassificationCharacteristicData.
func (o *SapClassificationCharacteristicDatum) SetClassInternalIDSapClassificationClassDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SapClassificationClassDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `sap_classification_characteristic_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ClassInternalID"}),
		strmangle.WhereClause("`", "`", 0, sapClassificationCharacteristicDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ClassInternalID, o.ClassInternalID, o.CharcInternalID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ClassInternalID = related.ClassInternalID
	if o.R == nil {
		o.R = &sapClassificationCharacteristicDatumR{
			ClassInternalIDSapClassificationClassDatum: related,
		}
	} else {
		o.R.ClassInternalIDSapClassificationClassDatum = related
	}

	if related.R == nil {
		related.R = &sapClassificationClassDatumR{
			ClassInternalIDSapClassificationCharacteristicData: SapClassificationCharacteristicDatumSlice{o},
		}
	} else {
		related.R.ClassInternalIDSapClassificationCharacteristicData = append(related.R.ClassInternalIDSapClassificationCharacteristicData, o)
	}

	return nil
}

// SapClassificationCharacteristicData retrieves all the records using an executor.
func SapClassificationCharacteristicData(mods ...qm.QueryMod) sapClassificationCharacteristicDatumQuery {
	mods = append(mods, qm.From("`sap_classification_characteristic_data`"))
	return sapClassificationCharacteristicDatumQuery{NewQuery(mods...)}
}

// FindSapClassificationCharacteristicDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapClassificationCharacteristicDatum(ctx context.Context, exec boil.ContextExecutor, classInternalID string, charcInternalID string, selectCols ...string) (*SapClassificationCharacteristicDatum, error) {
	sapClassificationCharacteristicDatumObj := &SapClassificationCharacteristicDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_classification_characteristic_data` where `ClassInternalID`=? AND `CharcInternalID`=?", sel,
	)

	q := queries.Raw(query, classInternalID, charcInternalID)

	err := q.Bind(ctx, exec, sapClassificationCharacteristicDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_classification_characteristic_data")
	}

	if err = sapClassificationCharacteristicDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapClassificationCharacteristicDatumObj, err
	}

	return sapClassificationCharacteristicDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapClassificationCharacteristicDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_classification_characteristic_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapClassificationCharacteristicDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapClassificationCharacteristicDatumInsertCacheMut.RLock()
	cache, cached := sapClassificationCharacteristicDatumInsertCache[key]
	sapClassificationCharacteristicDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapClassificationCharacteristicDatumAllColumns,
			sapClassificationCharacteristicDatumColumnsWithDefault,
			sapClassificationCharacteristicDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapClassificationCharacteristicDatumType, sapClassificationCharacteristicDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapClassificationCharacteristicDatumType, sapClassificationCharacteristicDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_classification_characteristic_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_classification_characteristic_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_classification_characteristic_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapClassificationCharacteristicDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_classification_characteristic_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ClassInternalID,
		o.CharcInternalID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_classification_characteristic_data")
	}

CacheNoHooks:
	if !cached {
		sapClassificationCharacteristicDatumInsertCacheMut.Lock()
		sapClassificationCharacteristicDatumInsertCache[key] = cache
		sapClassificationCharacteristicDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapClassificationCharacteristicDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapClassificationCharacteristicDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapClassificationCharacteristicDatumUpdateCacheMut.RLock()
	cache, cached := sapClassificationCharacteristicDatumUpdateCache[key]
	sapClassificationCharacteristicDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapClassificationCharacteristicDatumAllColumns,
			sapClassificationCharacteristicDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_classification_characteristic_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_classification_characteristic_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapClassificationCharacteristicDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapClassificationCharacteristicDatumType, sapClassificationCharacteristicDatumMapping, append(wl, sapClassificationCharacteristicDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_classification_characteristic_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_classification_characteristic_data")
	}

	if !cached {
		sapClassificationCharacteristicDatumUpdateCacheMut.Lock()
		sapClassificationCharacteristicDatumUpdateCache[key] = cache
		sapClassificationCharacteristicDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapClassificationCharacteristicDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_classification_characteristic_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_classification_characteristic_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapClassificationCharacteristicDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapClassificationCharacteristicDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_classification_characteristic_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapClassificationCharacteristicDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapClassificationCharacteristicDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapClassificationCharacteristicDatum")
	}
	return rowsAff, nil
}

var mySQLSapClassificationCharacteristicDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapClassificationCharacteristicDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_classification_characteristic_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapClassificationCharacteristicDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapClassificationCharacteristicDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapClassificationCharacteristicDatumUpsertCacheMut.RLock()
	cache, cached := sapClassificationCharacteristicDatumUpsertCache[key]
	sapClassificationCharacteristicDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapClassificationCharacteristicDatumAllColumns,
			sapClassificationCharacteristicDatumColumnsWithDefault,
			sapClassificationCharacteristicDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapClassificationCharacteristicDatumAllColumns,
			sapClassificationCharacteristicDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_classification_characteristic_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_classification_characteristic_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_classification_characteristic_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapClassificationCharacteristicDatumType, sapClassificationCharacteristicDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapClassificationCharacteristicDatumType, sapClassificationCharacteristicDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_classification_characteristic_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapClassificationCharacteristicDatumType, sapClassificationCharacteristicDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_classification_characteristic_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_classification_characteristic_data")
	}

CacheNoHooks:
	if !cached {
		sapClassificationCharacteristicDatumUpsertCacheMut.Lock()
		sapClassificationCharacteristicDatumUpsertCache[key] = cache
		sapClassificationCharacteristicDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapClassificationCharacteristicDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapClassificationCharacteristicDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapClassificationCharacteristicDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapClassificationCharacteristicDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_classification_characteristic_data` WHERE `ClassInternalID`=? AND `CharcInternalID`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_classification_characteristic_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_classification_characteristic_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapClassificationCharacteristicDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapClassificationCharacteristicDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_classification_characteristic_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_classification_characteristic_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapClassificationCharacteristicDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapClassificationCharacteristicDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapClassificationCharacteristicDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_classification_characteristic_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapClassificationCharacteristicDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapClassificationCharacteristicDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_classification_characteristic_data")
	}

	if len(sapClassificationCharacteristicDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapClassificationCharacteristicDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapClassificationCharacteristicDatum(ctx, exec, o.ClassInternalID, o.CharcInternalID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapClassificationCharacteristicDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapClassificationCharacteristicDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapClassificationCharacteristicDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_classification_characteristic_data`.* FROM `sap_classification_characteristic_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapClassificationCharacteristicDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapClassificationCharacteristicDatumSlice")
	}

	*o = slice

	return nil
}

// SapClassificationCharacteristicDatumExists checks if the SapClassificationCharacteristicDatum row exists.
func SapClassificationCharacteristicDatumExists(ctx context.Context, exec boil.ContextExecutor, classInternalID string, charcInternalID string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_classification_characteristic_data` where `ClassInternalID`=? AND `CharcInternalID`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, classInternalID, charcInternalID)
	}
	row := exec.QueryRowContext(ctx, sql, classInternalID, charcInternalID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_classification_characteristic_data exists")
	}

	return exists, nil
}
