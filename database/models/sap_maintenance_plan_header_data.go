// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapMaintenancePlanHeaderDatum is an object representing the database table.
type SapMaintenancePlanHeaderDatum struct {
	MaintenancePlan                string      `boil:"MaintenancePlan" json:"MaintenancePlan" toml:"MaintenancePlan" yaml:"MaintenancePlan"`
	MaintenancePlanDesc            null.String `boil:"MaintenancePlanDesc" json:"MaintenancePlanDesc,omitempty" toml:"MaintenancePlanDesc" yaml:"MaintenancePlanDesc,omitempty"`
	CreationDate                   null.String `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	LastChangeDate                 null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	MaintenanceStrategy            null.String `boil:"MaintenanceStrategy" json:"MaintenanceStrategy,omitempty" toml:"MaintenanceStrategy" yaml:"MaintenanceStrategy,omitempty"`
	SchedulingDuration             null.String `boil:"SchedulingDuration" json:"SchedulingDuration,omitempty" toml:"SchedulingDuration" yaml:"SchedulingDuration,omitempty"`
	SchedulingDurationUnit         null.String `boil:"SchedulingDurationUnit" json:"SchedulingDurationUnit,omitempty" toml:"SchedulingDurationUnit" yaml:"SchedulingDurationUnit,omitempty"`
	NumberOfMaintenanceItems       null.String `boil:"NumberOfMaintenanceItems" json:"NumberOfMaintenanceItems,omitempty" toml:"NumberOfMaintenanceItems" yaml:"NumberOfMaintenanceItems,omitempty"`
	CycleModificationRatio         null.String `boil:"CycleModificationRatio" json:"CycleModificationRatio,omitempty" toml:"CycleModificationRatio" yaml:"CycleModificationRatio,omitempty"`
	MaintPlanSchedgIndicator       null.String `boil:"MaintPlanSchedgIndicator" json:"MaintPlanSchedgIndicator,omitempty" toml:"MaintPlanSchedgIndicator" yaml:"MaintPlanSchedgIndicator,omitempty"`
	MaintenancePlanInternalID      null.String `boil:"MaintenancePlanInternalID" json:"MaintenancePlanInternalID,omitempty" toml:"MaintenancePlanInternalID" yaml:"MaintenancePlanInternalID,omitempty"`
	MaintenanceCall                null.Int    `boil:"MaintenanceCall" json:"MaintenanceCall,omitempty" toml:"MaintenanceCall" yaml:"MaintenanceCall,omitempty"`
	MaintenancePlanCategory        null.String `boil:"MaintenancePlanCategory" json:"MaintenancePlanCategory,omitempty" toml:"MaintenancePlanCategory" yaml:"MaintenancePlanCategory,omitempty"`
	MaintPlanFreeDefinedAttrib     null.String `boil:"MaintPlanFreeDefinedAttrib" json:"MaintPlanFreeDefinedAttrib,omitempty" toml:"MaintPlanFreeDefinedAttrib" yaml:"MaintPlanFreeDefinedAttrib,omitempty"`
	BasicStartDate                 null.String `boil:"BasicStartDate" json:"BasicStartDate,omitempty" toml:"BasicStartDate" yaml:"BasicStartDate,omitempty"`
	SchedulingStartDate            null.String `boil:"SchedulingStartDate" json:"SchedulingStartDate,omitempty" toml:"SchedulingStartDate" yaml:"SchedulingStartDate,omitempty"`
	SchedulingStartTime            null.String `boil:"SchedulingStartTime" json:"SchedulingStartTime,omitempty" toml:"SchedulingStartTime" yaml:"SchedulingStartTime,omitempty"`
	MaintPlanStartCntrReadingValue null.String `boil:"MaintPlanStartCntrReadingValue" json:"MaintPlanStartCntrReadingValue,omitempty" toml:"MaintPlanStartCntrReadingValue" yaml:"MaintPlanStartCntrReadingValue,omitempty"`
	MaintPlnStrtBufDurationInDays  null.String `boil:"MaintPlnStrtBufDurationInDays" json:"MaintPlnStrtBufDurationInDays,omitempty" toml:"MaintPlnStrtBufDurationInDays" yaml:"MaintPlnStrtBufDurationInDays,omitempty"`
	MaintPlanStartBufferUnit       null.String `boil:"MaintPlanStartBufferUnit" json:"MaintPlanStartBufferUnit,omitempty" toml:"MaintPlanStartBufferUnit" yaml:"MaintPlanStartBufferUnit,omitempty"`
	FactoryCalendar                null.String `boil:"FactoryCalendar" json:"FactoryCalendar,omitempty" toml:"FactoryCalendar" yaml:"FactoryCalendar,omitempty"`
	LateCompletionShiftInPercent   null.String `boil:"LateCompletionShiftInPercent" json:"LateCompletionShiftInPercent,omitempty" toml:"LateCompletionShiftInPercent" yaml:"LateCompletionShiftInPercent,omitempty"`
	LateCompletionTolerancePercent null.String `boil:"LateCompletionTolerancePercent" json:"LateCompletionTolerancePercent,omitempty" toml:"LateCompletionTolerancePercent" yaml:"LateCompletionTolerancePercent,omitempty"`
	EarlyCompletionShiftInPercent  null.String `boil:"EarlyCompletionShiftInPercent" json:"EarlyCompletionShiftInPercent,omitempty" toml:"EarlyCompletionShiftInPercent" yaml:"EarlyCompletionShiftInPercent,omitempty"`
	EarlyCompletionTolerancePct    null.String `boil:"EarlyCompletionTolerancePct" json:"EarlyCompletionTolerancePct,omitempty" toml:"EarlyCompletionTolerancePct" yaml:"EarlyCompletionTolerancePct,omitempty"`
	MaintPlanLogicalOperatorCode   null.String `boil:"MaintPlanLogicalOperatorCode" json:"MaintPlanLogicalOperatorCode,omitempty" toml:"MaintPlanLogicalOperatorCode" yaml:"MaintPlanLogicalOperatorCode,omitempty"`
	SchedulingEndDate              null.String `boil:"SchedulingEndDate" json:"SchedulingEndDate,omitempty" toml:"SchedulingEndDate" yaml:"SchedulingEndDate,omitempty"`
	MaintPlanEndCntrReadingValue   null.String `boil:"MaintPlanEndCntrReadingValue" json:"MaintPlanEndCntrReadingValue,omitempty" toml:"MaintPlanEndCntrReadingValue" yaml:"MaintPlanEndCntrReadingValue,omitempty"`
	LastChangeDateTime             null.String `boil:"LastChangeDateTime" json:"LastChangeDateTime,omitempty" toml:"LastChangeDateTime" yaml:"LastChangeDateTime,omitempty"`
	MultipleCounterPlanShiftFactor null.String `boil:"MultipleCounterPlanShiftFactor" json:"MultipleCounterPlanShiftFactor,omitempty" toml:"MultipleCounterPlanShiftFactor" yaml:"MultipleCounterPlanShiftFactor,omitempty"`
	MaintenanceLeadFloatInDays     null.String `boil:"MaintenanceLeadFloatInDays" json:"MaintenanceLeadFloatInDays,omitempty" toml:"MaintenanceLeadFloatInDays" yaml:"MaintenanceLeadFloatInDays,omitempty"`
	MaintenancePlanCallObject      null.String `boil:"MaintenancePlanCallObject" json:"MaintenancePlanCallObject,omitempty" toml:"MaintenancePlanCallObject" yaml:"MaintenancePlanCallObject,omitempty"`
	MaintenancePlanSystemStatus    null.String `boil:"MaintenancePlanSystemStatus" json:"MaintenancePlanSystemStatus,omitempty" toml:"MaintenancePlanSystemStatus" yaml:"MaintenancePlanSystemStatus,omitempty"`

	R *sapMaintenancePlanHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapMaintenancePlanHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapMaintenancePlanHeaderDatumColumns = struct {
	MaintenancePlan                string
	MaintenancePlanDesc            string
	CreationDate                   string
	LastChangeDate                 string
	MaintenanceStrategy            string
	SchedulingDuration             string
	SchedulingDurationUnit         string
	NumberOfMaintenanceItems       string
	CycleModificationRatio         string
	MaintPlanSchedgIndicator       string
	MaintenancePlanInternalID      string
	MaintenanceCall                string
	MaintenancePlanCategory        string
	MaintPlanFreeDefinedAttrib     string
	BasicStartDate                 string
	SchedulingStartDate            string
	SchedulingStartTime            string
	MaintPlanStartCntrReadingValue string
	MaintPlnStrtBufDurationInDays  string
	MaintPlanStartBufferUnit       string
	FactoryCalendar                string
	LateCompletionShiftInPercent   string
	LateCompletionTolerancePercent string
	EarlyCompletionShiftInPercent  string
	EarlyCompletionTolerancePct    string
	MaintPlanLogicalOperatorCode   string
	SchedulingEndDate              string
	MaintPlanEndCntrReadingValue   string
	LastChangeDateTime             string
	MultipleCounterPlanShiftFactor string
	MaintenanceLeadFloatInDays     string
	MaintenancePlanCallObject      string
	MaintenancePlanSystemStatus    string
}{
	MaintenancePlan:                "MaintenancePlan",
	MaintenancePlanDesc:            "MaintenancePlanDesc",
	CreationDate:                   "CreationDate",
	LastChangeDate:                 "LastChangeDate",
	MaintenanceStrategy:            "MaintenanceStrategy",
	SchedulingDuration:             "SchedulingDuration",
	SchedulingDurationUnit:         "SchedulingDurationUnit",
	NumberOfMaintenanceItems:       "NumberOfMaintenanceItems",
	CycleModificationRatio:         "CycleModificationRatio",
	MaintPlanSchedgIndicator:       "MaintPlanSchedgIndicator",
	MaintenancePlanInternalID:      "MaintenancePlanInternalID",
	MaintenanceCall:                "MaintenanceCall",
	MaintenancePlanCategory:        "MaintenancePlanCategory",
	MaintPlanFreeDefinedAttrib:     "MaintPlanFreeDefinedAttrib",
	BasicStartDate:                 "BasicStartDate",
	SchedulingStartDate:            "SchedulingStartDate",
	SchedulingStartTime:            "SchedulingStartTime",
	MaintPlanStartCntrReadingValue: "MaintPlanStartCntrReadingValue",
	MaintPlnStrtBufDurationInDays:  "MaintPlnStrtBufDurationInDays",
	MaintPlanStartBufferUnit:       "MaintPlanStartBufferUnit",
	FactoryCalendar:                "FactoryCalendar",
	LateCompletionShiftInPercent:   "LateCompletionShiftInPercent",
	LateCompletionTolerancePercent: "LateCompletionTolerancePercent",
	EarlyCompletionShiftInPercent:  "EarlyCompletionShiftInPercent",
	EarlyCompletionTolerancePct:    "EarlyCompletionTolerancePct",
	MaintPlanLogicalOperatorCode:   "MaintPlanLogicalOperatorCode",
	SchedulingEndDate:              "SchedulingEndDate",
	MaintPlanEndCntrReadingValue:   "MaintPlanEndCntrReadingValue",
	LastChangeDateTime:             "LastChangeDateTime",
	MultipleCounterPlanShiftFactor: "MultipleCounterPlanShiftFactor",
	MaintenanceLeadFloatInDays:     "MaintenanceLeadFloatInDays",
	MaintenancePlanCallObject:      "MaintenancePlanCallObject",
	MaintenancePlanSystemStatus:    "MaintenancePlanSystemStatus",
}

var SapMaintenancePlanHeaderDatumTableColumns = struct {
	MaintenancePlan                string
	MaintenancePlanDesc            string
	CreationDate                   string
	LastChangeDate                 string
	MaintenanceStrategy            string
	SchedulingDuration             string
	SchedulingDurationUnit         string
	NumberOfMaintenanceItems       string
	CycleModificationRatio         string
	MaintPlanSchedgIndicator       string
	MaintenancePlanInternalID      string
	MaintenanceCall                string
	MaintenancePlanCategory        string
	MaintPlanFreeDefinedAttrib     string
	BasicStartDate                 string
	SchedulingStartDate            string
	SchedulingStartTime            string
	MaintPlanStartCntrReadingValue string
	MaintPlnStrtBufDurationInDays  string
	MaintPlanStartBufferUnit       string
	FactoryCalendar                string
	LateCompletionShiftInPercent   string
	LateCompletionTolerancePercent string
	EarlyCompletionShiftInPercent  string
	EarlyCompletionTolerancePct    string
	MaintPlanLogicalOperatorCode   string
	SchedulingEndDate              string
	MaintPlanEndCntrReadingValue   string
	LastChangeDateTime             string
	MultipleCounterPlanShiftFactor string
	MaintenanceLeadFloatInDays     string
	MaintenancePlanCallObject      string
	MaintenancePlanSystemStatus    string
}{
	MaintenancePlan:                "sap_maintenance_plan_header_data.MaintenancePlan",
	MaintenancePlanDesc:            "sap_maintenance_plan_header_data.MaintenancePlanDesc",
	CreationDate:                   "sap_maintenance_plan_header_data.CreationDate",
	LastChangeDate:                 "sap_maintenance_plan_header_data.LastChangeDate",
	MaintenanceStrategy:            "sap_maintenance_plan_header_data.MaintenanceStrategy",
	SchedulingDuration:             "sap_maintenance_plan_header_data.SchedulingDuration",
	SchedulingDurationUnit:         "sap_maintenance_plan_header_data.SchedulingDurationUnit",
	NumberOfMaintenanceItems:       "sap_maintenance_plan_header_data.NumberOfMaintenanceItems",
	CycleModificationRatio:         "sap_maintenance_plan_header_data.CycleModificationRatio",
	MaintPlanSchedgIndicator:       "sap_maintenance_plan_header_data.MaintPlanSchedgIndicator",
	MaintenancePlanInternalID:      "sap_maintenance_plan_header_data.MaintenancePlanInternalID",
	MaintenanceCall:                "sap_maintenance_plan_header_data.MaintenanceCall",
	MaintenancePlanCategory:        "sap_maintenance_plan_header_data.MaintenancePlanCategory",
	MaintPlanFreeDefinedAttrib:     "sap_maintenance_plan_header_data.MaintPlanFreeDefinedAttrib",
	BasicStartDate:                 "sap_maintenance_plan_header_data.BasicStartDate",
	SchedulingStartDate:            "sap_maintenance_plan_header_data.SchedulingStartDate",
	SchedulingStartTime:            "sap_maintenance_plan_header_data.SchedulingStartTime",
	MaintPlanStartCntrReadingValue: "sap_maintenance_plan_header_data.MaintPlanStartCntrReadingValue",
	MaintPlnStrtBufDurationInDays:  "sap_maintenance_plan_header_data.MaintPlnStrtBufDurationInDays",
	MaintPlanStartBufferUnit:       "sap_maintenance_plan_header_data.MaintPlanStartBufferUnit",
	FactoryCalendar:                "sap_maintenance_plan_header_data.FactoryCalendar",
	LateCompletionShiftInPercent:   "sap_maintenance_plan_header_data.LateCompletionShiftInPercent",
	LateCompletionTolerancePercent: "sap_maintenance_plan_header_data.LateCompletionTolerancePercent",
	EarlyCompletionShiftInPercent:  "sap_maintenance_plan_header_data.EarlyCompletionShiftInPercent",
	EarlyCompletionTolerancePct:    "sap_maintenance_plan_header_data.EarlyCompletionTolerancePct",
	MaintPlanLogicalOperatorCode:   "sap_maintenance_plan_header_data.MaintPlanLogicalOperatorCode",
	SchedulingEndDate:              "sap_maintenance_plan_header_data.SchedulingEndDate",
	MaintPlanEndCntrReadingValue:   "sap_maintenance_plan_header_data.MaintPlanEndCntrReadingValue",
	LastChangeDateTime:             "sap_maintenance_plan_header_data.LastChangeDateTime",
	MultipleCounterPlanShiftFactor: "sap_maintenance_plan_header_data.MultipleCounterPlanShiftFactor",
	MaintenanceLeadFloatInDays:     "sap_maintenance_plan_header_data.MaintenanceLeadFloatInDays",
	MaintenancePlanCallObject:      "sap_maintenance_plan_header_data.MaintenancePlanCallObject",
	MaintenancePlanSystemStatus:    "sap_maintenance_plan_header_data.MaintenancePlanSystemStatus",
}

// Generated where

var SapMaintenancePlanHeaderDatumWhere = struct {
	MaintenancePlan                whereHelperstring
	MaintenancePlanDesc            whereHelpernull_String
	CreationDate                   whereHelpernull_String
	LastChangeDate                 whereHelpernull_String
	MaintenanceStrategy            whereHelpernull_String
	SchedulingDuration             whereHelpernull_String
	SchedulingDurationUnit         whereHelpernull_String
	NumberOfMaintenanceItems       whereHelpernull_String
	CycleModificationRatio         whereHelpernull_String
	MaintPlanSchedgIndicator       whereHelpernull_String
	MaintenancePlanInternalID      whereHelpernull_String
	MaintenanceCall                whereHelpernull_Int
	MaintenancePlanCategory        whereHelpernull_String
	MaintPlanFreeDefinedAttrib     whereHelpernull_String
	BasicStartDate                 whereHelpernull_String
	SchedulingStartDate            whereHelpernull_String
	SchedulingStartTime            whereHelpernull_String
	MaintPlanStartCntrReadingValue whereHelpernull_String
	MaintPlnStrtBufDurationInDays  whereHelpernull_String
	MaintPlanStartBufferUnit       whereHelpernull_String
	FactoryCalendar                whereHelpernull_String
	LateCompletionShiftInPercent   whereHelpernull_String
	LateCompletionTolerancePercent whereHelpernull_String
	EarlyCompletionShiftInPercent  whereHelpernull_String
	EarlyCompletionTolerancePct    whereHelpernull_String
	MaintPlanLogicalOperatorCode   whereHelpernull_String
	SchedulingEndDate              whereHelpernull_String
	MaintPlanEndCntrReadingValue   whereHelpernull_String
	LastChangeDateTime             whereHelpernull_String
	MultipleCounterPlanShiftFactor whereHelpernull_String
	MaintenanceLeadFloatInDays     whereHelpernull_String
	MaintenancePlanCallObject      whereHelpernull_String
	MaintenancePlanSystemStatus    whereHelpernull_String
}{
	MaintenancePlan:                whereHelperstring{field: "`sap_maintenance_plan_header_data`.`MaintenancePlan`"},
	MaintenancePlanDesc:            whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintenancePlanDesc`"},
	CreationDate:                   whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`CreationDate`"},
	LastChangeDate:                 whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`LastChangeDate`"},
	MaintenanceStrategy:            whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintenanceStrategy`"},
	SchedulingDuration:             whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`SchedulingDuration`"},
	SchedulingDurationUnit:         whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`SchedulingDurationUnit`"},
	NumberOfMaintenanceItems:       whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`NumberOfMaintenanceItems`"},
	CycleModificationRatio:         whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`CycleModificationRatio`"},
	MaintPlanSchedgIndicator:       whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintPlanSchedgIndicator`"},
	MaintenancePlanInternalID:      whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintenancePlanInternalID`"},
	MaintenanceCall:                whereHelpernull_Int{field: "`sap_maintenance_plan_header_data`.`MaintenanceCall`"},
	MaintenancePlanCategory:        whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintenancePlanCategory`"},
	MaintPlanFreeDefinedAttrib:     whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintPlanFreeDefinedAttrib`"},
	BasicStartDate:                 whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`BasicStartDate`"},
	SchedulingStartDate:            whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`SchedulingStartDate`"},
	SchedulingStartTime:            whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`SchedulingStartTime`"},
	MaintPlanStartCntrReadingValue: whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintPlanStartCntrReadingValue`"},
	MaintPlnStrtBufDurationInDays:  whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintPlnStrtBufDurationInDays`"},
	MaintPlanStartBufferUnit:       whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintPlanStartBufferUnit`"},
	FactoryCalendar:                whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`FactoryCalendar`"},
	LateCompletionShiftInPercent:   whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`LateCompletionShiftInPercent`"},
	LateCompletionTolerancePercent: whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`LateCompletionTolerancePercent`"},
	EarlyCompletionShiftInPercent:  whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`EarlyCompletionShiftInPercent`"},
	EarlyCompletionTolerancePct:    whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`EarlyCompletionTolerancePct`"},
	MaintPlanLogicalOperatorCode:   whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintPlanLogicalOperatorCode`"},
	SchedulingEndDate:              whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`SchedulingEndDate`"},
	MaintPlanEndCntrReadingValue:   whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintPlanEndCntrReadingValue`"},
	LastChangeDateTime:             whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`LastChangeDateTime`"},
	MultipleCounterPlanShiftFactor: whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MultipleCounterPlanShiftFactor`"},
	MaintenanceLeadFloatInDays:     whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintenanceLeadFloatInDays`"},
	MaintenancePlanCallObject:      whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintenancePlanCallObject`"},
	MaintenancePlanSystemStatus:    whereHelpernull_String{field: "`sap_maintenance_plan_header_data`.`MaintenancePlanSystemStatus`"},
}

// SapMaintenancePlanHeaderDatumRels is where relationship names are stored.
var SapMaintenancePlanHeaderDatumRels = struct {
	MaintenancePlanSapMaintenancePlanCallObjectsData   string
	MaintenancePlanSapMaintenancePlanItemData          string
	MaintenancePlanSapMaintenancePlanStrategyCycleData string
}{
	MaintenancePlanSapMaintenancePlanCallObjectsData:   "MaintenancePlanSapMaintenancePlanCallObjectsData",
	MaintenancePlanSapMaintenancePlanItemData:          "MaintenancePlanSapMaintenancePlanItemData",
	MaintenancePlanSapMaintenancePlanStrategyCycleData: "MaintenancePlanSapMaintenancePlanStrategyCycleData",
}

// sapMaintenancePlanHeaderDatumR is where relationships are stored.
type sapMaintenancePlanHeaderDatumR struct {
	MaintenancePlanSapMaintenancePlanCallObjectsData   SapMaintenancePlanCallObjectsDatumSlice   `boil:"MaintenancePlanSapMaintenancePlanCallObjectsData" json:"MaintenancePlanSapMaintenancePlanCallObjectsData" toml:"MaintenancePlanSapMaintenancePlanCallObjectsData" yaml:"MaintenancePlanSapMaintenancePlanCallObjectsData"`
	MaintenancePlanSapMaintenancePlanItemData          SapMaintenancePlanItemDatumSlice          `boil:"MaintenancePlanSapMaintenancePlanItemData" json:"MaintenancePlanSapMaintenancePlanItemData" toml:"MaintenancePlanSapMaintenancePlanItemData" yaml:"MaintenancePlanSapMaintenancePlanItemData"`
	MaintenancePlanSapMaintenancePlanStrategyCycleData SapMaintenancePlanStrategyCycleDatumSlice `boil:"MaintenancePlanSapMaintenancePlanStrategyCycleData" json:"MaintenancePlanSapMaintenancePlanStrategyCycleData" toml:"MaintenancePlanSapMaintenancePlanStrategyCycleData" yaml:"MaintenancePlanSapMaintenancePlanStrategyCycleData"`
}

// NewStruct creates a new relationship struct
func (*sapMaintenancePlanHeaderDatumR) NewStruct() *sapMaintenancePlanHeaderDatumR {
	return &sapMaintenancePlanHeaderDatumR{}
}

func (r *sapMaintenancePlanHeaderDatumR) GetMaintenancePlanSapMaintenancePlanCallObjectsData() SapMaintenancePlanCallObjectsDatumSlice {
	if r == nil {
		return nil
	}
	return r.MaintenancePlanSapMaintenancePlanCallObjectsData
}

func (r *sapMaintenancePlanHeaderDatumR) GetMaintenancePlanSapMaintenancePlanItemData() SapMaintenancePlanItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.MaintenancePlanSapMaintenancePlanItemData
}

func (r *sapMaintenancePlanHeaderDatumR) GetMaintenancePlanSapMaintenancePlanStrategyCycleData() SapMaintenancePlanStrategyCycleDatumSlice {
	if r == nil {
		return nil
	}
	return r.MaintenancePlanSapMaintenancePlanStrategyCycleData
}

// sapMaintenancePlanHeaderDatumL is where Load methods for each relationship are stored.
type sapMaintenancePlanHeaderDatumL struct{}

var (
	sapMaintenancePlanHeaderDatumAllColumns            = []string{"MaintenancePlan", "MaintenancePlanDesc", "CreationDate", "LastChangeDate", "MaintenanceStrategy", "SchedulingDuration", "SchedulingDurationUnit", "NumberOfMaintenanceItems", "CycleModificationRatio", "MaintPlanSchedgIndicator", "MaintenancePlanInternalID", "MaintenanceCall", "MaintenancePlanCategory", "MaintPlanFreeDefinedAttrib", "BasicStartDate", "SchedulingStartDate", "SchedulingStartTime", "MaintPlanStartCntrReadingValue", "MaintPlnStrtBufDurationInDays", "MaintPlanStartBufferUnit", "FactoryCalendar", "LateCompletionShiftInPercent", "LateCompletionTolerancePercent", "EarlyCompletionShiftInPercent", "EarlyCompletionTolerancePct", "MaintPlanLogicalOperatorCode", "SchedulingEndDate", "MaintPlanEndCntrReadingValue", "LastChangeDateTime", "MultipleCounterPlanShiftFactor", "MaintenanceLeadFloatInDays", "MaintenancePlanCallObject", "MaintenancePlanSystemStatus"}
	sapMaintenancePlanHeaderDatumColumnsWithoutDefault = []string{"MaintenancePlan", "MaintenancePlanDesc", "CreationDate", "LastChangeDate", "MaintenanceStrategy", "SchedulingDuration", "SchedulingDurationUnit", "NumberOfMaintenanceItems", "CycleModificationRatio", "MaintPlanSchedgIndicator", "MaintenancePlanInternalID", "MaintenanceCall", "MaintenancePlanCategory", "MaintPlanFreeDefinedAttrib", "BasicStartDate", "SchedulingStartDate", "SchedulingStartTime", "MaintPlanStartCntrReadingValue", "MaintPlnStrtBufDurationInDays", "MaintPlanStartBufferUnit", "FactoryCalendar", "LateCompletionShiftInPercent", "LateCompletionTolerancePercent", "EarlyCompletionShiftInPercent", "EarlyCompletionTolerancePct", "MaintPlanLogicalOperatorCode", "SchedulingEndDate", "MaintPlanEndCntrReadingValue", "LastChangeDateTime", "MultipleCounterPlanShiftFactor", "MaintenanceLeadFloatInDays", "MaintenancePlanCallObject", "MaintenancePlanSystemStatus"}
	sapMaintenancePlanHeaderDatumColumnsWithDefault    = []string{}
	sapMaintenancePlanHeaderDatumPrimaryKeyColumns     = []string{"MaintenancePlan"}
	sapMaintenancePlanHeaderDatumGeneratedColumns      = []string{}
)

type (
	// SapMaintenancePlanHeaderDatumSlice is an alias for a slice of pointers to SapMaintenancePlanHeaderDatum.
	// This should almost always be used instead of []SapMaintenancePlanHeaderDatum.
	SapMaintenancePlanHeaderDatumSlice []*SapMaintenancePlanHeaderDatum
	// SapMaintenancePlanHeaderDatumHook is the signature for custom SapMaintenancePlanHeaderDatum hook methods
	SapMaintenancePlanHeaderDatumHook func(context.Context, boil.ContextExecutor, *SapMaintenancePlanHeaderDatum) error

	sapMaintenancePlanHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapMaintenancePlanHeaderDatumType                 = reflect.TypeOf(&SapMaintenancePlanHeaderDatum{})
	sapMaintenancePlanHeaderDatumMapping              = queries.MakeStructMapping(sapMaintenancePlanHeaderDatumType)
	sapMaintenancePlanHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(sapMaintenancePlanHeaderDatumType, sapMaintenancePlanHeaderDatumMapping, sapMaintenancePlanHeaderDatumPrimaryKeyColumns)
	sapMaintenancePlanHeaderDatumInsertCacheMut       sync.RWMutex
	sapMaintenancePlanHeaderDatumInsertCache          = make(map[string]insertCache)
	sapMaintenancePlanHeaderDatumUpdateCacheMut       sync.RWMutex
	sapMaintenancePlanHeaderDatumUpdateCache          = make(map[string]updateCache)
	sapMaintenancePlanHeaderDatumUpsertCacheMut       sync.RWMutex
	sapMaintenancePlanHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapMaintenancePlanHeaderDatumAfterSelectHooks []SapMaintenancePlanHeaderDatumHook

var sapMaintenancePlanHeaderDatumBeforeInsertHooks []SapMaintenancePlanHeaderDatumHook
var sapMaintenancePlanHeaderDatumAfterInsertHooks []SapMaintenancePlanHeaderDatumHook

var sapMaintenancePlanHeaderDatumBeforeUpdateHooks []SapMaintenancePlanHeaderDatumHook
var sapMaintenancePlanHeaderDatumAfterUpdateHooks []SapMaintenancePlanHeaderDatumHook

var sapMaintenancePlanHeaderDatumBeforeDeleteHooks []SapMaintenancePlanHeaderDatumHook
var sapMaintenancePlanHeaderDatumAfterDeleteHooks []SapMaintenancePlanHeaderDatumHook

var sapMaintenancePlanHeaderDatumBeforeUpsertHooks []SapMaintenancePlanHeaderDatumHook
var sapMaintenancePlanHeaderDatumAfterUpsertHooks []SapMaintenancePlanHeaderDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapMaintenancePlanHeaderDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenancePlanHeaderDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapMaintenancePlanHeaderDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenancePlanHeaderDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapMaintenancePlanHeaderDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenancePlanHeaderDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapMaintenancePlanHeaderDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenancePlanHeaderDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapMaintenancePlanHeaderDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenancePlanHeaderDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapMaintenancePlanHeaderDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenancePlanHeaderDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapMaintenancePlanHeaderDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenancePlanHeaderDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapMaintenancePlanHeaderDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenancePlanHeaderDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapMaintenancePlanHeaderDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenancePlanHeaderDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapMaintenancePlanHeaderDatumHook registers your hook function for all future operations.
func AddSapMaintenancePlanHeaderDatumHook(hookPoint boil.HookPoint, sapMaintenancePlanHeaderDatumHook SapMaintenancePlanHeaderDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapMaintenancePlanHeaderDatumAfterSelectHooks = append(sapMaintenancePlanHeaderDatumAfterSelectHooks, sapMaintenancePlanHeaderDatumHook)
	case boil.BeforeInsertHook:
		sapMaintenancePlanHeaderDatumBeforeInsertHooks = append(sapMaintenancePlanHeaderDatumBeforeInsertHooks, sapMaintenancePlanHeaderDatumHook)
	case boil.AfterInsertHook:
		sapMaintenancePlanHeaderDatumAfterInsertHooks = append(sapMaintenancePlanHeaderDatumAfterInsertHooks, sapMaintenancePlanHeaderDatumHook)
	case boil.BeforeUpdateHook:
		sapMaintenancePlanHeaderDatumBeforeUpdateHooks = append(sapMaintenancePlanHeaderDatumBeforeUpdateHooks, sapMaintenancePlanHeaderDatumHook)
	case boil.AfterUpdateHook:
		sapMaintenancePlanHeaderDatumAfterUpdateHooks = append(sapMaintenancePlanHeaderDatumAfterUpdateHooks, sapMaintenancePlanHeaderDatumHook)
	case boil.BeforeDeleteHook:
		sapMaintenancePlanHeaderDatumBeforeDeleteHooks = append(sapMaintenancePlanHeaderDatumBeforeDeleteHooks, sapMaintenancePlanHeaderDatumHook)
	case boil.AfterDeleteHook:
		sapMaintenancePlanHeaderDatumAfterDeleteHooks = append(sapMaintenancePlanHeaderDatumAfterDeleteHooks, sapMaintenancePlanHeaderDatumHook)
	case boil.BeforeUpsertHook:
		sapMaintenancePlanHeaderDatumBeforeUpsertHooks = append(sapMaintenancePlanHeaderDatumBeforeUpsertHooks, sapMaintenancePlanHeaderDatumHook)
	case boil.AfterUpsertHook:
		sapMaintenancePlanHeaderDatumAfterUpsertHooks = append(sapMaintenancePlanHeaderDatumAfterUpsertHooks, sapMaintenancePlanHeaderDatumHook)
	}
}

// One returns a single sapMaintenancePlanHeaderDatum record from the query.
func (q sapMaintenancePlanHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapMaintenancePlanHeaderDatum, error) {
	o := &SapMaintenancePlanHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_maintenance_plan_header_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapMaintenancePlanHeaderDatum records from the query.
func (q sapMaintenancePlanHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapMaintenancePlanHeaderDatumSlice, error) {
	var o []*SapMaintenancePlanHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapMaintenancePlanHeaderDatum slice")
	}

	if len(sapMaintenancePlanHeaderDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapMaintenancePlanHeaderDatum records in the query.
func (q sapMaintenancePlanHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_maintenance_plan_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapMaintenancePlanHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_maintenance_plan_header_data exists")
	}

	return count > 0, nil
}

// MaintenancePlanSapMaintenancePlanCallObjectsData retrieves all the sap_maintenance_plan_call_objects_datum's SapMaintenancePlanCallObjectsData with an executor via MaintenancePlan column.
func (o *SapMaintenancePlanHeaderDatum) MaintenancePlanSapMaintenancePlanCallObjectsData(mods ...qm.QueryMod) sapMaintenancePlanCallObjectsDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_maintenance_plan_call_objects_data`.`MaintenancePlan`=?", o.MaintenancePlan),
	)

	return SapMaintenancePlanCallObjectsData(queryMods...)
}

// MaintenancePlanSapMaintenancePlanItemData retrieves all the sap_maintenance_plan_item_datum's SapMaintenancePlanItemData with an executor via MaintenancePlan column.
func (o *SapMaintenancePlanHeaderDatum) MaintenancePlanSapMaintenancePlanItemData(mods ...qm.QueryMod) sapMaintenancePlanItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_maintenance_plan_item_data`.`MaintenancePlan`=?", o.MaintenancePlan),
	)

	return SapMaintenancePlanItemData(queryMods...)
}

// MaintenancePlanSapMaintenancePlanStrategyCycleData retrieves all the sap_maintenance_plan_strategy_cycle_datum's SapMaintenancePlanStrategyCycleData with an executor via MaintenancePlan column.
func (o *SapMaintenancePlanHeaderDatum) MaintenancePlanSapMaintenancePlanStrategyCycleData(mods ...qm.QueryMod) sapMaintenancePlanStrategyCycleDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_maintenance_plan_strategy_cycle_data`.`MaintenancePlan`=?", o.MaintenancePlan),
	)

	return SapMaintenancePlanStrategyCycleData(queryMods...)
}

// LoadMaintenancePlanSapMaintenancePlanCallObjectsData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapMaintenancePlanHeaderDatumL) LoadMaintenancePlanSapMaintenancePlanCallObjectsData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapMaintenancePlanHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapMaintenancePlanHeaderDatum
	var object *SapMaintenancePlanHeaderDatum

	if singular {
		object = maybeSapMaintenancePlanHeaderDatum.(*SapMaintenancePlanHeaderDatum)
	} else {
		slice = *maybeSapMaintenancePlanHeaderDatum.(*[]*SapMaintenancePlanHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapMaintenancePlanHeaderDatumR{}
		}
		args = append(args, object.MaintenancePlan)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapMaintenancePlanHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.MaintenancePlan {
					continue Outer
				}
			}

			args = append(args, obj.MaintenancePlan)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_maintenance_plan_call_objects_data`),
		qm.WhereIn(`sap_maintenance_plan_call_objects_data.MaintenancePlan in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_maintenance_plan_call_objects_data")
	}

	var resultSlice []*SapMaintenancePlanCallObjectsDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_maintenance_plan_call_objects_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_maintenance_plan_call_objects_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_maintenance_plan_call_objects_data")
	}

	if len(sapMaintenancePlanCallObjectsDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MaintenancePlanSapMaintenancePlanCallObjectsData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapMaintenancePlanCallObjectsDatumR{}
			}
			foreign.R.MaintenancePlanSapMaintenancePlanHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.MaintenancePlan == foreign.MaintenancePlan {
				local.R.MaintenancePlanSapMaintenancePlanCallObjectsData = append(local.R.MaintenancePlanSapMaintenancePlanCallObjectsData, foreign)
				if foreign.R == nil {
					foreign.R = &sapMaintenancePlanCallObjectsDatumR{}
				}
				foreign.R.MaintenancePlanSapMaintenancePlanHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// LoadMaintenancePlanSapMaintenancePlanItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapMaintenancePlanHeaderDatumL) LoadMaintenancePlanSapMaintenancePlanItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapMaintenancePlanHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapMaintenancePlanHeaderDatum
	var object *SapMaintenancePlanHeaderDatum

	if singular {
		object = maybeSapMaintenancePlanHeaderDatum.(*SapMaintenancePlanHeaderDatum)
	} else {
		slice = *maybeSapMaintenancePlanHeaderDatum.(*[]*SapMaintenancePlanHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapMaintenancePlanHeaderDatumR{}
		}
		args = append(args, object.MaintenancePlan)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapMaintenancePlanHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.MaintenancePlan {
					continue Outer
				}
			}

			args = append(args, obj.MaintenancePlan)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_maintenance_plan_item_data`),
		qm.WhereIn(`sap_maintenance_plan_item_data.MaintenancePlan in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_maintenance_plan_item_data")
	}

	var resultSlice []*SapMaintenancePlanItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_maintenance_plan_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_maintenance_plan_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_maintenance_plan_item_data")
	}

	if len(sapMaintenancePlanItemDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MaintenancePlanSapMaintenancePlanItemData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapMaintenancePlanItemDatumR{}
			}
			foreign.R.MaintenancePlanSapMaintenancePlanHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.MaintenancePlan == foreign.MaintenancePlan {
				local.R.MaintenancePlanSapMaintenancePlanItemData = append(local.R.MaintenancePlanSapMaintenancePlanItemData, foreign)
				if foreign.R == nil {
					foreign.R = &sapMaintenancePlanItemDatumR{}
				}
				foreign.R.MaintenancePlanSapMaintenancePlanHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// LoadMaintenancePlanSapMaintenancePlanStrategyCycleData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapMaintenancePlanHeaderDatumL) LoadMaintenancePlanSapMaintenancePlanStrategyCycleData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapMaintenancePlanHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapMaintenancePlanHeaderDatum
	var object *SapMaintenancePlanHeaderDatum

	if singular {
		object = maybeSapMaintenancePlanHeaderDatum.(*SapMaintenancePlanHeaderDatum)
	} else {
		slice = *maybeSapMaintenancePlanHeaderDatum.(*[]*SapMaintenancePlanHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapMaintenancePlanHeaderDatumR{}
		}
		args = append(args, object.MaintenancePlan)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapMaintenancePlanHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.MaintenancePlan {
					continue Outer
				}
			}

			args = append(args, obj.MaintenancePlan)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_maintenance_plan_strategy_cycle_data`),
		qm.WhereIn(`sap_maintenance_plan_strategy_cycle_data.MaintenancePlan in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_maintenance_plan_strategy_cycle_data")
	}

	var resultSlice []*SapMaintenancePlanStrategyCycleDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_maintenance_plan_strategy_cycle_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_maintenance_plan_strategy_cycle_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_maintenance_plan_strategy_cycle_data")
	}

	if len(sapMaintenancePlanStrategyCycleDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MaintenancePlanSapMaintenancePlanStrategyCycleData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapMaintenancePlanStrategyCycleDatumR{}
			}
			foreign.R.MaintenancePlanSapMaintenancePlanHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.MaintenancePlan == foreign.MaintenancePlan {
				local.R.MaintenancePlanSapMaintenancePlanStrategyCycleData = append(local.R.MaintenancePlanSapMaintenancePlanStrategyCycleData, foreign)
				if foreign.R == nil {
					foreign.R = &sapMaintenancePlanStrategyCycleDatumR{}
				}
				foreign.R.MaintenancePlanSapMaintenancePlanHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// AddMaintenancePlanSapMaintenancePlanCallObjectsData adds the given related objects to the existing relationships
// of the sap_maintenance_plan_header_datum, optionally inserting them as new records.
// Appends related to o.R.MaintenancePlanSapMaintenancePlanCallObjectsData.
// Sets related.R.MaintenancePlanSapMaintenancePlanHeaderDatum appropriately.
func (o *SapMaintenancePlanHeaderDatum) AddMaintenancePlanSapMaintenancePlanCallObjectsData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapMaintenancePlanCallObjectsDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MaintenancePlan = o.MaintenancePlan
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_maintenance_plan_call_objects_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"MaintenancePlan"}),
				strmangle.WhereClause("`", "`", 0, sapMaintenancePlanCallObjectsDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.MaintenancePlan, rel.MaintenancePlan, rel.MaintenanceItem, rel.MaintenancePlanCallNumber}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MaintenancePlan = o.MaintenancePlan
		}
	}

	if o.R == nil {
		o.R = &sapMaintenancePlanHeaderDatumR{
			MaintenancePlanSapMaintenancePlanCallObjectsData: related,
		}
	} else {
		o.R.MaintenancePlanSapMaintenancePlanCallObjectsData = append(o.R.MaintenancePlanSapMaintenancePlanCallObjectsData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapMaintenancePlanCallObjectsDatumR{
				MaintenancePlanSapMaintenancePlanHeaderDatum: o,
			}
		} else {
			rel.R.MaintenancePlanSapMaintenancePlanHeaderDatum = o
		}
	}
	return nil
}

// AddMaintenancePlanSapMaintenancePlanItemData adds the given related objects to the existing relationships
// of the sap_maintenance_plan_header_datum, optionally inserting them as new records.
// Appends related to o.R.MaintenancePlanSapMaintenancePlanItemData.
// Sets related.R.MaintenancePlanSapMaintenancePlanHeaderDatum appropriately.
func (o *SapMaintenancePlanHeaderDatum) AddMaintenancePlanSapMaintenancePlanItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapMaintenancePlanItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MaintenancePlan = o.MaintenancePlan
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_maintenance_plan_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"MaintenancePlan"}),
				strmangle.WhereClause("`", "`", 0, sapMaintenancePlanItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.MaintenancePlan, rel.MaintenancePlan, rel.MaintenanceItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MaintenancePlan = o.MaintenancePlan
		}
	}

	if o.R == nil {
		o.R = &sapMaintenancePlanHeaderDatumR{
			MaintenancePlanSapMaintenancePlanItemData: related,
		}
	} else {
		o.R.MaintenancePlanSapMaintenancePlanItemData = append(o.R.MaintenancePlanSapMaintenancePlanItemData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapMaintenancePlanItemDatumR{
				MaintenancePlanSapMaintenancePlanHeaderDatum: o,
			}
		} else {
			rel.R.MaintenancePlanSapMaintenancePlanHeaderDatum = o
		}
	}
	return nil
}

// AddMaintenancePlanSapMaintenancePlanStrategyCycleData adds the given related objects to the existing relationships
// of the sap_maintenance_plan_header_datum, optionally inserting them as new records.
// Appends related to o.R.MaintenancePlanSapMaintenancePlanStrategyCycleData.
// Sets related.R.MaintenancePlanSapMaintenancePlanHeaderDatum appropriately.
func (o *SapMaintenancePlanHeaderDatum) AddMaintenancePlanSapMaintenancePlanStrategyCycleData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapMaintenancePlanStrategyCycleDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MaintenancePlan = o.MaintenancePlan
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_maintenance_plan_strategy_cycle_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"MaintenancePlan"}),
				strmangle.WhereClause("`", "`", 0, sapMaintenancePlanStrategyCycleDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.MaintenancePlan, rel.MaintenancePlan, rel.MaintenancePlanCycle}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MaintenancePlan = o.MaintenancePlan
		}
	}

	if o.R == nil {
		o.R = &sapMaintenancePlanHeaderDatumR{
			MaintenancePlanSapMaintenancePlanStrategyCycleData: related,
		}
	} else {
		o.R.MaintenancePlanSapMaintenancePlanStrategyCycleData = append(o.R.MaintenancePlanSapMaintenancePlanStrategyCycleData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapMaintenancePlanStrategyCycleDatumR{
				MaintenancePlanSapMaintenancePlanHeaderDatum: o,
			}
		} else {
			rel.R.MaintenancePlanSapMaintenancePlanHeaderDatum = o
		}
	}
	return nil
}

// SapMaintenancePlanHeaderData retrieves all the records using an executor.
func SapMaintenancePlanHeaderData(mods ...qm.QueryMod) sapMaintenancePlanHeaderDatumQuery {
	mods = append(mods, qm.From("`sap_maintenance_plan_header_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`sap_maintenance_plan_header_data`.*"})
	}

	return sapMaintenancePlanHeaderDatumQuery{q}
}

// FindSapMaintenancePlanHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapMaintenancePlanHeaderDatum(ctx context.Context, exec boil.ContextExecutor, maintenancePlan string, selectCols ...string) (*SapMaintenancePlanHeaderDatum, error) {
	sapMaintenancePlanHeaderDatumObj := &SapMaintenancePlanHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_maintenance_plan_header_data` where `MaintenancePlan`=?", sel,
	)

	q := queries.Raw(query, maintenancePlan)

	err := q.Bind(ctx, exec, sapMaintenancePlanHeaderDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_maintenance_plan_header_data")
	}

	if err = sapMaintenancePlanHeaderDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapMaintenancePlanHeaderDatumObj, err
	}

	return sapMaintenancePlanHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapMaintenancePlanHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_maintenance_plan_header_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapMaintenancePlanHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapMaintenancePlanHeaderDatumInsertCacheMut.RLock()
	cache, cached := sapMaintenancePlanHeaderDatumInsertCache[key]
	sapMaintenancePlanHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapMaintenancePlanHeaderDatumAllColumns,
			sapMaintenancePlanHeaderDatumColumnsWithDefault,
			sapMaintenancePlanHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapMaintenancePlanHeaderDatumType, sapMaintenancePlanHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapMaintenancePlanHeaderDatumType, sapMaintenancePlanHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_maintenance_plan_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_maintenance_plan_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_maintenance_plan_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapMaintenancePlanHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_maintenance_plan_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.MaintenancePlan,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_maintenance_plan_header_data")
	}

CacheNoHooks:
	if !cached {
		sapMaintenancePlanHeaderDatumInsertCacheMut.Lock()
		sapMaintenancePlanHeaderDatumInsertCache[key] = cache
		sapMaintenancePlanHeaderDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapMaintenancePlanHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapMaintenancePlanHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapMaintenancePlanHeaderDatumUpdateCacheMut.RLock()
	cache, cached := sapMaintenancePlanHeaderDatumUpdateCache[key]
	sapMaintenancePlanHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapMaintenancePlanHeaderDatumAllColumns,
			sapMaintenancePlanHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_maintenance_plan_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_maintenance_plan_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapMaintenancePlanHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapMaintenancePlanHeaderDatumType, sapMaintenancePlanHeaderDatumMapping, append(wl, sapMaintenancePlanHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_maintenance_plan_header_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_maintenance_plan_header_data")
	}

	if !cached {
		sapMaintenancePlanHeaderDatumUpdateCacheMut.Lock()
		sapMaintenancePlanHeaderDatumUpdateCache[key] = cache
		sapMaintenancePlanHeaderDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapMaintenancePlanHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_maintenance_plan_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_maintenance_plan_header_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapMaintenancePlanHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapMaintenancePlanHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_maintenance_plan_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapMaintenancePlanHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapMaintenancePlanHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapMaintenancePlanHeaderDatum")
	}
	return rowsAff, nil
}

var mySQLSapMaintenancePlanHeaderDatumUniqueColumns = []string{
	"MaintenancePlan",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapMaintenancePlanHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_maintenance_plan_header_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapMaintenancePlanHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapMaintenancePlanHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapMaintenancePlanHeaderDatumUpsertCacheMut.RLock()
	cache, cached := sapMaintenancePlanHeaderDatumUpsertCache[key]
	sapMaintenancePlanHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapMaintenancePlanHeaderDatumAllColumns,
			sapMaintenancePlanHeaderDatumColumnsWithDefault,
			sapMaintenancePlanHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapMaintenancePlanHeaderDatumAllColumns,
			sapMaintenancePlanHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_maintenance_plan_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_maintenance_plan_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_maintenance_plan_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapMaintenancePlanHeaderDatumType, sapMaintenancePlanHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapMaintenancePlanHeaderDatumType, sapMaintenancePlanHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_maintenance_plan_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapMaintenancePlanHeaderDatumType, sapMaintenancePlanHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_maintenance_plan_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_maintenance_plan_header_data")
	}

CacheNoHooks:
	if !cached {
		sapMaintenancePlanHeaderDatumUpsertCacheMut.Lock()
		sapMaintenancePlanHeaderDatumUpsertCache[key] = cache
		sapMaintenancePlanHeaderDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapMaintenancePlanHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapMaintenancePlanHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapMaintenancePlanHeaderDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapMaintenancePlanHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_maintenance_plan_header_data` WHERE `MaintenancePlan`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_maintenance_plan_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_maintenance_plan_header_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapMaintenancePlanHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapMaintenancePlanHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_maintenance_plan_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_maintenance_plan_header_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapMaintenancePlanHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapMaintenancePlanHeaderDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapMaintenancePlanHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_maintenance_plan_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapMaintenancePlanHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapMaintenancePlanHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_maintenance_plan_header_data")
	}

	if len(sapMaintenancePlanHeaderDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapMaintenancePlanHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapMaintenancePlanHeaderDatum(ctx, exec, o.MaintenancePlan)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapMaintenancePlanHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapMaintenancePlanHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapMaintenancePlanHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_maintenance_plan_header_data`.* FROM `sap_maintenance_plan_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapMaintenancePlanHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapMaintenancePlanHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// SapMaintenancePlanHeaderDatumExists checks if the SapMaintenancePlanHeaderDatum row exists.
func SapMaintenancePlanHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, maintenancePlan string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_maintenance_plan_header_data` where `MaintenancePlan`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, maintenancePlan)
	}
	row := exec.QueryRowContext(ctx, sql, maintenancePlan)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_maintenance_plan_header_data exists")
	}

	return exists, nil
}
