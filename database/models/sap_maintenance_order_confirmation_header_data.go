// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapMaintenanceOrderConfirmationHeaderDatum is an object representing the database table.
type SapMaintenanceOrderConfirmationHeaderDatum struct {
	MaintOrderConf                 string      `boil:"MaintOrderConf" json:"MaintOrderConf" toml:"MaintOrderConf" yaml:"MaintOrderConf"`
	MaintOrderConfCntrValue        string      `boil:"MaintOrderConfCntrValue" json:"MaintOrderConfCntrValue" toml:"MaintOrderConfCntrValue" yaml:"MaintOrderConfCntrValue"`
	MaintenanceOrder               null.String `boil:"MaintenanceOrder" json:"MaintenanceOrder,omitempty" toml:"MaintenanceOrder" yaml:"MaintenanceOrder,omitempty"`
	MaintenanceOrderOperation      null.String `boil:"MaintenanceOrderOperation" json:"MaintenanceOrderOperation,omitempty" toml:"MaintenanceOrderOperation" yaml:"MaintenanceOrderOperation,omitempty"`
	MaintenanceOrderSubOperation   null.String `boil:"MaintenanceOrderSubOperation" json:"MaintenanceOrderSubOperation,omitempty" toml:"MaintenanceOrderSubOperation" yaml:"MaintenanceOrderSubOperation,omitempty"`
	PersonnelNumber                null.String `boil:"PersonnelNumber" json:"PersonnelNumber,omitempty" toml:"PersonnelNumber" yaml:"PersonnelNumber,omitempty"`
	ActualWorkQuantity             null.String `boil:"ActualWorkQuantity" json:"ActualWorkQuantity,omitempty" toml:"ActualWorkQuantity" yaml:"ActualWorkQuantity,omitempty"`
	ActualWorkQuantityUnit         null.String `boil:"ActualWorkQuantityUnit" json:"ActualWorkQuantityUnit,omitempty" toml:"ActualWorkQuantityUnit" yaml:"ActualWorkQuantityUnit,omitempty"`
	ActualDuration                 null.String `boil:"ActualDuration" json:"ActualDuration,omitempty" toml:"ActualDuration" yaml:"ActualDuration,omitempty"`
	ActualDurationUnit             null.String `boil:"ActualDurationUnit" json:"ActualDurationUnit,omitempty" toml:"ActualDurationUnit" yaml:"ActualDurationUnit,omitempty"`
	OperationConfirmedStartDate    null.String `boil:"OperationConfirmedStartDate" json:"OperationConfirmedStartDate,omitempty" toml:"OperationConfirmedStartDate" yaml:"OperationConfirmedStartDate,omitempty"`
	OperationConfirmedStartTime    null.String `boil:"OperationConfirmedStartTime" json:"OperationConfirmedStartTime,omitempty" toml:"OperationConfirmedStartTime" yaml:"OperationConfirmedStartTime,omitempty"`
	OperationConfirmedEndDate      null.String `boil:"OperationConfirmedEndDate" json:"OperationConfirmedEndDate,omitempty" toml:"OperationConfirmedEndDate" yaml:"OperationConfirmedEndDate,omitempty"`
	OperationConfirmedEndTime      null.String `boil:"OperationConfirmedEndTime" json:"OperationConfirmedEndTime,omitempty" toml:"OperationConfirmedEndTime" yaml:"OperationConfirmedEndTime,omitempty"`
	IsFinalConfirmation            null.Bool   `boil:"IsFinalConfirmation" json:"IsFinalConfirmation,omitempty" toml:"IsFinalConfirmation" yaml:"IsFinalConfirmation,omitempty"`
	NoFurtherWorkQuantityIsExpd    null.Bool   `boil:"NoFurtherWorkQuantityIsExpd" json:"NoFurtherWorkQuantityIsExpd,omitempty" toml:"NoFurtherWorkQuantityIsExpd" yaml:"NoFurtherWorkQuantityIsExpd,omitempty"`
	RemainingWorkQuantity          null.String `boil:"RemainingWorkQuantity" json:"RemainingWorkQuantity,omitempty" toml:"RemainingWorkQuantity" yaml:"RemainingWorkQuantity,omitempty"`
	RemainingWorkQuantityUnit      null.String `boil:"RemainingWorkQuantityUnit" json:"RemainingWorkQuantityUnit,omitempty" toml:"RemainingWorkQuantityUnit" yaml:"RemainingWorkQuantityUnit,omitempty"`
	PostingDate                    null.String `boil:"PostingDate" json:"PostingDate,omitempty" toml:"PostingDate" yaml:"PostingDate,omitempty"`
	ActivityType                   null.String `boil:"ActivityType" json:"ActivityType,omitempty" toml:"ActivityType" yaml:"ActivityType,omitempty"`
	OpenReservationsIsCleared      null.Bool   `boil:"OpenReservationsIsCleared" json:"OpenReservationsIsCleared,omitempty" toml:"OpenReservationsIsCleared" yaml:"OpenReservationsIsCleared,omitempty"`
	ConfirmationText               null.String `boil:"ConfirmationText" json:"ConfirmationText,omitempty" toml:"ConfirmationText" yaml:"ConfirmationText,omitempty"`
	VarianceReasonCode             null.String `boil:"VarianceReasonCode" json:"VarianceReasonCode,omitempty" toml:"VarianceReasonCode" yaml:"VarianceReasonCode,omitempty"`
	CapacityInternalID             null.String `boil:"CapacityInternalID" json:"CapacityInternalID,omitempty" toml:"CapacityInternalID" yaml:"CapacityInternalID,omitempty"`
	NmbrOfMaintTechnicianCapSplits null.Int    `boil:"NmbrOfMaintTechnicianCapSplits" json:"NmbrOfMaintTechnicianCapSplits,omitempty" toml:"NmbrOfMaintTechnicianCapSplits" yaml:"NmbrOfMaintTechnicianCapSplits,omitempty"`
	MaterialDocument               null.String `boil:"MaterialDocument" json:"MaterialDocument,omitempty" toml:"MaterialDocument" yaml:"MaterialDocument,omitempty"`
	AccountingIndicatorCode        null.String `boil:"AccountingIndicatorCode" json:"AccountingIndicatorCode,omitempty" toml:"AccountingIndicatorCode" yaml:"AccountingIndicatorCode,omitempty"`
	ActyConfFcstdEndDate           null.String `boil:"ActyConfFcstdEndDate" json:"ActyConfFcstdEndDate,omitempty" toml:"ActyConfFcstdEndDate" yaml:"ActyConfFcstdEndDate,omitempty"`
	ActyConfFcstdEndTime           null.String `boil:"ActyConfFcstdEndTime" json:"ActyConfFcstdEndTime,omitempty" toml:"ActyConfFcstdEndTime" yaml:"ActyConfFcstdEndTime,omitempty"`

	R *sapMaintenanceOrderConfirmationHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapMaintenanceOrderConfirmationHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapMaintenanceOrderConfirmationHeaderDatumColumns = struct {
	MaintOrderConf                 string
	MaintOrderConfCntrValue        string
	MaintenanceOrder               string
	MaintenanceOrderOperation      string
	MaintenanceOrderSubOperation   string
	PersonnelNumber                string
	ActualWorkQuantity             string
	ActualWorkQuantityUnit         string
	ActualDuration                 string
	ActualDurationUnit             string
	OperationConfirmedStartDate    string
	OperationConfirmedStartTime    string
	OperationConfirmedEndDate      string
	OperationConfirmedEndTime      string
	IsFinalConfirmation            string
	NoFurtherWorkQuantityIsExpd    string
	RemainingWorkQuantity          string
	RemainingWorkQuantityUnit      string
	PostingDate                    string
	ActivityType                   string
	OpenReservationsIsCleared      string
	ConfirmationText               string
	VarianceReasonCode             string
	CapacityInternalID             string
	NmbrOfMaintTechnicianCapSplits string
	MaterialDocument               string
	AccountingIndicatorCode        string
	ActyConfFcstdEndDate           string
	ActyConfFcstdEndTime           string
}{
	MaintOrderConf:                 "MaintOrderConf",
	MaintOrderConfCntrValue:        "MaintOrderConfCntrValue",
	MaintenanceOrder:               "MaintenanceOrder",
	MaintenanceOrderOperation:      "MaintenanceOrderOperation",
	MaintenanceOrderSubOperation:   "MaintenanceOrderSubOperation",
	PersonnelNumber:                "PersonnelNumber",
	ActualWorkQuantity:             "ActualWorkQuantity",
	ActualWorkQuantityUnit:         "ActualWorkQuantityUnit",
	ActualDuration:                 "ActualDuration",
	ActualDurationUnit:             "ActualDurationUnit",
	OperationConfirmedStartDate:    "OperationConfirmedStartDate",
	OperationConfirmedStartTime:    "OperationConfirmedStartTime",
	OperationConfirmedEndDate:      "OperationConfirmedEndDate",
	OperationConfirmedEndTime:      "OperationConfirmedEndTime",
	IsFinalConfirmation:            "IsFinalConfirmation",
	NoFurtherWorkQuantityIsExpd:    "NoFurtherWorkQuantityIsExpd",
	RemainingWorkQuantity:          "RemainingWorkQuantity",
	RemainingWorkQuantityUnit:      "RemainingWorkQuantityUnit",
	PostingDate:                    "PostingDate",
	ActivityType:                   "ActivityType",
	OpenReservationsIsCleared:      "OpenReservationsIsCleared",
	ConfirmationText:               "ConfirmationText",
	VarianceReasonCode:             "VarianceReasonCode",
	CapacityInternalID:             "CapacityInternalID",
	NmbrOfMaintTechnicianCapSplits: "NmbrOfMaintTechnicianCapSplits",
	MaterialDocument:               "MaterialDocument",
	AccountingIndicatorCode:        "AccountingIndicatorCode",
	ActyConfFcstdEndDate:           "ActyConfFcstdEndDate",
	ActyConfFcstdEndTime:           "ActyConfFcstdEndTime",
}

var SapMaintenanceOrderConfirmationHeaderDatumTableColumns = struct {
	MaintOrderConf                 string
	MaintOrderConfCntrValue        string
	MaintenanceOrder               string
	MaintenanceOrderOperation      string
	MaintenanceOrderSubOperation   string
	PersonnelNumber                string
	ActualWorkQuantity             string
	ActualWorkQuantityUnit         string
	ActualDuration                 string
	ActualDurationUnit             string
	OperationConfirmedStartDate    string
	OperationConfirmedStartTime    string
	OperationConfirmedEndDate      string
	OperationConfirmedEndTime      string
	IsFinalConfirmation            string
	NoFurtherWorkQuantityIsExpd    string
	RemainingWorkQuantity          string
	RemainingWorkQuantityUnit      string
	PostingDate                    string
	ActivityType                   string
	OpenReservationsIsCleared      string
	ConfirmationText               string
	VarianceReasonCode             string
	CapacityInternalID             string
	NmbrOfMaintTechnicianCapSplits string
	MaterialDocument               string
	AccountingIndicatorCode        string
	ActyConfFcstdEndDate           string
	ActyConfFcstdEndTime           string
}{
	MaintOrderConf:                 "sap_maintenance_order_confirmation_header_data.MaintOrderConf",
	MaintOrderConfCntrValue:        "sap_maintenance_order_confirmation_header_data.MaintOrderConfCntrValue",
	MaintenanceOrder:               "sap_maintenance_order_confirmation_header_data.MaintenanceOrder",
	MaintenanceOrderOperation:      "sap_maintenance_order_confirmation_header_data.MaintenanceOrderOperation",
	MaintenanceOrderSubOperation:   "sap_maintenance_order_confirmation_header_data.MaintenanceOrderSubOperation",
	PersonnelNumber:                "sap_maintenance_order_confirmation_header_data.PersonnelNumber",
	ActualWorkQuantity:             "sap_maintenance_order_confirmation_header_data.ActualWorkQuantity",
	ActualWorkQuantityUnit:         "sap_maintenance_order_confirmation_header_data.ActualWorkQuantityUnit",
	ActualDuration:                 "sap_maintenance_order_confirmation_header_data.ActualDuration",
	ActualDurationUnit:             "sap_maintenance_order_confirmation_header_data.ActualDurationUnit",
	OperationConfirmedStartDate:    "sap_maintenance_order_confirmation_header_data.OperationConfirmedStartDate",
	OperationConfirmedStartTime:    "sap_maintenance_order_confirmation_header_data.OperationConfirmedStartTime",
	OperationConfirmedEndDate:      "sap_maintenance_order_confirmation_header_data.OperationConfirmedEndDate",
	OperationConfirmedEndTime:      "sap_maintenance_order_confirmation_header_data.OperationConfirmedEndTime",
	IsFinalConfirmation:            "sap_maintenance_order_confirmation_header_data.IsFinalConfirmation",
	NoFurtherWorkQuantityIsExpd:    "sap_maintenance_order_confirmation_header_data.NoFurtherWorkQuantityIsExpd",
	RemainingWorkQuantity:          "sap_maintenance_order_confirmation_header_data.RemainingWorkQuantity",
	RemainingWorkQuantityUnit:      "sap_maintenance_order_confirmation_header_data.RemainingWorkQuantityUnit",
	PostingDate:                    "sap_maintenance_order_confirmation_header_data.PostingDate",
	ActivityType:                   "sap_maintenance_order_confirmation_header_data.ActivityType",
	OpenReservationsIsCleared:      "sap_maintenance_order_confirmation_header_data.OpenReservationsIsCleared",
	ConfirmationText:               "sap_maintenance_order_confirmation_header_data.ConfirmationText",
	VarianceReasonCode:             "sap_maintenance_order_confirmation_header_data.VarianceReasonCode",
	CapacityInternalID:             "sap_maintenance_order_confirmation_header_data.CapacityInternalID",
	NmbrOfMaintTechnicianCapSplits: "sap_maintenance_order_confirmation_header_data.NmbrOfMaintTechnicianCapSplits",
	MaterialDocument:               "sap_maintenance_order_confirmation_header_data.MaterialDocument",
	AccountingIndicatorCode:        "sap_maintenance_order_confirmation_header_data.AccountingIndicatorCode",
	ActyConfFcstdEndDate:           "sap_maintenance_order_confirmation_header_data.ActyConfFcstdEndDate",
	ActyConfFcstdEndTime:           "sap_maintenance_order_confirmation_header_data.ActyConfFcstdEndTime",
}

// Generated where

var SapMaintenanceOrderConfirmationHeaderDatumWhere = struct {
	MaintOrderConf                 whereHelperstring
	MaintOrderConfCntrValue        whereHelperstring
	MaintenanceOrder               whereHelpernull_String
	MaintenanceOrderOperation      whereHelpernull_String
	MaintenanceOrderSubOperation   whereHelpernull_String
	PersonnelNumber                whereHelpernull_String
	ActualWorkQuantity             whereHelpernull_String
	ActualWorkQuantityUnit         whereHelpernull_String
	ActualDuration                 whereHelpernull_String
	ActualDurationUnit             whereHelpernull_String
	OperationConfirmedStartDate    whereHelpernull_String
	OperationConfirmedStartTime    whereHelpernull_String
	OperationConfirmedEndDate      whereHelpernull_String
	OperationConfirmedEndTime      whereHelpernull_String
	IsFinalConfirmation            whereHelpernull_Bool
	NoFurtherWorkQuantityIsExpd    whereHelpernull_Bool
	RemainingWorkQuantity          whereHelpernull_String
	RemainingWorkQuantityUnit      whereHelpernull_String
	PostingDate                    whereHelpernull_String
	ActivityType                   whereHelpernull_String
	OpenReservationsIsCleared      whereHelpernull_Bool
	ConfirmationText               whereHelpernull_String
	VarianceReasonCode             whereHelpernull_String
	CapacityInternalID             whereHelpernull_String
	NmbrOfMaintTechnicianCapSplits whereHelpernull_Int
	MaterialDocument               whereHelpernull_String
	AccountingIndicatorCode        whereHelpernull_String
	ActyConfFcstdEndDate           whereHelpernull_String
	ActyConfFcstdEndTime           whereHelpernull_String
}{
	MaintOrderConf:                 whereHelperstring{field: "`sap_maintenance_order_confirmation_header_data`.`MaintOrderConf`"},
	MaintOrderConfCntrValue:        whereHelperstring{field: "`sap_maintenance_order_confirmation_header_data`.`MaintOrderConfCntrValue`"},
	MaintenanceOrder:               whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`MaintenanceOrder`"},
	MaintenanceOrderOperation:      whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`MaintenanceOrderOperation`"},
	MaintenanceOrderSubOperation:   whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`MaintenanceOrderSubOperation`"},
	PersonnelNumber:                whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`PersonnelNumber`"},
	ActualWorkQuantity:             whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`ActualWorkQuantity`"},
	ActualWorkQuantityUnit:         whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`ActualWorkQuantityUnit`"},
	ActualDuration:                 whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`ActualDuration`"},
	ActualDurationUnit:             whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`ActualDurationUnit`"},
	OperationConfirmedStartDate:    whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`OperationConfirmedStartDate`"},
	OperationConfirmedStartTime:    whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`OperationConfirmedStartTime`"},
	OperationConfirmedEndDate:      whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`OperationConfirmedEndDate`"},
	OperationConfirmedEndTime:      whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`OperationConfirmedEndTime`"},
	IsFinalConfirmation:            whereHelpernull_Bool{field: "`sap_maintenance_order_confirmation_header_data`.`IsFinalConfirmation`"},
	NoFurtherWorkQuantityIsExpd:    whereHelpernull_Bool{field: "`sap_maintenance_order_confirmation_header_data`.`NoFurtherWorkQuantityIsExpd`"},
	RemainingWorkQuantity:          whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`RemainingWorkQuantity`"},
	RemainingWorkQuantityUnit:      whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`RemainingWorkQuantityUnit`"},
	PostingDate:                    whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`PostingDate`"},
	ActivityType:                   whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`ActivityType`"},
	OpenReservationsIsCleared:      whereHelpernull_Bool{field: "`sap_maintenance_order_confirmation_header_data`.`OpenReservationsIsCleared`"},
	ConfirmationText:               whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`ConfirmationText`"},
	VarianceReasonCode:             whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`VarianceReasonCode`"},
	CapacityInternalID:             whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`CapacityInternalID`"},
	NmbrOfMaintTechnicianCapSplits: whereHelpernull_Int{field: "`sap_maintenance_order_confirmation_header_data`.`NmbrOfMaintTechnicianCapSplits`"},
	MaterialDocument:               whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`MaterialDocument`"},
	AccountingIndicatorCode:        whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`AccountingIndicatorCode`"},
	ActyConfFcstdEndDate:           whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`ActyConfFcstdEndDate`"},
	ActyConfFcstdEndTime:           whereHelpernull_String{field: "`sap_maintenance_order_confirmation_header_data`.`ActyConfFcstdEndTime`"},
}

// SapMaintenanceOrderConfirmationHeaderDatumRels is where relationship names are stored.
var SapMaintenanceOrderConfirmationHeaderDatumRels = struct {
}{}

// sapMaintenanceOrderConfirmationHeaderDatumR is where relationships are stored.
type sapMaintenanceOrderConfirmationHeaderDatumR struct {
}

// NewStruct creates a new relationship struct
func (*sapMaintenanceOrderConfirmationHeaderDatumR) NewStruct() *sapMaintenanceOrderConfirmationHeaderDatumR {
	return &sapMaintenanceOrderConfirmationHeaderDatumR{}
}

// sapMaintenanceOrderConfirmationHeaderDatumL is where Load methods for each relationship are stored.
type sapMaintenanceOrderConfirmationHeaderDatumL struct{}

var (
	sapMaintenanceOrderConfirmationHeaderDatumAllColumns            = []string{"MaintOrderConf", "MaintOrderConfCntrValue", "MaintenanceOrder", "MaintenanceOrderOperation", "MaintenanceOrderSubOperation", "PersonnelNumber", "ActualWorkQuantity", "ActualWorkQuantityUnit", "ActualDuration", "ActualDurationUnit", "OperationConfirmedStartDate", "OperationConfirmedStartTime", "OperationConfirmedEndDate", "OperationConfirmedEndTime", "IsFinalConfirmation", "NoFurtherWorkQuantityIsExpd", "RemainingWorkQuantity", "RemainingWorkQuantityUnit", "PostingDate", "ActivityType", "OpenReservationsIsCleared", "ConfirmationText", "VarianceReasonCode", "CapacityInternalID", "NmbrOfMaintTechnicianCapSplits", "MaterialDocument", "AccountingIndicatorCode", "ActyConfFcstdEndDate", "ActyConfFcstdEndTime"}
	sapMaintenanceOrderConfirmationHeaderDatumColumnsWithoutDefault = []string{"MaintOrderConf", "MaintOrderConfCntrValue", "MaintenanceOrder", "MaintenanceOrderOperation", "MaintenanceOrderSubOperation", "PersonnelNumber", "ActualWorkQuantity", "ActualWorkQuantityUnit", "ActualDuration", "ActualDurationUnit", "OperationConfirmedStartDate", "OperationConfirmedStartTime", "OperationConfirmedEndDate", "OperationConfirmedEndTime", "IsFinalConfirmation", "NoFurtherWorkQuantityIsExpd", "RemainingWorkQuantity", "RemainingWorkQuantityUnit", "PostingDate", "ActivityType", "OpenReservationsIsCleared", "ConfirmationText", "VarianceReasonCode", "CapacityInternalID", "NmbrOfMaintTechnicianCapSplits", "MaterialDocument", "AccountingIndicatorCode", "ActyConfFcstdEndDate", "ActyConfFcstdEndTime"}
	sapMaintenanceOrderConfirmationHeaderDatumColumnsWithDefault    = []string{}
	sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns     = []string{"MaintOrderConf"}
	sapMaintenanceOrderConfirmationHeaderDatumGeneratedColumns      = []string{}
)

type (
	// SapMaintenanceOrderConfirmationHeaderDatumSlice is an alias for a slice of pointers to SapMaintenanceOrderConfirmationHeaderDatum.
	// This should almost always be used instead of []SapMaintenanceOrderConfirmationHeaderDatum.
	SapMaintenanceOrderConfirmationHeaderDatumSlice []*SapMaintenanceOrderConfirmationHeaderDatum
	// SapMaintenanceOrderConfirmationHeaderDatumHook is the signature for custom SapMaintenanceOrderConfirmationHeaderDatum hook methods
	SapMaintenanceOrderConfirmationHeaderDatumHook func(context.Context, boil.ContextExecutor, *SapMaintenanceOrderConfirmationHeaderDatum) error

	sapMaintenanceOrderConfirmationHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapMaintenanceOrderConfirmationHeaderDatumType                 = reflect.TypeOf(&SapMaintenanceOrderConfirmationHeaderDatum{})
	sapMaintenanceOrderConfirmationHeaderDatumMapping              = queries.MakeStructMapping(sapMaintenanceOrderConfirmationHeaderDatumType)
	sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(sapMaintenanceOrderConfirmationHeaderDatumType, sapMaintenanceOrderConfirmationHeaderDatumMapping, sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns)
	sapMaintenanceOrderConfirmationHeaderDatumInsertCacheMut       sync.RWMutex
	sapMaintenanceOrderConfirmationHeaderDatumInsertCache          = make(map[string]insertCache)
	sapMaintenanceOrderConfirmationHeaderDatumUpdateCacheMut       sync.RWMutex
	sapMaintenanceOrderConfirmationHeaderDatumUpdateCache          = make(map[string]updateCache)
	sapMaintenanceOrderConfirmationHeaderDatumUpsertCacheMut       sync.RWMutex
	sapMaintenanceOrderConfirmationHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapMaintenanceOrderConfirmationHeaderDatumAfterSelectHooks []SapMaintenanceOrderConfirmationHeaderDatumHook

var sapMaintenanceOrderConfirmationHeaderDatumBeforeInsertHooks []SapMaintenanceOrderConfirmationHeaderDatumHook
var sapMaintenanceOrderConfirmationHeaderDatumAfterInsertHooks []SapMaintenanceOrderConfirmationHeaderDatumHook

var sapMaintenanceOrderConfirmationHeaderDatumBeforeUpdateHooks []SapMaintenanceOrderConfirmationHeaderDatumHook
var sapMaintenanceOrderConfirmationHeaderDatumAfterUpdateHooks []SapMaintenanceOrderConfirmationHeaderDatumHook

var sapMaintenanceOrderConfirmationHeaderDatumBeforeDeleteHooks []SapMaintenanceOrderConfirmationHeaderDatumHook
var sapMaintenanceOrderConfirmationHeaderDatumAfterDeleteHooks []SapMaintenanceOrderConfirmationHeaderDatumHook

var sapMaintenanceOrderConfirmationHeaderDatumBeforeUpsertHooks []SapMaintenanceOrderConfirmationHeaderDatumHook
var sapMaintenanceOrderConfirmationHeaderDatumAfterUpsertHooks []SapMaintenanceOrderConfirmationHeaderDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenanceOrderConfirmationHeaderDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenanceOrderConfirmationHeaderDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenanceOrderConfirmationHeaderDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenanceOrderConfirmationHeaderDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenanceOrderConfirmationHeaderDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenanceOrderConfirmationHeaderDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenanceOrderConfirmationHeaderDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenanceOrderConfirmationHeaderDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapMaintenanceOrderConfirmationHeaderDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapMaintenanceOrderConfirmationHeaderDatumHook registers your hook function for all future operations.
func AddSapMaintenanceOrderConfirmationHeaderDatumHook(hookPoint boil.HookPoint, sapMaintenanceOrderConfirmationHeaderDatumHook SapMaintenanceOrderConfirmationHeaderDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapMaintenanceOrderConfirmationHeaderDatumAfterSelectHooks = append(sapMaintenanceOrderConfirmationHeaderDatumAfterSelectHooks, sapMaintenanceOrderConfirmationHeaderDatumHook)
	case boil.BeforeInsertHook:
		sapMaintenanceOrderConfirmationHeaderDatumBeforeInsertHooks = append(sapMaintenanceOrderConfirmationHeaderDatumBeforeInsertHooks, sapMaintenanceOrderConfirmationHeaderDatumHook)
	case boil.AfterInsertHook:
		sapMaintenanceOrderConfirmationHeaderDatumAfterInsertHooks = append(sapMaintenanceOrderConfirmationHeaderDatumAfterInsertHooks, sapMaintenanceOrderConfirmationHeaderDatumHook)
	case boil.BeforeUpdateHook:
		sapMaintenanceOrderConfirmationHeaderDatumBeforeUpdateHooks = append(sapMaintenanceOrderConfirmationHeaderDatumBeforeUpdateHooks, sapMaintenanceOrderConfirmationHeaderDatumHook)
	case boil.AfterUpdateHook:
		sapMaintenanceOrderConfirmationHeaderDatumAfterUpdateHooks = append(sapMaintenanceOrderConfirmationHeaderDatumAfterUpdateHooks, sapMaintenanceOrderConfirmationHeaderDatumHook)
	case boil.BeforeDeleteHook:
		sapMaintenanceOrderConfirmationHeaderDatumBeforeDeleteHooks = append(sapMaintenanceOrderConfirmationHeaderDatumBeforeDeleteHooks, sapMaintenanceOrderConfirmationHeaderDatumHook)
	case boil.AfterDeleteHook:
		sapMaintenanceOrderConfirmationHeaderDatumAfterDeleteHooks = append(sapMaintenanceOrderConfirmationHeaderDatumAfterDeleteHooks, sapMaintenanceOrderConfirmationHeaderDatumHook)
	case boil.BeforeUpsertHook:
		sapMaintenanceOrderConfirmationHeaderDatumBeforeUpsertHooks = append(sapMaintenanceOrderConfirmationHeaderDatumBeforeUpsertHooks, sapMaintenanceOrderConfirmationHeaderDatumHook)
	case boil.AfterUpsertHook:
		sapMaintenanceOrderConfirmationHeaderDatumAfterUpsertHooks = append(sapMaintenanceOrderConfirmationHeaderDatumAfterUpsertHooks, sapMaintenanceOrderConfirmationHeaderDatumHook)
	}
}

// One returns a single sapMaintenanceOrderConfirmationHeaderDatum record from the query.
func (q sapMaintenanceOrderConfirmationHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapMaintenanceOrderConfirmationHeaderDatum, error) {
	o := &SapMaintenanceOrderConfirmationHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_maintenance_order_confirmation_header_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapMaintenanceOrderConfirmationHeaderDatum records from the query.
func (q sapMaintenanceOrderConfirmationHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapMaintenanceOrderConfirmationHeaderDatumSlice, error) {
	var o []*SapMaintenanceOrderConfirmationHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapMaintenanceOrderConfirmationHeaderDatum slice")
	}

	if len(sapMaintenanceOrderConfirmationHeaderDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapMaintenanceOrderConfirmationHeaderDatum records in the query.
func (q sapMaintenanceOrderConfirmationHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_maintenance_order_confirmation_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapMaintenanceOrderConfirmationHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_maintenance_order_confirmation_header_data exists")
	}

	return count > 0, nil
}

// SapMaintenanceOrderConfirmationHeaderData retrieves all the records using an executor.
func SapMaintenanceOrderConfirmationHeaderData(mods ...qm.QueryMod) sapMaintenanceOrderConfirmationHeaderDatumQuery {
	mods = append(mods, qm.From("`sap_maintenance_order_confirmation_header_data`"))
	return sapMaintenanceOrderConfirmationHeaderDatumQuery{NewQuery(mods...)}
}

// FindSapMaintenanceOrderConfirmationHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapMaintenanceOrderConfirmationHeaderDatum(ctx context.Context, exec boil.ContextExecutor, maintOrderConf string, selectCols ...string) (*SapMaintenanceOrderConfirmationHeaderDatum, error) {
	sapMaintenanceOrderConfirmationHeaderDatumObj := &SapMaintenanceOrderConfirmationHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_maintenance_order_confirmation_header_data` where `MaintOrderConf`=?", sel,
	)

	q := queries.Raw(query, maintOrderConf)

	err := q.Bind(ctx, exec, sapMaintenanceOrderConfirmationHeaderDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_maintenance_order_confirmation_header_data")
	}

	if err = sapMaintenanceOrderConfirmationHeaderDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapMaintenanceOrderConfirmationHeaderDatumObj, err
	}

	return sapMaintenanceOrderConfirmationHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_maintenance_order_confirmation_header_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapMaintenanceOrderConfirmationHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapMaintenanceOrderConfirmationHeaderDatumInsertCacheMut.RLock()
	cache, cached := sapMaintenanceOrderConfirmationHeaderDatumInsertCache[key]
	sapMaintenanceOrderConfirmationHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapMaintenanceOrderConfirmationHeaderDatumAllColumns,
			sapMaintenanceOrderConfirmationHeaderDatumColumnsWithDefault,
			sapMaintenanceOrderConfirmationHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapMaintenanceOrderConfirmationHeaderDatumType, sapMaintenanceOrderConfirmationHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapMaintenanceOrderConfirmationHeaderDatumType, sapMaintenanceOrderConfirmationHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_maintenance_order_confirmation_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_maintenance_order_confirmation_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_maintenance_order_confirmation_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_maintenance_order_confirmation_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.MaintOrderConf,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_maintenance_order_confirmation_header_data")
	}

CacheNoHooks:
	if !cached {
		sapMaintenanceOrderConfirmationHeaderDatumInsertCacheMut.Lock()
		sapMaintenanceOrderConfirmationHeaderDatumInsertCache[key] = cache
		sapMaintenanceOrderConfirmationHeaderDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapMaintenanceOrderConfirmationHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapMaintenanceOrderConfirmationHeaderDatumUpdateCacheMut.RLock()
	cache, cached := sapMaintenanceOrderConfirmationHeaderDatumUpdateCache[key]
	sapMaintenanceOrderConfirmationHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapMaintenanceOrderConfirmationHeaderDatumAllColumns,
			sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_maintenance_order_confirmation_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_maintenance_order_confirmation_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapMaintenanceOrderConfirmationHeaderDatumType, sapMaintenanceOrderConfirmationHeaderDatumMapping, append(wl, sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_maintenance_order_confirmation_header_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_maintenance_order_confirmation_header_data")
	}

	if !cached {
		sapMaintenanceOrderConfirmationHeaderDatumUpdateCacheMut.Lock()
		sapMaintenanceOrderConfirmationHeaderDatumUpdateCache[key] = cache
		sapMaintenanceOrderConfirmationHeaderDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapMaintenanceOrderConfirmationHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_maintenance_order_confirmation_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_maintenance_order_confirmation_header_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapMaintenanceOrderConfirmationHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_maintenance_order_confirmation_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapMaintenanceOrderConfirmationHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapMaintenanceOrderConfirmationHeaderDatum")
	}
	return rowsAff, nil
}

var mySQLSapMaintenanceOrderConfirmationHeaderDatumUniqueColumns = []string{
	"MaintOrderConf",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_maintenance_order_confirmation_header_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapMaintenanceOrderConfirmationHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapMaintenanceOrderConfirmationHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapMaintenanceOrderConfirmationHeaderDatumUpsertCacheMut.RLock()
	cache, cached := sapMaintenanceOrderConfirmationHeaderDatumUpsertCache[key]
	sapMaintenanceOrderConfirmationHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapMaintenanceOrderConfirmationHeaderDatumAllColumns,
			sapMaintenanceOrderConfirmationHeaderDatumColumnsWithDefault,
			sapMaintenanceOrderConfirmationHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapMaintenanceOrderConfirmationHeaderDatumAllColumns,
			sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_maintenance_order_confirmation_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_maintenance_order_confirmation_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_maintenance_order_confirmation_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapMaintenanceOrderConfirmationHeaderDatumType, sapMaintenanceOrderConfirmationHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapMaintenanceOrderConfirmationHeaderDatumType, sapMaintenanceOrderConfirmationHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_maintenance_order_confirmation_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapMaintenanceOrderConfirmationHeaderDatumType, sapMaintenanceOrderConfirmationHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_maintenance_order_confirmation_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_maintenance_order_confirmation_header_data")
	}

CacheNoHooks:
	if !cached {
		sapMaintenanceOrderConfirmationHeaderDatumUpsertCacheMut.Lock()
		sapMaintenanceOrderConfirmationHeaderDatumUpsertCache[key] = cache
		sapMaintenanceOrderConfirmationHeaderDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapMaintenanceOrderConfirmationHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapMaintenanceOrderConfirmationHeaderDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_maintenance_order_confirmation_header_data` WHERE `MaintOrderConf`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_maintenance_order_confirmation_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_maintenance_order_confirmation_header_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapMaintenanceOrderConfirmationHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapMaintenanceOrderConfirmationHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_maintenance_order_confirmation_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_maintenance_order_confirmation_header_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapMaintenanceOrderConfirmationHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapMaintenanceOrderConfirmationHeaderDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_maintenance_order_confirmation_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapMaintenanceOrderConfirmationHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_maintenance_order_confirmation_header_data")
	}

	if len(sapMaintenanceOrderConfirmationHeaderDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapMaintenanceOrderConfirmationHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapMaintenanceOrderConfirmationHeaderDatum(ctx, exec, o.MaintOrderConf)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapMaintenanceOrderConfirmationHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapMaintenanceOrderConfirmationHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_maintenance_order_confirmation_header_data`.* FROM `sap_maintenance_order_confirmation_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapMaintenanceOrderConfirmationHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapMaintenanceOrderConfirmationHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// SapMaintenanceOrderConfirmationHeaderDatumExists checks if the SapMaintenanceOrderConfirmationHeaderDatum row exists.
func SapMaintenanceOrderConfirmationHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, maintOrderConf string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_maintenance_order_confirmation_header_data` where `MaintOrderConf`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, maintOrderConf)
	}
	row := exec.QueryRowContext(ctx, sql, maintOrderConf)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_maintenance_order_confirmation_header_data exists")
	}

	return exists, nil
}
