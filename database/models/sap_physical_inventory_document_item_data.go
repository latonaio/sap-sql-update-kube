// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapPhysicalInventoryDocumentItemDatum is an object representing the database table.
type SapPhysicalInventoryDocumentItemDatum struct {
	FiscalYear                     string      `boil:"FiscalYear" json:"FiscalYear" toml:"FiscalYear" yaml:"FiscalYear"`
	PhysicalInventoryDocument      string      `boil:"PhysicalInventoryDocument" json:"PhysicalInventoryDocument" toml:"PhysicalInventoryDocument" yaml:"PhysicalInventoryDocument"`
	PhysicalInventoryDocumentItem  string      `boil:"PhysicalInventoryDocumentItem" json:"PhysicalInventoryDocumentItem" toml:"PhysicalInventoryDocumentItem" yaml:"PhysicalInventoryDocumentItem"`
	Plant                          null.String `boil:"Plant" json:"Plant,omitempty" toml:"Plant" yaml:"Plant,omitempty"`
	StorageLocation                null.String `boil:"StorageLocation" json:"StorageLocation,omitempty" toml:"StorageLocation" yaml:"StorageLocation,omitempty"`
	InventorySpecialStockType      null.String `boil:"InventorySpecialStockType" json:"InventorySpecialStockType,omitempty" toml:"InventorySpecialStockType" yaml:"InventorySpecialStockType,omitempty"`
	Material                       null.String `boil:"Material" json:"Material,omitempty" toml:"Material" yaml:"Material,omitempty"`
	Batch                          null.String `boil:"Batch" json:"Batch,omitempty" toml:"Batch" yaml:"Batch,omitempty"`
	PhysicalInventoryStockType     null.String `boil:"PhysicalInventoryStockType" json:"PhysicalInventoryStockType,omitempty" toml:"PhysicalInventoryStockType" yaml:"PhysicalInventoryStockType,omitempty"`
	SalesOrder                     null.String `boil:"SalesOrder" json:"SalesOrder,omitempty" toml:"SalesOrder" yaml:"SalesOrder,omitempty"`
	SalesOrderItem                 null.String `boil:"SalesOrderItem" json:"SalesOrderItem,omitempty" toml:"SalesOrderItem" yaml:"SalesOrderItem,omitempty"`
	Supplier                       null.String `boil:"Supplier" json:"Supplier,omitempty" toml:"Supplier" yaml:"Supplier,omitempty"`
	Customer                       null.String `boil:"Customer" json:"Customer,omitempty" toml:"Customer" yaml:"Customer,omitempty"`
	WBSElement                     null.String `boil:"WBSElement" json:"WBSElement,omitempty" toml:"WBSElement" yaml:"WBSElement,omitempty"`
	LastChangeDate                 null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	CountedByUser                  null.String `boil:"CountedByUser" json:"CountedByUser,omitempty" toml:"CountedByUser" yaml:"CountedByUser,omitempty"`
	PhysicalInventoryLastCountDate null.String `boil:"PhysicalInventoryLastCountDate" json:"PhysicalInventoryLastCountDate,omitempty" toml:"PhysicalInventoryLastCountDate" yaml:"PhysicalInventoryLastCountDate,omitempty"`
	AdjustmentPostingMadeByUser    null.String `boil:"AdjustmentPostingMadeByUser" json:"AdjustmentPostingMadeByUser,omitempty" toml:"AdjustmentPostingMadeByUser" yaml:"AdjustmentPostingMadeByUser,omitempty"`
	PostingDate                    null.String `boil:"PostingDate" json:"PostingDate,omitempty" toml:"PostingDate" yaml:"PostingDate,omitempty"`
	PhysicalInventoryItemIsCounted null.Bool   `boil:"PhysicalInventoryItemIsCounted" json:"PhysicalInventoryItemIsCounted,omitempty" toml:"PhysicalInventoryItemIsCounted" yaml:"PhysicalInventoryItemIsCounted,omitempty"`
	PhysInvtryDifferenceIsPosted   null.Bool   `boil:"PhysInvtryDifferenceIsPosted" json:"PhysInvtryDifferenceIsPosted,omitempty" toml:"PhysInvtryDifferenceIsPosted" yaml:"PhysInvtryDifferenceIsPosted,omitempty"`
	PhysInvtryItemIsRecounted      null.Bool   `boil:"PhysInvtryItemIsRecounted" json:"PhysInvtryItemIsRecounted,omitempty" toml:"PhysInvtryItemIsRecounted" yaml:"PhysInvtryItemIsRecounted,omitempty"`
	PhysInvtryItemIsDeleted        null.Bool   `boil:"PhysInvtryItemIsDeleted" json:"PhysInvtryItemIsDeleted,omitempty" toml:"PhysInvtryItemIsDeleted" yaml:"PhysInvtryItemIsDeleted,omitempty"`
	IsHandledInAltvUnitOfMsr       null.Bool   `boil:"IsHandledInAltvUnitOfMsr" json:"IsHandledInAltvUnitOfMsr,omitempty" toml:"IsHandledInAltvUnitOfMsr" yaml:"IsHandledInAltvUnitOfMsr,omitempty"`
	CycleCountType                 null.String `boil:"CycleCountType" json:"CycleCountType,omitempty" toml:"CycleCountType" yaml:"CycleCountType,omitempty"`
	IsValueOnlyMaterial            null.Bool   `boil:"IsValueOnlyMaterial" json:"IsValueOnlyMaterial,omitempty" toml:"IsValueOnlyMaterial" yaml:"IsValueOnlyMaterial,omitempty"`
	PhysInventoryReferenceNumber   null.String `boil:"PhysInventoryReferenceNumber" json:"PhysInventoryReferenceNumber,omitempty" toml:"PhysInventoryReferenceNumber" yaml:"PhysInventoryReferenceNumber,omitempty"`
	MaterialDocument               null.String `boil:"MaterialDocument" json:"MaterialDocument,omitempty" toml:"MaterialDocument" yaml:"MaterialDocument,omitempty"`
	MaterialDocumentYear           null.String `boil:"MaterialDocumentYear" json:"MaterialDocumentYear,omitempty" toml:"MaterialDocumentYear" yaml:"MaterialDocumentYear,omitempty"`
	MaterialDocumentItem           null.String `boil:"MaterialDocumentItem" json:"MaterialDocumentItem,omitempty" toml:"MaterialDocumentItem" yaml:"MaterialDocumentItem,omitempty"`
	PhysInvtryRecountDocument      null.String `boil:"PhysInvtryRecountDocument" json:"PhysInvtryRecountDocument,omitempty" toml:"PhysInvtryRecountDocument" yaml:"PhysInvtryRecountDocument,omitempty"`
	PhysicalInventoryItemIsZero    null.Bool   `boil:"PhysicalInventoryItemIsZero" json:"PhysicalInventoryItemIsZero,omitempty" toml:"PhysicalInventoryItemIsZero" yaml:"PhysicalInventoryItemIsZero,omitempty"`
	ReasonForPhysInvtryDifference  null.String `boil:"ReasonForPhysInvtryDifference" json:"ReasonForPhysInvtryDifference,omitempty" toml:"ReasonForPhysInvtryDifference" yaml:"ReasonForPhysInvtryDifference,omitempty"`
	MaterialBaseUnit               null.String `boil:"MaterialBaseUnit" json:"MaterialBaseUnit,omitempty" toml:"MaterialBaseUnit" yaml:"MaterialBaseUnit,omitempty"`
	BookQtyBfrCountInMatlBaseUnit  null.String `boil:"BookQtyBfrCountInMatlBaseUnit" json:"BookQtyBfrCountInMatlBaseUnit,omitempty" toml:"BookQtyBfrCountInMatlBaseUnit" yaml:"BookQtyBfrCountInMatlBaseUnit,omitempty"`
	Quantity                       null.String `boil:"Quantity" json:"Quantity,omitempty" toml:"Quantity" yaml:"Quantity,omitempty"`
	UnitOfEntry                    null.String `boil:"UnitOfEntry" json:"UnitOfEntry,omitempty" toml:"UnitOfEntry" yaml:"UnitOfEntry,omitempty"`
	QuantityInUnitOfEntry          null.String `boil:"QuantityInUnitOfEntry" json:"QuantityInUnitOfEntry,omitempty" toml:"QuantityInUnitOfEntry" yaml:"QuantityInUnitOfEntry,omitempty"`
	Currency                       null.String `boil:"Currency" json:"Currency,omitempty" toml:"Currency" yaml:"Currency,omitempty"`
	LastChangeDateTime             null.String `boil:"LastChangeDateTime" json:"LastChangeDateTime,omitempty" toml:"LastChangeDateTime" yaml:"LastChangeDateTime,omitempty"`

	R *sapPhysicalInventoryDocumentItemDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapPhysicalInventoryDocumentItemDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapPhysicalInventoryDocumentItemDatumColumns = struct {
	FiscalYear                     string
	PhysicalInventoryDocument      string
	PhysicalInventoryDocumentItem  string
	Plant                          string
	StorageLocation                string
	InventorySpecialStockType      string
	Material                       string
	Batch                          string
	PhysicalInventoryStockType     string
	SalesOrder                     string
	SalesOrderItem                 string
	Supplier                       string
	Customer                       string
	WBSElement                     string
	LastChangeDate                 string
	CountedByUser                  string
	PhysicalInventoryLastCountDate string
	AdjustmentPostingMadeByUser    string
	PostingDate                    string
	PhysicalInventoryItemIsCounted string
	PhysInvtryDifferenceIsPosted   string
	PhysInvtryItemIsRecounted      string
	PhysInvtryItemIsDeleted        string
	IsHandledInAltvUnitOfMsr       string
	CycleCountType                 string
	IsValueOnlyMaterial            string
	PhysInventoryReferenceNumber   string
	MaterialDocument               string
	MaterialDocumentYear           string
	MaterialDocumentItem           string
	PhysInvtryRecountDocument      string
	PhysicalInventoryItemIsZero    string
	ReasonForPhysInvtryDifference  string
	MaterialBaseUnit               string
	BookQtyBfrCountInMatlBaseUnit  string
	Quantity                       string
	UnitOfEntry                    string
	QuantityInUnitOfEntry          string
	Currency                       string
	LastChangeDateTime             string
}{
	FiscalYear:                     "FiscalYear",
	PhysicalInventoryDocument:      "PhysicalInventoryDocument",
	PhysicalInventoryDocumentItem:  "PhysicalInventoryDocumentItem",
	Plant:                          "Plant",
	StorageLocation:                "StorageLocation",
	InventorySpecialStockType:      "InventorySpecialStockType",
	Material:                       "Material",
	Batch:                          "Batch",
	PhysicalInventoryStockType:     "PhysicalInventoryStockType",
	SalesOrder:                     "SalesOrder",
	SalesOrderItem:                 "SalesOrderItem",
	Supplier:                       "Supplier",
	Customer:                       "Customer",
	WBSElement:                     "WBSElement",
	LastChangeDate:                 "LastChangeDate",
	CountedByUser:                  "CountedByUser",
	PhysicalInventoryLastCountDate: "PhysicalInventoryLastCountDate",
	AdjustmentPostingMadeByUser:    "AdjustmentPostingMadeByUser",
	PostingDate:                    "PostingDate",
	PhysicalInventoryItemIsCounted: "PhysicalInventoryItemIsCounted",
	PhysInvtryDifferenceIsPosted:   "PhysInvtryDifferenceIsPosted",
	PhysInvtryItemIsRecounted:      "PhysInvtryItemIsRecounted",
	PhysInvtryItemIsDeleted:        "PhysInvtryItemIsDeleted",
	IsHandledInAltvUnitOfMsr:       "IsHandledInAltvUnitOfMsr",
	CycleCountType:                 "CycleCountType",
	IsValueOnlyMaterial:            "IsValueOnlyMaterial",
	PhysInventoryReferenceNumber:   "PhysInventoryReferenceNumber",
	MaterialDocument:               "MaterialDocument",
	MaterialDocumentYear:           "MaterialDocumentYear",
	MaterialDocumentItem:           "MaterialDocumentItem",
	PhysInvtryRecountDocument:      "PhysInvtryRecountDocument",
	PhysicalInventoryItemIsZero:    "PhysicalInventoryItemIsZero",
	ReasonForPhysInvtryDifference:  "ReasonForPhysInvtryDifference",
	MaterialBaseUnit:               "MaterialBaseUnit",
	BookQtyBfrCountInMatlBaseUnit:  "BookQtyBfrCountInMatlBaseUnit",
	Quantity:                       "Quantity",
	UnitOfEntry:                    "UnitOfEntry",
	QuantityInUnitOfEntry:          "QuantityInUnitOfEntry",
	Currency:                       "Currency",
	LastChangeDateTime:             "LastChangeDateTime",
}

var SapPhysicalInventoryDocumentItemDatumTableColumns = struct {
	FiscalYear                     string
	PhysicalInventoryDocument      string
	PhysicalInventoryDocumentItem  string
	Plant                          string
	StorageLocation                string
	InventorySpecialStockType      string
	Material                       string
	Batch                          string
	PhysicalInventoryStockType     string
	SalesOrder                     string
	SalesOrderItem                 string
	Supplier                       string
	Customer                       string
	WBSElement                     string
	LastChangeDate                 string
	CountedByUser                  string
	PhysicalInventoryLastCountDate string
	AdjustmentPostingMadeByUser    string
	PostingDate                    string
	PhysicalInventoryItemIsCounted string
	PhysInvtryDifferenceIsPosted   string
	PhysInvtryItemIsRecounted      string
	PhysInvtryItemIsDeleted        string
	IsHandledInAltvUnitOfMsr       string
	CycleCountType                 string
	IsValueOnlyMaterial            string
	PhysInventoryReferenceNumber   string
	MaterialDocument               string
	MaterialDocumentYear           string
	MaterialDocumentItem           string
	PhysInvtryRecountDocument      string
	PhysicalInventoryItemIsZero    string
	ReasonForPhysInvtryDifference  string
	MaterialBaseUnit               string
	BookQtyBfrCountInMatlBaseUnit  string
	Quantity                       string
	UnitOfEntry                    string
	QuantityInUnitOfEntry          string
	Currency                       string
	LastChangeDateTime             string
}{
	FiscalYear:                     "sap_physical_inventory_document_item_data.FiscalYear",
	PhysicalInventoryDocument:      "sap_physical_inventory_document_item_data.PhysicalInventoryDocument",
	PhysicalInventoryDocumentItem:  "sap_physical_inventory_document_item_data.PhysicalInventoryDocumentItem",
	Plant:                          "sap_physical_inventory_document_item_data.Plant",
	StorageLocation:                "sap_physical_inventory_document_item_data.StorageLocation",
	InventorySpecialStockType:      "sap_physical_inventory_document_item_data.InventorySpecialStockType",
	Material:                       "sap_physical_inventory_document_item_data.Material",
	Batch:                          "sap_physical_inventory_document_item_data.Batch",
	PhysicalInventoryStockType:     "sap_physical_inventory_document_item_data.PhysicalInventoryStockType",
	SalesOrder:                     "sap_physical_inventory_document_item_data.SalesOrder",
	SalesOrderItem:                 "sap_physical_inventory_document_item_data.SalesOrderItem",
	Supplier:                       "sap_physical_inventory_document_item_data.Supplier",
	Customer:                       "sap_physical_inventory_document_item_data.Customer",
	WBSElement:                     "sap_physical_inventory_document_item_data.WBSElement",
	LastChangeDate:                 "sap_physical_inventory_document_item_data.LastChangeDate",
	CountedByUser:                  "sap_physical_inventory_document_item_data.CountedByUser",
	PhysicalInventoryLastCountDate: "sap_physical_inventory_document_item_data.PhysicalInventoryLastCountDate",
	AdjustmentPostingMadeByUser:    "sap_physical_inventory_document_item_data.AdjustmentPostingMadeByUser",
	PostingDate:                    "sap_physical_inventory_document_item_data.PostingDate",
	PhysicalInventoryItemIsCounted: "sap_physical_inventory_document_item_data.PhysicalInventoryItemIsCounted",
	PhysInvtryDifferenceIsPosted:   "sap_physical_inventory_document_item_data.PhysInvtryDifferenceIsPosted",
	PhysInvtryItemIsRecounted:      "sap_physical_inventory_document_item_data.PhysInvtryItemIsRecounted",
	PhysInvtryItemIsDeleted:        "sap_physical_inventory_document_item_data.PhysInvtryItemIsDeleted",
	IsHandledInAltvUnitOfMsr:       "sap_physical_inventory_document_item_data.IsHandledInAltvUnitOfMsr",
	CycleCountType:                 "sap_physical_inventory_document_item_data.CycleCountType",
	IsValueOnlyMaterial:            "sap_physical_inventory_document_item_data.IsValueOnlyMaterial",
	PhysInventoryReferenceNumber:   "sap_physical_inventory_document_item_data.PhysInventoryReferenceNumber",
	MaterialDocument:               "sap_physical_inventory_document_item_data.MaterialDocument",
	MaterialDocumentYear:           "sap_physical_inventory_document_item_data.MaterialDocumentYear",
	MaterialDocumentItem:           "sap_physical_inventory_document_item_data.MaterialDocumentItem",
	PhysInvtryRecountDocument:      "sap_physical_inventory_document_item_data.PhysInvtryRecountDocument",
	PhysicalInventoryItemIsZero:    "sap_physical_inventory_document_item_data.PhysicalInventoryItemIsZero",
	ReasonForPhysInvtryDifference:  "sap_physical_inventory_document_item_data.ReasonForPhysInvtryDifference",
	MaterialBaseUnit:               "sap_physical_inventory_document_item_data.MaterialBaseUnit",
	BookQtyBfrCountInMatlBaseUnit:  "sap_physical_inventory_document_item_data.BookQtyBfrCountInMatlBaseUnit",
	Quantity:                       "sap_physical_inventory_document_item_data.Quantity",
	UnitOfEntry:                    "sap_physical_inventory_document_item_data.UnitOfEntry",
	QuantityInUnitOfEntry:          "sap_physical_inventory_document_item_data.QuantityInUnitOfEntry",
	Currency:                       "sap_physical_inventory_document_item_data.Currency",
	LastChangeDateTime:             "sap_physical_inventory_document_item_data.LastChangeDateTime",
}

// Generated where

var SapPhysicalInventoryDocumentItemDatumWhere = struct {
	FiscalYear                     whereHelperstring
	PhysicalInventoryDocument      whereHelperstring
	PhysicalInventoryDocumentItem  whereHelperstring
	Plant                          whereHelpernull_String
	StorageLocation                whereHelpernull_String
	InventorySpecialStockType      whereHelpernull_String
	Material                       whereHelpernull_String
	Batch                          whereHelpernull_String
	PhysicalInventoryStockType     whereHelpernull_String
	SalesOrder                     whereHelpernull_String
	SalesOrderItem                 whereHelpernull_String
	Supplier                       whereHelpernull_String
	Customer                       whereHelpernull_String
	WBSElement                     whereHelpernull_String
	LastChangeDate                 whereHelpernull_String
	CountedByUser                  whereHelpernull_String
	PhysicalInventoryLastCountDate whereHelpernull_String
	AdjustmentPostingMadeByUser    whereHelpernull_String
	PostingDate                    whereHelpernull_String
	PhysicalInventoryItemIsCounted whereHelpernull_Bool
	PhysInvtryDifferenceIsPosted   whereHelpernull_Bool
	PhysInvtryItemIsRecounted      whereHelpernull_Bool
	PhysInvtryItemIsDeleted        whereHelpernull_Bool
	IsHandledInAltvUnitOfMsr       whereHelpernull_Bool
	CycleCountType                 whereHelpernull_String
	IsValueOnlyMaterial            whereHelpernull_Bool
	PhysInventoryReferenceNumber   whereHelpernull_String
	MaterialDocument               whereHelpernull_String
	MaterialDocumentYear           whereHelpernull_String
	MaterialDocumentItem           whereHelpernull_String
	PhysInvtryRecountDocument      whereHelpernull_String
	PhysicalInventoryItemIsZero    whereHelpernull_Bool
	ReasonForPhysInvtryDifference  whereHelpernull_String
	MaterialBaseUnit               whereHelpernull_String
	BookQtyBfrCountInMatlBaseUnit  whereHelpernull_String
	Quantity                       whereHelpernull_String
	UnitOfEntry                    whereHelpernull_String
	QuantityInUnitOfEntry          whereHelpernull_String
	Currency                       whereHelpernull_String
	LastChangeDateTime             whereHelpernull_String
}{
	FiscalYear:                     whereHelperstring{field: "`sap_physical_inventory_document_item_data`.`FiscalYear`"},
	PhysicalInventoryDocument:      whereHelperstring{field: "`sap_physical_inventory_document_item_data`.`PhysicalInventoryDocument`"},
	PhysicalInventoryDocumentItem:  whereHelperstring{field: "`sap_physical_inventory_document_item_data`.`PhysicalInventoryDocumentItem`"},
	Plant:                          whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`Plant`"},
	StorageLocation:                whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`StorageLocation`"},
	InventorySpecialStockType:      whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`InventorySpecialStockType`"},
	Material:                       whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`Material`"},
	Batch:                          whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`Batch`"},
	PhysicalInventoryStockType:     whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`PhysicalInventoryStockType`"},
	SalesOrder:                     whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`SalesOrder`"},
	SalesOrderItem:                 whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`SalesOrderItem`"},
	Supplier:                       whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`Supplier`"},
	Customer:                       whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`Customer`"},
	WBSElement:                     whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`WBSElement`"},
	LastChangeDate:                 whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`LastChangeDate`"},
	CountedByUser:                  whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`CountedByUser`"},
	PhysicalInventoryLastCountDate: whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`PhysicalInventoryLastCountDate`"},
	AdjustmentPostingMadeByUser:    whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`AdjustmentPostingMadeByUser`"},
	PostingDate:                    whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`PostingDate`"},
	PhysicalInventoryItemIsCounted: whereHelpernull_Bool{field: "`sap_physical_inventory_document_item_data`.`PhysicalInventoryItemIsCounted`"},
	PhysInvtryDifferenceIsPosted:   whereHelpernull_Bool{field: "`sap_physical_inventory_document_item_data`.`PhysInvtryDifferenceIsPosted`"},
	PhysInvtryItemIsRecounted:      whereHelpernull_Bool{field: "`sap_physical_inventory_document_item_data`.`PhysInvtryItemIsRecounted`"},
	PhysInvtryItemIsDeleted:        whereHelpernull_Bool{field: "`sap_physical_inventory_document_item_data`.`PhysInvtryItemIsDeleted`"},
	IsHandledInAltvUnitOfMsr:       whereHelpernull_Bool{field: "`sap_physical_inventory_document_item_data`.`IsHandledInAltvUnitOfMsr`"},
	CycleCountType:                 whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`CycleCountType`"},
	IsValueOnlyMaterial:            whereHelpernull_Bool{field: "`sap_physical_inventory_document_item_data`.`IsValueOnlyMaterial`"},
	PhysInventoryReferenceNumber:   whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`PhysInventoryReferenceNumber`"},
	MaterialDocument:               whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`MaterialDocument`"},
	MaterialDocumentYear:           whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`MaterialDocumentYear`"},
	MaterialDocumentItem:           whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`MaterialDocumentItem`"},
	PhysInvtryRecountDocument:      whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`PhysInvtryRecountDocument`"},
	PhysicalInventoryItemIsZero:    whereHelpernull_Bool{field: "`sap_physical_inventory_document_item_data`.`PhysicalInventoryItemIsZero`"},
	ReasonForPhysInvtryDifference:  whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`ReasonForPhysInvtryDifference`"},
	MaterialBaseUnit:               whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`MaterialBaseUnit`"},
	BookQtyBfrCountInMatlBaseUnit:  whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`BookQtyBfrCountInMatlBaseUnit`"},
	Quantity:                       whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`Quantity`"},
	UnitOfEntry:                    whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`UnitOfEntry`"},
	QuantityInUnitOfEntry:          whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`QuantityInUnitOfEntry`"},
	Currency:                       whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`Currency`"},
	LastChangeDateTime:             whereHelpernull_String{field: "`sap_physical_inventory_document_item_data`.`LastChangeDateTime`"},
}

// SapPhysicalInventoryDocumentItemDatumRels is where relationship names are stored.
var SapPhysicalInventoryDocumentItemDatumRels = struct {
}{}

// sapPhysicalInventoryDocumentItemDatumR is where relationships are stored.
type sapPhysicalInventoryDocumentItemDatumR struct {
}

// NewStruct creates a new relationship struct
func (*sapPhysicalInventoryDocumentItemDatumR) NewStruct() *sapPhysicalInventoryDocumentItemDatumR {
	return &sapPhysicalInventoryDocumentItemDatumR{}
}

// sapPhysicalInventoryDocumentItemDatumL is where Load methods for each relationship are stored.
type sapPhysicalInventoryDocumentItemDatumL struct{}

var (
	sapPhysicalInventoryDocumentItemDatumAllColumns            = []string{"FiscalYear", "PhysicalInventoryDocument", "PhysicalInventoryDocumentItem", "Plant", "StorageLocation", "InventorySpecialStockType", "Material", "Batch", "PhysicalInventoryStockType", "SalesOrder", "SalesOrderItem", "Supplier", "Customer", "WBSElement", "LastChangeDate", "CountedByUser", "PhysicalInventoryLastCountDate", "AdjustmentPostingMadeByUser", "PostingDate", "PhysicalInventoryItemIsCounted", "PhysInvtryDifferenceIsPosted", "PhysInvtryItemIsRecounted", "PhysInvtryItemIsDeleted", "IsHandledInAltvUnitOfMsr", "CycleCountType", "IsValueOnlyMaterial", "PhysInventoryReferenceNumber", "MaterialDocument", "MaterialDocumentYear", "MaterialDocumentItem", "PhysInvtryRecountDocument", "PhysicalInventoryItemIsZero", "ReasonForPhysInvtryDifference", "MaterialBaseUnit", "BookQtyBfrCountInMatlBaseUnit", "Quantity", "UnitOfEntry", "QuantityInUnitOfEntry", "Currency", "LastChangeDateTime"}
	sapPhysicalInventoryDocumentItemDatumColumnsWithoutDefault = []string{"FiscalYear", "PhysicalInventoryDocument", "PhysicalInventoryDocumentItem", "Plant", "StorageLocation", "InventorySpecialStockType", "Material", "Batch", "PhysicalInventoryStockType", "SalesOrder", "SalesOrderItem", "Supplier", "Customer", "WBSElement", "LastChangeDate", "CountedByUser", "PhysicalInventoryLastCountDate", "AdjustmentPostingMadeByUser", "PostingDate", "PhysicalInventoryItemIsCounted", "PhysInvtryDifferenceIsPosted", "PhysInvtryItemIsRecounted", "PhysInvtryItemIsDeleted", "IsHandledInAltvUnitOfMsr", "CycleCountType", "IsValueOnlyMaterial", "PhysInventoryReferenceNumber", "MaterialDocument", "MaterialDocumentYear", "MaterialDocumentItem", "PhysInvtryRecountDocument", "PhysicalInventoryItemIsZero", "ReasonForPhysInvtryDifference", "MaterialBaseUnit", "BookQtyBfrCountInMatlBaseUnit", "Quantity", "UnitOfEntry", "QuantityInUnitOfEntry", "Currency", "LastChangeDateTime"}
	sapPhysicalInventoryDocumentItemDatumColumnsWithDefault    = []string{}
	sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns     = []string{"FiscalYear", "PhysicalInventoryDocument", "PhysicalInventoryDocumentItem"}
	sapPhysicalInventoryDocumentItemDatumGeneratedColumns      = []string{}
)

type (
	// SapPhysicalInventoryDocumentItemDatumSlice is an alias for a slice of pointers to SapPhysicalInventoryDocumentItemDatum.
	// This should almost always be used instead of []SapPhysicalInventoryDocumentItemDatum.
	SapPhysicalInventoryDocumentItemDatumSlice []*SapPhysicalInventoryDocumentItemDatum
	// SapPhysicalInventoryDocumentItemDatumHook is the signature for custom SapPhysicalInventoryDocumentItemDatum hook methods
	SapPhysicalInventoryDocumentItemDatumHook func(context.Context, boil.ContextExecutor, *SapPhysicalInventoryDocumentItemDatum) error

	sapPhysicalInventoryDocumentItemDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapPhysicalInventoryDocumentItemDatumType                 = reflect.TypeOf(&SapPhysicalInventoryDocumentItemDatum{})
	sapPhysicalInventoryDocumentItemDatumMapping              = queries.MakeStructMapping(sapPhysicalInventoryDocumentItemDatumType)
	sapPhysicalInventoryDocumentItemDatumPrimaryKeyMapping, _ = queries.BindMapping(sapPhysicalInventoryDocumentItemDatumType, sapPhysicalInventoryDocumentItemDatumMapping, sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns)
	sapPhysicalInventoryDocumentItemDatumInsertCacheMut       sync.RWMutex
	sapPhysicalInventoryDocumentItemDatumInsertCache          = make(map[string]insertCache)
	sapPhysicalInventoryDocumentItemDatumUpdateCacheMut       sync.RWMutex
	sapPhysicalInventoryDocumentItemDatumUpdateCache          = make(map[string]updateCache)
	sapPhysicalInventoryDocumentItemDatumUpsertCacheMut       sync.RWMutex
	sapPhysicalInventoryDocumentItemDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapPhysicalInventoryDocumentItemDatumAfterSelectHooks []SapPhysicalInventoryDocumentItemDatumHook

var sapPhysicalInventoryDocumentItemDatumBeforeInsertHooks []SapPhysicalInventoryDocumentItemDatumHook
var sapPhysicalInventoryDocumentItemDatumAfterInsertHooks []SapPhysicalInventoryDocumentItemDatumHook

var sapPhysicalInventoryDocumentItemDatumBeforeUpdateHooks []SapPhysicalInventoryDocumentItemDatumHook
var sapPhysicalInventoryDocumentItemDatumAfterUpdateHooks []SapPhysicalInventoryDocumentItemDatumHook

var sapPhysicalInventoryDocumentItemDatumBeforeDeleteHooks []SapPhysicalInventoryDocumentItemDatumHook
var sapPhysicalInventoryDocumentItemDatumAfterDeleteHooks []SapPhysicalInventoryDocumentItemDatumHook

var sapPhysicalInventoryDocumentItemDatumBeforeUpsertHooks []SapPhysicalInventoryDocumentItemDatumHook
var sapPhysicalInventoryDocumentItemDatumAfterUpsertHooks []SapPhysicalInventoryDocumentItemDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapPhysicalInventoryDocumentItemDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPhysicalInventoryDocumentItemDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapPhysicalInventoryDocumentItemDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPhysicalInventoryDocumentItemDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapPhysicalInventoryDocumentItemDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPhysicalInventoryDocumentItemDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapPhysicalInventoryDocumentItemDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPhysicalInventoryDocumentItemDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapPhysicalInventoryDocumentItemDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPhysicalInventoryDocumentItemDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapPhysicalInventoryDocumentItemDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPhysicalInventoryDocumentItemDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapPhysicalInventoryDocumentItemDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPhysicalInventoryDocumentItemDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapPhysicalInventoryDocumentItemDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPhysicalInventoryDocumentItemDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapPhysicalInventoryDocumentItemDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPhysicalInventoryDocumentItemDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapPhysicalInventoryDocumentItemDatumHook registers your hook function for all future operations.
func AddSapPhysicalInventoryDocumentItemDatumHook(hookPoint boil.HookPoint, sapPhysicalInventoryDocumentItemDatumHook SapPhysicalInventoryDocumentItemDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapPhysicalInventoryDocumentItemDatumAfterSelectHooks = append(sapPhysicalInventoryDocumentItemDatumAfterSelectHooks, sapPhysicalInventoryDocumentItemDatumHook)
	case boil.BeforeInsertHook:
		sapPhysicalInventoryDocumentItemDatumBeforeInsertHooks = append(sapPhysicalInventoryDocumentItemDatumBeforeInsertHooks, sapPhysicalInventoryDocumentItemDatumHook)
	case boil.AfterInsertHook:
		sapPhysicalInventoryDocumentItemDatumAfterInsertHooks = append(sapPhysicalInventoryDocumentItemDatumAfterInsertHooks, sapPhysicalInventoryDocumentItemDatumHook)
	case boil.BeforeUpdateHook:
		sapPhysicalInventoryDocumentItemDatumBeforeUpdateHooks = append(sapPhysicalInventoryDocumentItemDatumBeforeUpdateHooks, sapPhysicalInventoryDocumentItemDatumHook)
	case boil.AfterUpdateHook:
		sapPhysicalInventoryDocumentItemDatumAfterUpdateHooks = append(sapPhysicalInventoryDocumentItemDatumAfterUpdateHooks, sapPhysicalInventoryDocumentItemDatumHook)
	case boil.BeforeDeleteHook:
		sapPhysicalInventoryDocumentItemDatumBeforeDeleteHooks = append(sapPhysicalInventoryDocumentItemDatumBeforeDeleteHooks, sapPhysicalInventoryDocumentItemDatumHook)
	case boil.AfterDeleteHook:
		sapPhysicalInventoryDocumentItemDatumAfterDeleteHooks = append(sapPhysicalInventoryDocumentItemDatumAfterDeleteHooks, sapPhysicalInventoryDocumentItemDatumHook)
	case boil.BeforeUpsertHook:
		sapPhysicalInventoryDocumentItemDatumBeforeUpsertHooks = append(sapPhysicalInventoryDocumentItemDatumBeforeUpsertHooks, sapPhysicalInventoryDocumentItemDatumHook)
	case boil.AfterUpsertHook:
		sapPhysicalInventoryDocumentItemDatumAfterUpsertHooks = append(sapPhysicalInventoryDocumentItemDatumAfterUpsertHooks, sapPhysicalInventoryDocumentItemDatumHook)
	}
}

// One returns a single sapPhysicalInventoryDocumentItemDatum record from the query.
func (q sapPhysicalInventoryDocumentItemDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapPhysicalInventoryDocumentItemDatum, error) {
	o := &SapPhysicalInventoryDocumentItemDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_physical_inventory_document_item_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapPhysicalInventoryDocumentItemDatum records from the query.
func (q sapPhysicalInventoryDocumentItemDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapPhysicalInventoryDocumentItemDatumSlice, error) {
	var o []*SapPhysicalInventoryDocumentItemDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapPhysicalInventoryDocumentItemDatum slice")
	}

	if len(sapPhysicalInventoryDocumentItemDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapPhysicalInventoryDocumentItemDatum records in the query.
func (q sapPhysicalInventoryDocumentItemDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_physical_inventory_document_item_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapPhysicalInventoryDocumentItemDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_physical_inventory_document_item_data exists")
	}

	return count > 0, nil
}

// SapPhysicalInventoryDocumentItemData retrieves all the records using an executor.
func SapPhysicalInventoryDocumentItemData(mods ...qm.QueryMod) sapPhysicalInventoryDocumentItemDatumQuery {
	mods = append(mods, qm.From("`sap_physical_inventory_document_item_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`sap_physical_inventory_document_item_data`.*"})
	}

	return sapPhysicalInventoryDocumentItemDatumQuery{q}
}

// FindSapPhysicalInventoryDocumentItemDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapPhysicalInventoryDocumentItemDatum(ctx context.Context, exec boil.ContextExecutor, fiscalYear string, physicalInventoryDocument string, physicalInventoryDocumentItem string, selectCols ...string) (*SapPhysicalInventoryDocumentItemDatum, error) {
	sapPhysicalInventoryDocumentItemDatumObj := &SapPhysicalInventoryDocumentItemDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_physical_inventory_document_item_data` where `FiscalYear`=? AND `PhysicalInventoryDocument`=? AND `PhysicalInventoryDocumentItem`=?", sel,
	)

	q := queries.Raw(query, fiscalYear, physicalInventoryDocument, physicalInventoryDocumentItem)

	err := q.Bind(ctx, exec, sapPhysicalInventoryDocumentItemDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_physical_inventory_document_item_data")
	}

	if err = sapPhysicalInventoryDocumentItemDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapPhysicalInventoryDocumentItemDatumObj, err
	}

	return sapPhysicalInventoryDocumentItemDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapPhysicalInventoryDocumentItemDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_physical_inventory_document_item_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapPhysicalInventoryDocumentItemDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapPhysicalInventoryDocumentItemDatumInsertCacheMut.RLock()
	cache, cached := sapPhysicalInventoryDocumentItemDatumInsertCache[key]
	sapPhysicalInventoryDocumentItemDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapPhysicalInventoryDocumentItemDatumAllColumns,
			sapPhysicalInventoryDocumentItemDatumColumnsWithDefault,
			sapPhysicalInventoryDocumentItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapPhysicalInventoryDocumentItemDatumType, sapPhysicalInventoryDocumentItemDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapPhysicalInventoryDocumentItemDatumType, sapPhysicalInventoryDocumentItemDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_physical_inventory_document_item_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_physical_inventory_document_item_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_physical_inventory_document_item_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_physical_inventory_document_item_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.FiscalYear,
		o.PhysicalInventoryDocument,
		o.PhysicalInventoryDocumentItem,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_physical_inventory_document_item_data")
	}

CacheNoHooks:
	if !cached {
		sapPhysicalInventoryDocumentItemDatumInsertCacheMut.Lock()
		sapPhysicalInventoryDocumentItemDatumInsertCache[key] = cache
		sapPhysicalInventoryDocumentItemDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapPhysicalInventoryDocumentItemDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapPhysicalInventoryDocumentItemDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapPhysicalInventoryDocumentItemDatumUpdateCacheMut.RLock()
	cache, cached := sapPhysicalInventoryDocumentItemDatumUpdateCache[key]
	sapPhysicalInventoryDocumentItemDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapPhysicalInventoryDocumentItemDatumAllColumns,
			sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_physical_inventory_document_item_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_physical_inventory_document_item_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapPhysicalInventoryDocumentItemDatumType, sapPhysicalInventoryDocumentItemDatumMapping, append(wl, sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_physical_inventory_document_item_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_physical_inventory_document_item_data")
	}

	if !cached {
		sapPhysicalInventoryDocumentItemDatumUpdateCacheMut.Lock()
		sapPhysicalInventoryDocumentItemDatumUpdateCache[key] = cache
		sapPhysicalInventoryDocumentItemDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapPhysicalInventoryDocumentItemDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_physical_inventory_document_item_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_physical_inventory_document_item_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapPhysicalInventoryDocumentItemDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapPhysicalInventoryDocumentItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_physical_inventory_document_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapPhysicalInventoryDocumentItemDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapPhysicalInventoryDocumentItemDatum")
	}
	return rowsAff, nil
}

var mySQLSapPhysicalInventoryDocumentItemDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapPhysicalInventoryDocumentItemDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_physical_inventory_document_item_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapPhysicalInventoryDocumentItemDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapPhysicalInventoryDocumentItemDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapPhysicalInventoryDocumentItemDatumUpsertCacheMut.RLock()
	cache, cached := sapPhysicalInventoryDocumentItemDatumUpsertCache[key]
	sapPhysicalInventoryDocumentItemDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapPhysicalInventoryDocumentItemDatumAllColumns,
			sapPhysicalInventoryDocumentItemDatumColumnsWithDefault,
			sapPhysicalInventoryDocumentItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapPhysicalInventoryDocumentItemDatumAllColumns,
			sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_physical_inventory_document_item_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_physical_inventory_document_item_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_physical_inventory_document_item_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapPhysicalInventoryDocumentItemDatumType, sapPhysicalInventoryDocumentItemDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapPhysicalInventoryDocumentItemDatumType, sapPhysicalInventoryDocumentItemDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_physical_inventory_document_item_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapPhysicalInventoryDocumentItemDatumType, sapPhysicalInventoryDocumentItemDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_physical_inventory_document_item_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_physical_inventory_document_item_data")
	}

CacheNoHooks:
	if !cached {
		sapPhysicalInventoryDocumentItemDatumUpsertCacheMut.Lock()
		sapPhysicalInventoryDocumentItemDatumUpsertCache[key] = cache
		sapPhysicalInventoryDocumentItemDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapPhysicalInventoryDocumentItemDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapPhysicalInventoryDocumentItemDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapPhysicalInventoryDocumentItemDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapPhysicalInventoryDocumentItemDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_physical_inventory_document_item_data` WHERE `FiscalYear`=? AND `PhysicalInventoryDocument`=? AND `PhysicalInventoryDocumentItem`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_physical_inventory_document_item_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_physical_inventory_document_item_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapPhysicalInventoryDocumentItemDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapPhysicalInventoryDocumentItemDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_physical_inventory_document_item_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_physical_inventory_document_item_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapPhysicalInventoryDocumentItemDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapPhysicalInventoryDocumentItemDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapPhysicalInventoryDocumentItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_physical_inventory_document_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapPhysicalInventoryDocumentItemDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_physical_inventory_document_item_data")
	}

	if len(sapPhysicalInventoryDocumentItemDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapPhysicalInventoryDocumentItemDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapPhysicalInventoryDocumentItemDatum(ctx, exec, o.FiscalYear, o.PhysicalInventoryDocument, o.PhysicalInventoryDocumentItem)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapPhysicalInventoryDocumentItemDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapPhysicalInventoryDocumentItemDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapPhysicalInventoryDocumentItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_physical_inventory_document_item_data`.* FROM `sap_physical_inventory_document_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapPhysicalInventoryDocumentItemDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapPhysicalInventoryDocumentItemDatumSlice")
	}

	*o = slice

	return nil
}

// SapPhysicalInventoryDocumentItemDatumExists checks if the SapPhysicalInventoryDocumentItemDatum row exists.
func SapPhysicalInventoryDocumentItemDatumExists(ctx context.Context, exec boil.ContextExecutor, fiscalYear string, physicalInventoryDocument string, physicalInventoryDocumentItem string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_physical_inventory_document_item_data` where `FiscalYear`=? AND `PhysicalInventoryDocument`=? AND `PhysicalInventoryDocumentItem`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, fiscalYear, physicalInventoryDocument, physicalInventoryDocumentItem)
	}
	row := exec.QueryRowContext(ctx, sql, fiscalYear, physicalInventoryDocument, physicalInventoryDocumentItem)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_physical_inventory_document_item_data exists")
	}

	return exists, nil
}
