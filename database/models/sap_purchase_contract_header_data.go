// Code generated by SQLBoiler 4.8.4 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapPurchaseContractHeaderDatum is an object representing the database table.
type SapPurchaseContractHeaderDatum struct {
	PurchaseContract               string      `boil:"PurchaseContract" json:"PurchaseContract" toml:"PurchaseContract" yaml:"PurchaseContract"`
	PurchaseContractType           null.String `boil:"PurchaseContractType" json:"PurchaseContractType,omitempty" toml:"PurchaseContractType" yaml:"PurchaseContractType,omitempty"`
	CompanyCode                    null.String `boil:"CompanyCode" json:"CompanyCode,omitempty" toml:"CompanyCode" yaml:"CompanyCode,omitempty"`
	PurchasingDocumentDeletionCode null.String `boil:"PurchasingDocumentDeletionCode" json:"PurchasingDocumentDeletionCode,omitempty" toml:"PurchasingDocumentDeletionCode" yaml:"PurchasingDocumentDeletionCode,omitempty"`
	CreationDate                   null.String `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	Supplier                       null.String `boil:"Supplier" json:"Supplier,omitempty" toml:"Supplier" yaml:"Supplier,omitempty"`
	PurchasingOrganization         null.String `boil:"PurchasingOrganization" json:"PurchasingOrganization,omitempty" toml:"PurchasingOrganization" yaml:"PurchasingOrganization,omitempty"`
	PurchasingGroup                null.String `boil:"PurchasingGroup" json:"PurchasingGroup,omitempty" toml:"PurchasingGroup" yaml:"PurchasingGroup,omitempty"`
	PaymentTerms                   null.String `boil:"PaymentTerms" json:"PaymentTerms,omitempty" toml:"PaymentTerms" yaml:"PaymentTerms,omitempty"`
	NetPaymentDays                 null.String `boil:"NetPaymentDays" json:"NetPaymentDays,omitempty" toml:"NetPaymentDays" yaml:"NetPaymentDays,omitempty"`
	DocumentCurrency               null.String `boil:"DocumentCurrency" json:"DocumentCurrency,omitempty" toml:"DocumentCurrency" yaml:"DocumentCurrency,omitempty"`
	ExchangeRate                   null.String `boil:"ExchangeRate" json:"ExchangeRate,omitempty" toml:"ExchangeRate" yaml:"ExchangeRate,omitempty"`
	ValidityStartDate              null.String `boil:"ValidityStartDate" json:"ValidityStartDate,omitempty" toml:"ValidityStartDate" yaml:"ValidityStartDate,omitempty"`
	ValidityEndDate                null.String `boil:"ValidityEndDate" json:"ValidityEndDate,omitempty" toml:"ValidityEndDate" yaml:"ValidityEndDate,omitempty"`
	SupplierRespSalesPersonName    null.String `boil:"SupplierRespSalesPersonName" json:"SupplierRespSalesPersonName,omitempty" toml:"SupplierRespSalesPersonName" yaml:"SupplierRespSalesPersonName,omitempty"`
	SupplierPhoneNumber            null.String `boil:"SupplierPhoneNumber" json:"SupplierPhoneNumber,omitempty" toml:"SupplierPhoneNumber" yaml:"SupplierPhoneNumber,omitempty"`
	IncotermsClassification        null.String `boil:"IncotermsClassification" json:"IncotermsClassification,omitempty" toml:"IncotermsClassification" yaml:"IncotermsClassification,omitempty"`
	PurchaseContractTargetAmount   null.String `boil:"PurchaseContractTargetAmount" json:"PurchaseContractTargetAmount,omitempty" toml:"PurchaseContractTargetAmount" yaml:"PurchaseContractTargetAmount,omitempty"`
	InvoicingParty                 null.String `boil:"InvoicingParty" json:"InvoicingParty,omitempty" toml:"InvoicingParty" yaml:"InvoicingParty,omitempty"`
	ReleaseCode                    null.String `boil:"ReleaseCode" json:"ReleaseCode,omitempty" toml:"ReleaseCode" yaml:"ReleaseCode,omitempty"`
	LastChangeDateTime             null.String `boil:"LastChangeDateTime" json:"LastChangeDateTime,omitempty" toml:"LastChangeDateTime" yaml:"LastChangeDateTime,omitempty"`
	PurchasingProcessingStatus     null.String `boil:"PurchasingProcessingStatus" json:"PurchasingProcessingStatus,omitempty" toml:"PurchasingProcessingStatus" yaml:"PurchasingProcessingStatus,omitempty"`
	PurchasingProcessingStatusName null.String `boil:"PurchasingProcessingStatusName" json:"PurchasingProcessingStatusName,omitempty" toml:"PurchasingProcessingStatusName" yaml:"PurchasingProcessingStatusName,omitempty"`
	PurgContractIsInPreparation    null.Bool   `boil:"PurgContractIsInPreparation" json:"PurgContractIsInPreparation,omitempty" toml:"PurgContractIsInPreparation" yaml:"PurgContractIsInPreparation,omitempty"`

	R *sapPurchaseContractHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapPurchaseContractHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapPurchaseContractHeaderDatumColumns = struct {
	PurchaseContract               string
	PurchaseContractType           string
	CompanyCode                    string
	PurchasingDocumentDeletionCode string
	CreationDate                   string
	Supplier                       string
	PurchasingOrganization         string
	PurchasingGroup                string
	PaymentTerms                   string
	NetPaymentDays                 string
	DocumentCurrency               string
	ExchangeRate                   string
	ValidityStartDate              string
	ValidityEndDate                string
	SupplierRespSalesPersonName    string
	SupplierPhoneNumber            string
	IncotermsClassification        string
	PurchaseContractTargetAmount   string
	InvoicingParty                 string
	ReleaseCode                    string
	LastChangeDateTime             string
	PurchasingProcessingStatus     string
	PurchasingProcessingStatusName string
	PurgContractIsInPreparation    string
}{
	PurchaseContract:               "PurchaseContract",
	PurchaseContractType:           "PurchaseContractType",
	CompanyCode:                    "CompanyCode",
	PurchasingDocumentDeletionCode: "PurchasingDocumentDeletionCode",
	CreationDate:                   "CreationDate",
	Supplier:                       "Supplier",
	PurchasingOrganization:         "PurchasingOrganization",
	PurchasingGroup:                "PurchasingGroup",
	PaymentTerms:                   "PaymentTerms",
	NetPaymentDays:                 "NetPaymentDays",
	DocumentCurrency:               "DocumentCurrency",
	ExchangeRate:                   "ExchangeRate",
	ValidityStartDate:              "ValidityStartDate",
	ValidityEndDate:                "ValidityEndDate",
	SupplierRespSalesPersonName:    "SupplierRespSalesPersonName",
	SupplierPhoneNumber:            "SupplierPhoneNumber",
	IncotermsClassification:        "IncotermsClassification",
	PurchaseContractTargetAmount:   "PurchaseContractTargetAmount",
	InvoicingParty:                 "InvoicingParty",
	ReleaseCode:                    "ReleaseCode",
	LastChangeDateTime:             "LastChangeDateTime",
	PurchasingProcessingStatus:     "PurchasingProcessingStatus",
	PurchasingProcessingStatusName: "PurchasingProcessingStatusName",
	PurgContractIsInPreparation:    "PurgContractIsInPreparation",
}

var SapPurchaseContractHeaderDatumTableColumns = struct {
	PurchaseContract               string
	PurchaseContractType           string
	CompanyCode                    string
	PurchasingDocumentDeletionCode string
	CreationDate                   string
	Supplier                       string
	PurchasingOrganization         string
	PurchasingGroup                string
	PaymentTerms                   string
	NetPaymentDays                 string
	DocumentCurrency               string
	ExchangeRate                   string
	ValidityStartDate              string
	ValidityEndDate                string
	SupplierRespSalesPersonName    string
	SupplierPhoneNumber            string
	IncotermsClassification        string
	PurchaseContractTargetAmount   string
	InvoicingParty                 string
	ReleaseCode                    string
	LastChangeDateTime             string
	PurchasingProcessingStatus     string
	PurchasingProcessingStatusName string
	PurgContractIsInPreparation    string
}{
	PurchaseContract:               "sap_purchase_contract_header_data.PurchaseContract",
	PurchaseContractType:           "sap_purchase_contract_header_data.PurchaseContractType",
	CompanyCode:                    "sap_purchase_contract_header_data.CompanyCode",
	PurchasingDocumentDeletionCode: "sap_purchase_contract_header_data.PurchasingDocumentDeletionCode",
	CreationDate:                   "sap_purchase_contract_header_data.CreationDate",
	Supplier:                       "sap_purchase_contract_header_data.Supplier",
	PurchasingOrganization:         "sap_purchase_contract_header_data.PurchasingOrganization",
	PurchasingGroup:                "sap_purchase_contract_header_data.PurchasingGroup",
	PaymentTerms:                   "sap_purchase_contract_header_data.PaymentTerms",
	NetPaymentDays:                 "sap_purchase_contract_header_data.NetPaymentDays",
	DocumentCurrency:               "sap_purchase_contract_header_data.DocumentCurrency",
	ExchangeRate:                   "sap_purchase_contract_header_data.ExchangeRate",
	ValidityStartDate:              "sap_purchase_contract_header_data.ValidityStartDate",
	ValidityEndDate:                "sap_purchase_contract_header_data.ValidityEndDate",
	SupplierRespSalesPersonName:    "sap_purchase_contract_header_data.SupplierRespSalesPersonName",
	SupplierPhoneNumber:            "sap_purchase_contract_header_data.SupplierPhoneNumber",
	IncotermsClassification:        "sap_purchase_contract_header_data.IncotermsClassification",
	PurchaseContractTargetAmount:   "sap_purchase_contract_header_data.PurchaseContractTargetAmount",
	InvoicingParty:                 "sap_purchase_contract_header_data.InvoicingParty",
	ReleaseCode:                    "sap_purchase_contract_header_data.ReleaseCode",
	LastChangeDateTime:             "sap_purchase_contract_header_data.LastChangeDateTime",
	PurchasingProcessingStatus:     "sap_purchase_contract_header_data.PurchasingProcessingStatus",
	PurchasingProcessingStatusName: "sap_purchase_contract_header_data.PurchasingProcessingStatusName",
	PurgContractIsInPreparation:    "sap_purchase_contract_header_data.PurgContractIsInPreparation",
}

// Generated where

var SapPurchaseContractHeaderDatumWhere = struct {
	PurchaseContract               whereHelperstring
	PurchaseContractType           whereHelpernull_String
	CompanyCode                    whereHelpernull_String
	PurchasingDocumentDeletionCode whereHelpernull_String
	CreationDate                   whereHelpernull_String
	Supplier                       whereHelpernull_String
	PurchasingOrganization         whereHelpernull_String
	PurchasingGroup                whereHelpernull_String
	PaymentTerms                   whereHelpernull_String
	NetPaymentDays                 whereHelpernull_String
	DocumentCurrency               whereHelpernull_String
	ExchangeRate                   whereHelpernull_String
	ValidityStartDate              whereHelpernull_String
	ValidityEndDate                whereHelpernull_String
	SupplierRespSalesPersonName    whereHelpernull_String
	SupplierPhoneNumber            whereHelpernull_String
	IncotermsClassification        whereHelpernull_String
	PurchaseContractTargetAmount   whereHelpernull_String
	InvoicingParty                 whereHelpernull_String
	ReleaseCode                    whereHelpernull_String
	LastChangeDateTime             whereHelpernull_String
	PurchasingProcessingStatus     whereHelpernull_String
	PurchasingProcessingStatusName whereHelpernull_String
	PurgContractIsInPreparation    whereHelpernull_Bool
}{
	PurchaseContract:               whereHelperstring{field: "`sap_purchase_contract_header_data`.`PurchaseContract`"},
	PurchaseContractType:           whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`PurchaseContractType`"},
	CompanyCode:                    whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`CompanyCode`"},
	PurchasingDocumentDeletionCode: whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`PurchasingDocumentDeletionCode`"},
	CreationDate:                   whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`CreationDate`"},
	Supplier:                       whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`Supplier`"},
	PurchasingOrganization:         whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`PurchasingOrganization`"},
	PurchasingGroup:                whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`PurchasingGroup`"},
	PaymentTerms:                   whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`PaymentTerms`"},
	NetPaymentDays:                 whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`NetPaymentDays`"},
	DocumentCurrency:               whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`DocumentCurrency`"},
	ExchangeRate:                   whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`ExchangeRate`"},
	ValidityStartDate:              whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`ValidityStartDate`"},
	ValidityEndDate:                whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`ValidityEndDate`"},
	SupplierRespSalesPersonName:    whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`SupplierRespSalesPersonName`"},
	SupplierPhoneNumber:            whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`SupplierPhoneNumber`"},
	IncotermsClassification:        whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`IncotermsClassification`"},
	PurchaseContractTargetAmount:   whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`PurchaseContractTargetAmount`"},
	InvoicingParty:                 whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`InvoicingParty`"},
	ReleaseCode:                    whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`ReleaseCode`"},
	LastChangeDateTime:             whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`LastChangeDateTime`"},
	PurchasingProcessingStatus:     whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`PurchasingProcessingStatus`"},
	PurchasingProcessingStatusName: whereHelpernull_String{field: "`sap_purchase_contract_header_data`.`PurchasingProcessingStatusName`"},
	PurgContractIsInPreparation:    whereHelpernull_Bool{field: "`sap_purchase_contract_header_data`.`PurgContractIsInPreparation`"},
}

// SapPurchaseContractHeaderDatumRels is where relationship names are stored.
var SapPurchaseContractHeaderDatumRels = struct {
	PurchaseContractSapPurchaseContractAddressData       string
	PurchaseContractSapPurchaseContractItemConditionData string
	PurchaseContractSapPurchaseContractItemData          string
}{
	PurchaseContractSapPurchaseContractAddressData:       "PurchaseContractSapPurchaseContractAddressData",
	PurchaseContractSapPurchaseContractItemConditionData: "PurchaseContractSapPurchaseContractItemConditionData",
	PurchaseContractSapPurchaseContractItemData:          "PurchaseContractSapPurchaseContractItemData",
}

// sapPurchaseContractHeaderDatumR is where relationships are stored.
type sapPurchaseContractHeaderDatumR struct {
	PurchaseContractSapPurchaseContractAddressData       SapPurchaseContractAddressDatumSlice       `boil:"PurchaseContractSapPurchaseContractAddressData" json:"PurchaseContractSapPurchaseContractAddressData" toml:"PurchaseContractSapPurchaseContractAddressData" yaml:"PurchaseContractSapPurchaseContractAddressData"`
	PurchaseContractSapPurchaseContractItemConditionData SapPurchaseContractItemConditionDatumSlice `boil:"PurchaseContractSapPurchaseContractItemConditionData" json:"PurchaseContractSapPurchaseContractItemConditionData" toml:"PurchaseContractSapPurchaseContractItemConditionData" yaml:"PurchaseContractSapPurchaseContractItemConditionData"`
	PurchaseContractSapPurchaseContractItemData          SapPurchaseContractItemDatumSlice          `boil:"PurchaseContractSapPurchaseContractItemData" json:"PurchaseContractSapPurchaseContractItemData" toml:"PurchaseContractSapPurchaseContractItemData" yaml:"PurchaseContractSapPurchaseContractItemData"`
}

// NewStruct creates a new relationship struct
func (*sapPurchaseContractHeaderDatumR) NewStruct() *sapPurchaseContractHeaderDatumR {
	return &sapPurchaseContractHeaderDatumR{}
}

// sapPurchaseContractHeaderDatumL is where Load methods for each relationship are stored.
type sapPurchaseContractHeaderDatumL struct{}

var (
	sapPurchaseContractHeaderDatumAllColumns            = []string{"PurchaseContract", "PurchaseContractType", "CompanyCode", "PurchasingDocumentDeletionCode", "CreationDate", "Supplier", "PurchasingOrganization", "PurchasingGroup", "PaymentTerms", "NetPaymentDays", "DocumentCurrency", "ExchangeRate", "ValidityStartDate", "ValidityEndDate", "SupplierRespSalesPersonName", "SupplierPhoneNumber", "IncotermsClassification", "PurchaseContractTargetAmount", "InvoicingParty", "ReleaseCode", "LastChangeDateTime", "PurchasingProcessingStatus", "PurchasingProcessingStatusName", "PurgContractIsInPreparation"}
	sapPurchaseContractHeaderDatumColumnsWithoutDefault = []string{"PurchaseContract", "PurchaseContractType", "CompanyCode", "PurchasingDocumentDeletionCode", "CreationDate", "Supplier", "PurchasingOrganization", "PurchasingGroup", "PaymentTerms", "NetPaymentDays", "DocumentCurrency", "ExchangeRate", "ValidityStartDate", "ValidityEndDate", "SupplierRespSalesPersonName", "SupplierPhoneNumber", "IncotermsClassification", "PurchaseContractTargetAmount", "InvoicingParty", "ReleaseCode", "LastChangeDateTime", "PurchasingProcessingStatus", "PurchasingProcessingStatusName", "PurgContractIsInPreparation"}
	sapPurchaseContractHeaderDatumColumnsWithDefault    = []string{}
	sapPurchaseContractHeaderDatumPrimaryKeyColumns     = []string{"PurchaseContract"}
	sapPurchaseContractHeaderDatumGeneratedColumns      = []string{}
)

type (
	// SapPurchaseContractHeaderDatumSlice is an alias for a slice of pointers to SapPurchaseContractHeaderDatum.
	// This should almost always be used instead of []SapPurchaseContractHeaderDatum.
	SapPurchaseContractHeaderDatumSlice []*SapPurchaseContractHeaderDatum
	// SapPurchaseContractHeaderDatumHook is the signature for custom SapPurchaseContractHeaderDatum hook methods
	SapPurchaseContractHeaderDatumHook func(context.Context, boil.ContextExecutor, *SapPurchaseContractHeaderDatum) error

	sapPurchaseContractHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapPurchaseContractHeaderDatumType                 = reflect.TypeOf(&SapPurchaseContractHeaderDatum{})
	sapPurchaseContractHeaderDatumMapping              = queries.MakeStructMapping(sapPurchaseContractHeaderDatumType)
	sapPurchaseContractHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(sapPurchaseContractHeaderDatumType, sapPurchaseContractHeaderDatumMapping, sapPurchaseContractHeaderDatumPrimaryKeyColumns)
	sapPurchaseContractHeaderDatumInsertCacheMut       sync.RWMutex
	sapPurchaseContractHeaderDatumInsertCache          = make(map[string]insertCache)
	sapPurchaseContractHeaderDatumUpdateCacheMut       sync.RWMutex
	sapPurchaseContractHeaderDatumUpdateCache          = make(map[string]updateCache)
	sapPurchaseContractHeaderDatumUpsertCacheMut       sync.RWMutex
	sapPurchaseContractHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapPurchaseContractHeaderDatumAfterSelectHooks []SapPurchaseContractHeaderDatumHook

var sapPurchaseContractHeaderDatumBeforeInsertHooks []SapPurchaseContractHeaderDatumHook
var sapPurchaseContractHeaderDatumAfterInsertHooks []SapPurchaseContractHeaderDatumHook

var sapPurchaseContractHeaderDatumBeforeUpdateHooks []SapPurchaseContractHeaderDatumHook
var sapPurchaseContractHeaderDatumAfterUpdateHooks []SapPurchaseContractHeaderDatumHook

var sapPurchaseContractHeaderDatumBeforeDeleteHooks []SapPurchaseContractHeaderDatumHook
var sapPurchaseContractHeaderDatumAfterDeleteHooks []SapPurchaseContractHeaderDatumHook

var sapPurchaseContractHeaderDatumBeforeUpsertHooks []SapPurchaseContractHeaderDatumHook
var sapPurchaseContractHeaderDatumAfterUpsertHooks []SapPurchaseContractHeaderDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapPurchaseContractHeaderDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchaseContractHeaderDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapPurchaseContractHeaderDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchaseContractHeaderDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapPurchaseContractHeaderDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchaseContractHeaderDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapPurchaseContractHeaderDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchaseContractHeaderDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapPurchaseContractHeaderDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchaseContractHeaderDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapPurchaseContractHeaderDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchaseContractHeaderDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapPurchaseContractHeaderDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchaseContractHeaderDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapPurchaseContractHeaderDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchaseContractHeaderDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapPurchaseContractHeaderDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchaseContractHeaderDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapPurchaseContractHeaderDatumHook registers your hook function for all future operations.
func AddSapPurchaseContractHeaderDatumHook(hookPoint boil.HookPoint, sapPurchaseContractHeaderDatumHook SapPurchaseContractHeaderDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapPurchaseContractHeaderDatumAfterSelectHooks = append(sapPurchaseContractHeaderDatumAfterSelectHooks, sapPurchaseContractHeaderDatumHook)
	case boil.BeforeInsertHook:
		sapPurchaseContractHeaderDatumBeforeInsertHooks = append(sapPurchaseContractHeaderDatumBeforeInsertHooks, sapPurchaseContractHeaderDatumHook)
	case boil.AfterInsertHook:
		sapPurchaseContractHeaderDatumAfterInsertHooks = append(sapPurchaseContractHeaderDatumAfterInsertHooks, sapPurchaseContractHeaderDatumHook)
	case boil.BeforeUpdateHook:
		sapPurchaseContractHeaderDatumBeforeUpdateHooks = append(sapPurchaseContractHeaderDatumBeforeUpdateHooks, sapPurchaseContractHeaderDatumHook)
	case boil.AfterUpdateHook:
		sapPurchaseContractHeaderDatumAfterUpdateHooks = append(sapPurchaseContractHeaderDatumAfterUpdateHooks, sapPurchaseContractHeaderDatumHook)
	case boil.BeforeDeleteHook:
		sapPurchaseContractHeaderDatumBeforeDeleteHooks = append(sapPurchaseContractHeaderDatumBeforeDeleteHooks, sapPurchaseContractHeaderDatumHook)
	case boil.AfterDeleteHook:
		sapPurchaseContractHeaderDatumAfterDeleteHooks = append(sapPurchaseContractHeaderDatumAfterDeleteHooks, sapPurchaseContractHeaderDatumHook)
	case boil.BeforeUpsertHook:
		sapPurchaseContractHeaderDatumBeforeUpsertHooks = append(sapPurchaseContractHeaderDatumBeforeUpsertHooks, sapPurchaseContractHeaderDatumHook)
	case boil.AfterUpsertHook:
		sapPurchaseContractHeaderDatumAfterUpsertHooks = append(sapPurchaseContractHeaderDatumAfterUpsertHooks, sapPurchaseContractHeaderDatumHook)
	}
}

// One returns a single sapPurchaseContractHeaderDatum record from the query.
func (q sapPurchaseContractHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapPurchaseContractHeaderDatum, error) {
	o := &SapPurchaseContractHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_purchase_contract_header_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapPurchaseContractHeaderDatum records from the query.
func (q sapPurchaseContractHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapPurchaseContractHeaderDatumSlice, error) {
	var o []*SapPurchaseContractHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapPurchaseContractHeaderDatum slice")
	}

	if len(sapPurchaseContractHeaderDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapPurchaseContractHeaderDatum records in the query.
func (q sapPurchaseContractHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_purchase_contract_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapPurchaseContractHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_purchase_contract_header_data exists")
	}

	return count > 0, nil
}

// PurchaseContractSapPurchaseContractAddressData retrieves all the sap_purchase_contract_address_datum's SapPurchaseContractAddressData with an executor via PurchaseContract column.
func (o *SapPurchaseContractHeaderDatum) PurchaseContractSapPurchaseContractAddressData(mods ...qm.QueryMod) sapPurchaseContractAddressDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_purchase_contract_address_data`.`PurchaseContract`=?", o.PurchaseContract),
	)

	query := SapPurchaseContractAddressData(queryMods...)
	queries.SetFrom(query.Query, "`sap_purchase_contract_address_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_purchase_contract_address_data`.*"})
	}

	return query
}

// PurchaseContractSapPurchaseContractItemConditionData retrieves all the sap_purchase_contract_item_condition_datum's SapPurchaseContractItemConditionData with an executor via PurchaseContract column.
func (o *SapPurchaseContractHeaderDatum) PurchaseContractSapPurchaseContractItemConditionData(mods ...qm.QueryMod) sapPurchaseContractItemConditionDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_purchase_contract_item_condition_data`.`PurchaseContract`=?", o.PurchaseContract),
	)

	query := SapPurchaseContractItemConditionData(queryMods...)
	queries.SetFrom(query.Query, "`sap_purchase_contract_item_condition_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_purchase_contract_item_condition_data`.*"})
	}

	return query
}

// PurchaseContractSapPurchaseContractItemData retrieves all the sap_purchase_contract_item_datum's SapPurchaseContractItemData with an executor via PurchaseContract column.
func (o *SapPurchaseContractHeaderDatum) PurchaseContractSapPurchaseContractItemData(mods ...qm.QueryMod) sapPurchaseContractItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_purchase_contract_item_data`.`PurchaseContract`=?", o.PurchaseContract),
	)

	query := SapPurchaseContractItemData(queryMods...)
	queries.SetFrom(query.Query, "`sap_purchase_contract_item_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_purchase_contract_item_data`.*"})
	}

	return query
}

// LoadPurchaseContractSapPurchaseContractAddressData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapPurchaseContractHeaderDatumL) LoadPurchaseContractSapPurchaseContractAddressData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapPurchaseContractHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapPurchaseContractHeaderDatum
	var object *SapPurchaseContractHeaderDatum

	if singular {
		object = maybeSapPurchaseContractHeaderDatum.(*SapPurchaseContractHeaderDatum)
	} else {
		slice = *maybeSapPurchaseContractHeaderDatum.(*[]*SapPurchaseContractHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapPurchaseContractHeaderDatumR{}
		}
		args = append(args, object.PurchaseContract)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapPurchaseContractHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.PurchaseContract {
					continue Outer
				}
			}

			args = append(args, obj.PurchaseContract)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_purchase_contract_address_data`),
		qm.WhereIn(`sap_purchase_contract_address_data.PurchaseContract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_purchase_contract_address_data")
	}

	var resultSlice []*SapPurchaseContractAddressDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_purchase_contract_address_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_purchase_contract_address_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_purchase_contract_address_data")
	}

	if len(sapPurchaseContractAddressDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PurchaseContractSapPurchaseContractAddressData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapPurchaseContractAddressDatumR{}
			}
			foreign.R.PurchaseContractSapPurchaseContractHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PurchaseContract == foreign.PurchaseContract {
				local.R.PurchaseContractSapPurchaseContractAddressData = append(local.R.PurchaseContractSapPurchaseContractAddressData, foreign)
				if foreign.R == nil {
					foreign.R = &sapPurchaseContractAddressDatumR{}
				}
				foreign.R.PurchaseContractSapPurchaseContractHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// LoadPurchaseContractSapPurchaseContractItemConditionData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapPurchaseContractHeaderDatumL) LoadPurchaseContractSapPurchaseContractItemConditionData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapPurchaseContractHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapPurchaseContractHeaderDatum
	var object *SapPurchaseContractHeaderDatum

	if singular {
		object = maybeSapPurchaseContractHeaderDatum.(*SapPurchaseContractHeaderDatum)
	} else {
		slice = *maybeSapPurchaseContractHeaderDatum.(*[]*SapPurchaseContractHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapPurchaseContractHeaderDatumR{}
		}
		args = append(args, object.PurchaseContract)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapPurchaseContractHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.PurchaseContract {
					continue Outer
				}
			}

			args = append(args, obj.PurchaseContract)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_purchase_contract_item_condition_data`),
		qm.WhereIn(`sap_purchase_contract_item_condition_data.PurchaseContract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_purchase_contract_item_condition_data")
	}

	var resultSlice []*SapPurchaseContractItemConditionDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_purchase_contract_item_condition_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_purchase_contract_item_condition_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_purchase_contract_item_condition_data")
	}

	if len(sapPurchaseContractItemConditionDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PurchaseContractSapPurchaseContractItemConditionData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapPurchaseContractItemConditionDatumR{}
			}
			foreign.R.PurchaseContractSapPurchaseContractHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PurchaseContract == foreign.PurchaseContract {
				local.R.PurchaseContractSapPurchaseContractItemConditionData = append(local.R.PurchaseContractSapPurchaseContractItemConditionData, foreign)
				if foreign.R == nil {
					foreign.R = &sapPurchaseContractItemConditionDatumR{}
				}
				foreign.R.PurchaseContractSapPurchaseContractHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// LoadPurchaseContractSapPurchaseContractItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapPurchaseContractHeaderDatumL) LoadPurchaseContractSapPurchaseContractItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapPurchaseContractHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapPurchaseContractHeaderDatum
	var object *SapPurchaseContractHeaderDatum

	if singular {
		object = maybeSapPurchaseContractHeaderDatum.(*SapPurchaseContractHeaderDatum)
	} else {
		slice = *maybeSapPurchaseContractHeaderDatum.(*[]*SapPurchaseContractHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapPurchaseContractHeaderDatumR{}
		}
		args = append(args, object.PurchaseContract)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapPurchaseContractHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.PurchaseContract {
					continue Outer
				}
			}

			args = append(args, obj.PurchaseContract)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_purchase_contract_item_data`),
		qm.WhereIn(`sap_purchase_contract_item_data.PurchaseContract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_purchase_contract_item_data")
	}

	var resultSlice []*SapPurchaseContractItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_purchase_contract_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_purchase_contract_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_purchase_contract_item_data")
	}

	if len(sapPurchaseContractItemDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PurchaseContractSapPurchaseContractItemData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapPurchaseContractItemDatumR{}
			}
			foreign.R.PurchaseContractSapPurchaseContractHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.PurchaseContract == foreign.PurchaseContract {
				local.R.PurchaseContractSapPurchaseContractItemData = append(local.R.PurchaseContractSapPurchaseContractItemData, foreign)
				if foreign.R == nil {
					foreign.R = &sapPurchaseContractItemDatumR{}
				}
				foreign.R.PurchaseContractSapPurchaseContractHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// AddPurchaseContractSapPurchaseContractAddressData adds the given related objects to the existing relationships
// of the sap_purchase_contract_header_datum, optionally inserting them as new records.
// Appends related to o.R.PurchaseContractSapPurchaseContractAddressData.
// Sets related.R.PurchaseContractSapPurchaseContractHeaderDatum appropriately.
func (o *SapPurchaseContractHeaderDatum) AddPurchaseContractSapPurchaseContractAddressData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapPurchaseContractAddressDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PurchaseContract = o.PurchaseContract
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_purchase_contract_address_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"PurchaseContract"}),
				strmangle.WhereClause("`", "`", 0, sapPurchaseContractAddressDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.PurchaseContract, rel.PurchaseContract, rel.PurchaseContractItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PurchaseContract = o.PurchaseContract
		}
	}

	if o.R == nil {
		o.R = &sapPurchaseContractHeaderDatumR{
			PurchaseContractSapPurchaseContractAddressData: related,
		}
	} else {
		o.R.PurchaseContractSapPurchaseContractAddressData = append(o.R.PurchaseContractSapPurchaseContractAddressData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapPurchaseContractAddressDatumR{
				PurchaseContractSapPurchaseContractHeaderDatum: o,
			}
		} else {
			rel.R.PurchaseContractSapPurchaseContractHeaderDatum = o
		}
	}
	return nil
}

// AddPurchaseContractSapPurchaseContractItemConditionData adds the given related objects to the existing relationships
// of the sap_purchase_contract_header_datum, optionally inserting them as new records.
// Appends related to o.R.PurchaseContractSapPurchaseContractItemConditionData.
// Sets related.R.PurchaseContractSapPurchaseContractHeaderDatum appropriately.
func (o *SapPurchaseContractHeaderDatum) AddPurchaseContractSapPurchaseContractItemConditionData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapPurchaseContractItemConditionDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PurchaseContract = o.PurchaseContract
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_purchase_contract_item_condition_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"PurchaseContract"}),
				strmangle.WhereClause("`", "`", 0, sapPurchaseContractItemConditionDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.PurchaseContract, rel.PurchaseContract, rel.PurchaseContractItem, rel.ConditionValidityEndDate}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PurchaseContract = o.PurchaseContract
		}
	}

	if o.R == nil {
		o.R = &sapPurchaseContractHeaderDatumR{
			PurchaseContractSapPurchaseContractItemConditionData: related,
		}
	} else {
		o.R.PurchaseContractSapPurchaseContractItemConditionData = append(o.R.PurchaseContractSapPurchaseContractItemConditionData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapPurchaseContractItemConditionDatumR{
				PurchaseContractSapPurchaseContractHeaderDatum: o,
			}
		} else {
			rel.R.PurchaseContractSapPurchaseContractHeaderDatum = o
		}
	}
	return nil
}

// AddPurchaseContractSapPurchaseContractItemData adds the given related objects to the existing relationships
// of the sap_purchase_contract_header_datum, optionally inserting them as new records.
// Appends related to o.R.PurchaseContractSapPurchaseContractItemData.
// Sets related.R.PurchaseContractSapPurchaseContractHeaderDatum appropriately.
func (o *SapPurchaseContractHeaderDatum) AddPurchaseContractSapPurchaseContractItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapPurchaseContractItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PurchaseContract = o.PurchaseContract
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_purchase_contract_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"PurchaseContract"}),
				strmangle.WhereClause("`", "`", 0, sapPurchaseContractItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.PurchaseContract, rel.PurchaseContract, rel.PurchaseContractItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PurchaseContract = o.PurchaseContract
		}
	}

	if o.R == nil {
		o.R = &sapPurchaseContractHeaderDatumR{
			PurchaseContractSapPurchaseContractItemData: related,
		}
	} else {
		o.R.PurchaseContractSapPurchaseContractItemData = append(o.R.PurchaseContractSapPurchaseContractItemData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapPurchaseContractItemDatumR{
				PurchaseContractSapPurchaseContractHeaderDatum: o,
			}
		} else {
			rel.R.PurchaseContractSapPurchaseContractHeaderDatum = o
		}
	}
	return nil
}

// SapPurchaseContractHeaderData retrieves all the records using an executor.
func SapPurchaseContractHeaderData(mods ...qm.QueryMod) sapPurchaseContractHeaderDatumQuery {
	mods = append(mods, qm.From("`sap_purchase_contract_header_data`"))
	return sapPurchaseContractHeaderDatumQuery{NewQuery(mods...)}
}

// FindSapPurchaseContractHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapPurchaseContractHeaderDatum(ctx context.Context, exec boil.ContextExecutor, purchaseContract string, selectCols ...string) (*SapPurchaseContractHeaderDatum, error) {
	sapPurchaseContractHeaderDatumObj := &SapPurchaseContractHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_purchase_contract_header_data` where `PurchaseContract`=?", sel,
	)

	q := queries.Raw(query, purchaseContract)

	err := q.Bind(ctx, exec, sapPurchaseContractHeaderDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_purchase_contract_header_data")
	}

	if err = sapPurchaseContractHeaderDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapPurchaseContractHeaderDatumObj, err
	}

	return sapPurchaseContractHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapPurchaseContractHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_purchase_contract_header_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapPurchaseContractHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapPurchaseContractHeaderDatumInsertCacheMut.RLock()
	cache, cached := sapPurchaseContractHeaderDatumInsertCache[key]
	sapPurchaseContractHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapPurchaseContractHeaderDatumAllColumns,
			sapPurchaseContractHeaderDatumColumnsWithDefault,
			sapPurchaseContractHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapPurchaseContractHeaderDatumType, sapPurchaseContractHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapPurchaseContractHeaderDatumType, sapPurchaseContractHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_purchase_contract_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_purchase_contract_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_purchase_contract_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapPurchaseContractHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_purchase_contract_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PurchaseContract,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_purchase_contract_header_data")
	}

CacheNoHooks:
	if !cached {
		sapPurchaseContractHeaderDatumInsertCacheMut.Lock()
		sapPurchaseContractHeaderDatumInsertCache[key] = cache
		sapPurchaseContractHeaderDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapPurchaseContractHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapPurchaseContractHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapPurchaseContractHeaderDatumUpdateCacheMut.RLock()
	cache, cached := sapPurchaseContractHeaderDatumUpdateCache[key]
	sapPurchaseContractHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapPurchaseContractHeaderDatumAllColumns,
			sapPurchaseContractHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_purchase_contract_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_purchase_contract_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapPurchaseContractHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapPurchaseContractHeaderDatumType, sapPurchaseContractHeaderDatumMapping, append(wl, sapPurchaseContractHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_purchase_contract_header_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_purchase_contract_header_data")
	}

	if !cached {
		sapPurchaseContractHeaderDatumUpdateCacheMut.Lock()
		sapPurchaseContractHeaderDatumUpdateCache[key] = cache
		sapPurchaseContractHeaderDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapPurchaseContractHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_purchase_contract_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_purchase_contract_header_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapPurchaseContractHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapPurchaseContractHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_purchase_contract_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapPurchaseContractHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapPurchaseContractHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapPurchaseContractHeaderDatum")
	}
	return rowsAff, nil
}

var mySQLSapPurchaseContractHeaderDatumUniqueColumns = []string{
	"PurchaseContract",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapPurchaseContractHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_purchase_contract_header_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapPurchaseContractHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapPurchaseContractHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapPurchaseContractHeaderDatumUpsertCacheMut.RLock()
	cache, cached := sapPurchaseContractHeaderDatumUpsertCache[key]
	sapPurchaseContractHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapPurchaseContractHeaderDatumAllColumns,
			sapPurchaseContractHeaderDatumColumnsWithDefault,
			sapPurchaseContractHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapPurchaseContractHeaderDatumAllColumns,
			sapPurchaseContractHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_purchase_contract_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_purchase_contract_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_purchase_contract_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapPurchaseContractHeaderDatumType, sapPurchaseContractHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapPurchaseContractHeaderDatumType, sapPurchaseContractHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_purchase_contract_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapPurchaseContractHeaderDatumType, sapPurchaseContractHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_purchase_contract_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_purchase_contract_header_data")
	}

CacheNoHooks:
	if !cached {
		sapPurchaseContractHeaderDatumUpsertCacheMut.Lock()
		sapPurchaseContractHeaderDatumUpsertCache[key] = cache
		sapPurchaseContractHeaderDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapPurchaseContractHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapPurchaseContractHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapPurchaseContractHeaderDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapPurchaseContractHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_purchase_contract_header_data` WHERE `PurchaseContract`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_purchase_contract_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_purchase_contract_header_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapPurchaseContractHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapPurchaseContractHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_purchase_contract_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_purchase_contract_header_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapPurchaseContractHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapPurchaseContractHeaderDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapPurchaseContractHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_purchase_contract_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapPurchaseContractHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapPurchaseContractHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_purchase_contract_header_data")
	}

	if len(sapPurchaseContractHeaderDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapPurchaseContractHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapPurchaseContractHeaderDatum(ctx, exec, o.PurchaseContract)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapPurchaseContractHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapPurchaseContractHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapPurchaseContractHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_purchase_contract_header_data`.* FROM `sap_purchase_contract_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapPurchaseContractHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapPurchaseContractHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// SapPurchaseContractHeaderDatumExists checks if the SapPurchaseContractHeaderDatum row exists.
func SapPurchaseContractHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, purchaseContract string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_purchase_contract_header_data` where `PurchaseContract`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, purchaseContract)
	}
	row := exec.QueryRowContext(ctx, sql, purchaseContract)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_purchase_contract_header_data exists")
	}

	return exists, nil
}
