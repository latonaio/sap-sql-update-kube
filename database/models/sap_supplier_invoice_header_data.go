// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapSupplierInvoiceHeaderDatum is an object representing the database table.
type SapSupplierInvoiceHeaderDatum struct {
	SupplierInvoice               string      `boil:"SupplierInvoice" json:"SupplierInvoice" toml:"SupplierInvoice" yaml:"SupplierInvoice"`
	FiscalYear                    string      `boil:"FiscalYear" json:"FiscalYear" toml:"FiscalYear" yaml:"FiscalYear"`
	CompanyCode                   null.String `boil:"CompanyCode" json:"CompanyCode,omitempty" toml:"CompanyCode" yaml:"CompanyCode,omitempty"`
	DocumentDate                  null.String `boil:"DocumentDate" json:"DocumentDate,omitempty" toml:"DocumentDate" yaml:"DocumentDate,omitempty"`
	PostingDate                   null.String `boil:"PostingDate" json:"PostingDate,omitempty" toml:"PostingDate" yaml:"PostingDate,omitempty"`
	SupplierInvoiceIDByInvcgParty null.String `boil:"SupplierInvoiceIDByInvcgParty" json:"SupplierInvoiceIDByInvcgParty,omitempty" toml:"SupplierInvoiceIDByInvcgParty" yaml:"SupplierInvoiceIDByInvcgParty,omitempty"`
	InvoicingParty                null.String `boil:"InvoicingParty" json:"InvoicingParty,omitempty" toml:"InvoicingParty" yaml:"InvoicingParty,omitempty"`
	DocumentCurrency              null.String `boil:"DocumentCurrency" json:"DocumentCurrency,omitempty" toml:"DocumentCurrency" yaml:"DocumentCurrency,omitempty"`
	InvoiceGrossAmount            null.String `boil:"InvoiceGrossAmount" json:"InvoiceGrossAmount,omitempty" toml:"InvoiceGrossAmount" yaml:"InvoiceGrossAmount,omitempty"`
	DocumentHeaderText            null.String `boil:"DocumentHeaderText" json:"DocumentHeaderText,omitempty" toml:"DocumentHeaderText" yaml:"DocumentHeaderText,omitempty"`
	PaymentTerms                  null.String `boil:"PaymentTerms" json:"PaymentTerms,omitempty" toml:"PaymentTerms" yaml:"PaymentTerms,omitempty"`
	DueCalculationBaseDate        null.String `boil:"DueCalculationBaseDate" json:"DueCalculationBaseDate,omitempty" toml:"DueCalculationBaseDate" yaml:"DueCalculationBaseDate,omitempty"`
	NetPaymentDays                null.String `boil:"NetPaymentDays" json:"NetPaymentDays,omitempty" toml:"NetPaymentDays" yaml:"NetPaymentDays,omitempty"`
	PaymentBlockingReason         null.String `boil:"PaymentBlockingReason" json:"PaymentBlockingReason,omitempty" toml:"PaymentBlockingReason" yaml:"PaymentBlockingReason,omitempty"`
	AccountingDocumentType        null.String `boil:"AccountingDocumentType" json:"AccountingDocumentType,omitempty" toml:"AccountingDocumentType" yaml:"AccountingDocumentType,omitempty"`
	BPBankAccountInternalID       null.String `boil:"BPBankAccountInternalID" json:"BPBankAccountInternalID,omitempty" toml:"BPBankAccountInternalID" yaml:"BPBankAccountInternalID,omitempty"`
	SupplierInvoiceStatus         null.String `boil:"SupplierInvoiceStatus" json:"SupplierInvoiceStatus,omitempty" toml:"SupplierInvoiceStatus" yaml:"SupplierInvoiceStatus,omitempty"`
	DirectQuotedExchangeRate      null.String `boil:"DirectQuotedExchangeRate" json:"DirectQuotedExchangeRate,omitempty" toml:"DirectQuotedExchangeRate" yaml:"DirectQuotedExchangeRate,omitempty"`
	SupplyingCountry              null.String `boil:"SupplyingCountry" json:"SupplyingCountry,omitempty" toml:"SupplyingCountry" yaml:"SupplyingCountry,omitempty"`
	PaymentMethod                 null.String `boil:"PaymentMethod" json:"PaymentMethod,omitempty" toml:"PaymentMethod" yaml:"PaymentMethod,omitempty"`
	InvoiceReference              null.String `boil:"InvoiceReference" json:"InvoiceReference,omitempty" toml:"InvoiceReference" yaml:"InvoiceReference,omitempty"`
	SupplierPostingLineItemText   null.String `boil:"SupplierPostingLineItemText" json:"SupplierPostingLineItemText,omitempty" toml:"SupplierPostingLineItemText" yaml:"SupplierPostingLineItemText,omitempty"`
	TaxIsCalculatedAutomatically  null.Bool   `boil:"TaxIsCalculatedAutomatically" json:"TaxIsCalculatedAutomatically,omitempty" toml:"TaxIsCalculatedAutomatically" yaml:"TaxIsCalculatedAutomatically,omitempty"`
	BusinessArea                  null.String `boil:"BusinessArea" json:"BusinessArea,omitempty" toml:"BusinessArea" yaml:"BusinessArea,omitempty"`
	SupplierInvoiceIsCreditMemo   null.String `boil:"SupplierInvoiceIsCreditMemo" json:"SupplierInvoiceIsCreditMemo,omitempty" toml:"SupplierInvoiceIsCreditMemo" yaml:"SupplierInvoiceIsCreditMemo,omitempty"`
	ReverseDocument               null.String `boil:"ReverseDocument" json:"ReverseDocument,omitempty" toml:"ReverseDocument" yaml:"ReverseDocument,omitempty"`
	ReverseDocumentFiscalYear     null.String `boil:"ReverseDocumentFiscalYear" json:"ReverseDocumentFiscalYear,omitempty" toml:"ReverseDocumentFiscalYear" yaml:"ReverseDocumentFiscalYear,omitempty"`

	R *sapSupplierInvoiceHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapSupplierInvoiceHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapSupplierInvoiceHeaderDatumColumns = struct {
	SupplierInvoice               string
	FiscalYear                    string
	CompanyCode                   string
	DocumentDate                  string
	PostingDate                   string
	SupplierInvoiceIDByInvcgParty string
	InvoicingParty                string
	DocumentCurrency              string
	InvoiceGrossAmount            string
	DocumentHeaderText            string
	PaymentTerms                  string
	DueCalculationBaseDate        string
	NetPaymentDays                string
	PaymentBlockingReason         string
	AccountingDocumentType        string
	BPBankAccountInternalID       string
	SupplierInvoiceStatus         string
	DirectQuotedExchangeRate      string
	SupplyingCountry              string
	PaymentMethod                 string
	InvoiceReference              string
	SupplierPostingLineItemText   string
	TaxIsCalculatedAutomatically  string
	BusinessArea                  string
	SupplierInvoiceIsCreditMemo   string
	ReverseDocument               string
	ReverseDocumentFiscalYear     string
}{
	SupplierInvoice:               "SupplierInvoice",
	FiscalYear:                    "FiscalYear",
	CompanyCode:                   "CompanyCode",
	DocumentDate:                  "DocumentDate",
	PostingDate:                   "PostingDate",
	SupplierInvoiceIDByInvcgParty: "SupplierInvoiceIDByInvcgParty",
	InvoicingParty:                "InvoicingParty",
	DocumentCurrency:              "DocumentCurrency",
	InvoiceGrossAmount:            "InvoiceGrossAmount",
	DocumentHeaderText:            "DocumentHeaderText",
	PaymentTerms:                  "PaymentTerms",
	DueCalculationBaseDate:        "DueCalculationBaseDate",
	NetPaymentDays:                "NetPaymentDays",
	PaymentBlockingReason:         "PaymentBlockingReason",
	AccountingDocumentType:        "AccountingDocumentType",
	BPBankAccountInternalID:       "BPBankAccountInternalID",
	SupplierInvoiceStatus:         "SupplierInvoiceStatus",
	DirectQuotedExchangeRate:      "DirectQuotedExchangeRate",
	SupplyingCountry:              "SupplyingCountry",
	PaymentMethod:                 "PaymentMethod",
	InvoiceReference:              "InvoiceReference",
	SupplierPostingLineItemText:   "SupplierPostingLineItemText",
	TaxIsCalculatedAutomatically:  "TaxIsCalculatedAutomatically",
	BusinessArea:                  "BusinessArea",
	SupplierInvoiceIsCreditMemo:   "SupplierInvoiceIsCreditMemo",
	ReverseDocument:               "ReverseDocument",
	ReverseDocumentFiscalYear:     "ReverseDocumentFiscalYear",
}

var SapSupplierInvoiceHeaderDatumTableColumns = struct {
	SupplierInvoice               string
	FiscalYear                    string
	CompanyCode                   string
	DocumentDate                  string
	PostingDate                   string
	SupplierInvoiceIDByInvcgParty string
	InvoicingParty                string
	DocumentCurrency              string
	InvoiceGrossAmount            string
	DocumentHeaderText            string
	PaymentTerms                  string
	DueCalculationBaseDate        string
	NetPaymentDays                string
	PaymentBlockingReason         string
	AccountingDocumentType        string
	BPBankAccountInternalID       string
	SupplierInvoiceStatus         string
	DirectQuotedExchangeRate      string
	SupplyingCountry              string
	PaymentMethod                 string
	InvoiceReference              string
	SupplierPostingLineItemText   string
	TaxIsCalculatedAutomatically  string
	BusinessArea                  string
	SupplierInvoiceIsCreditMemo   string
	ReverseDocument               string
	ReverseDocumentFiscalYear     string
}{
	SupplierInvoice:               "sap_supplier_invoice_header_data.SupplierInvoice",
	FiscalYear:                    "sap_supplier_invoice_header_data.FiscalYear",
	CompanyCode:                   "sap_supplier_invoice_header_data.CompanyCode",
	DocumentDate:                  "sap_supplier_invoice_header_data.DocumentDate",
	PostingDate:                   "sap_supplier_invoice_header_data.PostingDate",
	SupplierInvoiceIDByInvcgParty: "sap_supplier_invoice_header_data.SupplierInvoiceIDByInvcgParty",
	InvoicingParty:                "sap_supplier_invoice_header_data.InvoicingParty",
	DocumentCurrency:              "sap_supplier_invoice_header_data.DocumentCurrency",
	InvoiceGrossAmount:            "sap_supplier_invoice_header_data.InvoiceGrossAmount",
	DocumentHeaderText:            "sap_supplier_invoice_header_data.DocumentHeaderText",
	PaymentTerms:                  "sap_supplier_invoice_header_data.PaymentTerms",
	DueCalculationBaseDate:        "sap_supplier_invoice_header_data.DueCalculationBaseDate",
	NetPaymentDays:                "sap_supplier_invoice_header_data.NetPaymentDays",
	PaymentBlockingReason:         "sap_supplier_invoice_header_data.PaymentBlockingReason",
	AccountingDocumentType:        "sap_supplier_invoice_header_data.AccountingDocumentType",
	BPBankAccountInternalID:       "sap_supplier_invoice_header_data.BPBankAccountInternalID",
	SupplierInvoiceStatus:         "sap_supplier_invoice_header_data.SupplierInvoiceStatus",
	DirectQuotedExchangeRate:      "sap_supplier_invoice_header_data.DirectQuotedExchangeRate",
	SupplyingCountry:              "sap_supplier_invoice_header_data.SupplyingCountry",
	PaymentMethod:                 "sap_supplier_invoice_header_data.PaymentMethod",
	InvoiceReference:              "sap_supplier_invoice_header_data.InvoiceReference",
	SupplierPostingLineItemText:   "sap_supplier_invoice_header_data.SupplierPostingLineItemText",
	TaxIsCalculatedAutomatically:  "sap_supplier_invoice_header_data.TaxIsCalculatedAutomatically",
	BusinessArea:                  "sap_supplier_invoice_header_data.BusinessArea",
	SupplierInvoiceIsCreditMemo:   "sap_supplier_invoice_header_data.SupplierInvoiceIsCreditMemo",
	ReverseDocument:               "sap_supplier_invoice_header_data.ReverseDocument",
	ReverseDocumentFiscalYear:     "sap_supplier_invoice_header_data.ReverseDocumentFiscalYear",
}

// Generated where

var SapSupplierInvoiceHeaderDatumWhere = struct {
	SupplierInvoice               whereHelperstring
	FiscalYear                    whereHelperstring
	CompanyCode                   whereHelpernull_String
	DocumentDate                  whereHelpernull_String
	PostingDate                   whereHelpernull_String
	SupplierInvoiceIDByInvcgParty whereHelpernull_String
	InvoicingParty                whereHelpernull_String
	DocumentCurrency              whereHelpernull_String
	InvoiceGrossAmount            whereHelpernull_String
	DocumentHeaderText            whereHelpernull_String
	PaymentTerms                  whereHelpernull_String
	DueCalculationBaseDate        whereHelpernull_String
	NetPaymentDays                whereHelpernull_String
	PaymentBlockingReason         whereHelpernull_String
	AccountingDocumentType        whereHelpernull_String
	BPBankAccountInternalID       whereHelpernull_String
	SupplierInvoiceStatus         whereHelpernull_String
	DirectQuotedExchangeRate      whereHelpernull_String
	SupplyingCountry              whereHelpernull_String
	PaymentMethod                 whereHelpernull_String
	InvoiceReference              whereHelpernull_String
	SupplierPostingLineItemText   whereHelpernull_String
	TaxIsCalculatedAutomatically  whereHelpernull_Bool
	BusinessArea                  whereHelpernull_String
	SupplierInvoiceIsCreditMemo   whereHelpernull_String
	ReverseDocument               whereHelpernull_String
	ReverseDocumentFiscalYear     whereHelpernull_String
}{
	SupplierInvoice:               whereHelperstring{field: "`sap_supplier_invoice_header_data`.`SupplierInvoice`"},
	FiscalYear:                    whereHelperstring{field: "`sap_supplier_invoice_header_data`.`FiscalYear`"},
	CompanyCode:                   whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`CompanyCode`"},
	DocumentDate:                  whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`DocumentDate`"},
	PostingDate:                   whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`PostingDate`"},
	SupplierInvoiceIDByInvcgParty: whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`SupplierInvoiceIDByInvcgParty`"},
	InvoicingParty:                whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`InvoicingParty`"},
	DocumentCurrency:              whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`DocumentCurrency`"},
	InvoiceGrossAmount:            whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`InvoiceGrossAmount`"},
	DocumentHeaderText:            whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`DocumentHeaderText`"},
	PaymentTerms:                  whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`PaymentTerms`"},
	DueCalculationBaseDate:        whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`DueCalculationBaseDate`"},
	NetPaymentDays:                whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`NetPaymentDays`"},
	PaymentBlockingReason:         whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`PaymentBlockingReason`"},
	AccountingDocumentType:        whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`AccountingDocumentType`"},
	BPBankAccountInternalID:       whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`BPBankAccountInternalID`"},
	SupplierInvoiceStatus:         whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`SupplierInvoiceStatus`"},
	DirectQuotedExchangeRate:      whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`DirectQuotedExchangeRate`"},
	SupplyingCountry:              whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`SupplyingCountry`"},
	PaymentMethod:                 whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`PaymentMethod`"},
	InvoiceReference:              whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`InvoiceReference`"},
	SupplierPostingLineItemText:   whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`SupplierPostingLineItemText`"},
	TaxIsCalculatedAutomatically:  whereHelpernull_Bool{field: "`sap_supplier_invoice_header_data`.`TaxIsCalculatedAutomatically`"},
	BusinessArea:                  whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`BusinessArea`"},
	SupplierInvoiceIsCreditMemo:   whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`SupplierInvoiceIsCreditMemo`"},
	ReverseDocument:               whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`ReverseDocument`"},
	ReverseDocumentFiscalYear:     whereHelpernull_String{field: "`sap_supplier_invoice_header_data`.`ReverseDocumentFiscalYear`"},
}

// SapSupplierInvoiceHeaderDatumRels is where relationship names are stored.
var SapSupplierInvoiceHeaderDatumRels = struct {
}{}

// sapSupplierInvoiceHeaderDatumR is where relationships are stored.
type sapSupplierInvoiceHeaderDatumR struct {
}

// NewStruct creates a new relationship struct
func (*sapSupplierInvoiceHeaderDatumR) NewStruct() *sapSupplierInvoiceHeaderDatumR {
	return &sapSupplierInvoiceHeaderDatumR{}
}

// sapSupplierInvoiceHeaderDatumL is where Load methods for each relationship are stored.
type sapSupplierInvoiceHeaderDatumL struct{}

var (
	sapSupplierInvoiceHeaderDatumAllColumns            = []string{"SupplierInvoice", "FiscalYear", "CompanyCode", "DocumentDate", "PostingDate", "SupplierInvoiceIDByInvcgParty", "InvoicingParty", "DocumentCurrency", "InvoiceGrossAmount", "DocumentHeaderText", "PaymentTerms", "DueCalculationBaseDate", "NetPaymentDays", "PaymentBlockingReason", "AccountingDocumentType", "BPBankAccountInternalID", "SupplierInvoiceStatus", "DirectQuotedExchangeRate", "SupplyingCountry", "PaymentMethod", "InvoiceReference", "SupplierPostingLineItemText", "TaxIsCalculatedAutomatically", "BusinessArea", "SupplierInvoiceIsCreditMemo", "ReverseDocument", "ReverseDocumentFiscalYear"}
	sapSupplierInvoiceHeaderDatumColumnsWithoutDefault = []string{"SupplierInvoice", "FiscalYear", "CompanyCode", "DocumentDate", "PostingDate", "SupplierInvoiceIDByInvcgParty", "InvoicingParty", "DocumentCurrency", "InvoiceGrossAmount", "DocumentHeaderText", "PaymentTerms", "DueCalculationBaseDate", "NetPaymentDays", "PaymentBlockingReason", "AccountingDocumentType", "BPBankAccountInternalID", "SupplierInvoiceStatus", "DirectQuotedExchangeRate", "SupplyingCountry", "PaymentMethod", "InvoiceReference", "SupplierPostingLineItemText", "TaxIsCalculatedAutomatically", "BusinessArea", "SupplierInvoiceIsCreditMemo", "ReverseDocument", "ReverseDocumentFiscalYear"}
	sapSupplierInvoiceHeaderDatumColumnsWithDefault    = []string{}
	sapSupplierInvoiceHeaderDatumPrimaryKeyColumns     = []string{"SupplierInvoice", "FiscalYear"}
	sapSupplierInvoiceHeaderDatumGeneratedColumns      = []string{}
)

type (
	// SapSupplierInvoiceHeaderDatumSlice is an alias for a slice of pointers to SapSupplierInvoiceHeaderDatum.
	// This should almost always be used instead of []SapSupplierInvoiceHeaderDatum.
	SapSupplierInvoiceHeaderDatumSlice []*SapSupplierInvoiceHeaderDatum
	// SapSupplierInvoiceHeaderDatumHook is the signature for custom SapSupplierInvoiceHeaderDatum hook methods
	SapSupplierInvoiceHeaderDatumHook func(context.Context, boil.ContextExecutor, *SapSupplierInvoiceHeaderDatum) error

	sapSupplierInvoiceHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapSupplierInvoiceHeaderDatumType                 = reflect.TypeOf(&SapSupplierInvoiceHeaderDatum{})
	sapSupplierInvoiceHeaderDatumMapping              = queries.MakeStructMapping(sapSupplierInvoiceHeaderDatumType)
	sapSupplierInvoiceHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(sapSupplierInvoiceHeaderDatumType, sapSupplierInvoiceHeaderDatumMapping, sapSupplierInvoiceHeaderDatumPrimaryKeyColumns)
	sapSupplierInvoiceHeaderDatumInsertCacheMut       sync.RWMutex
	sapSupplierInvoiceHeaderDatumInsertCache          = make(map[string]insertCache)
	sapSupplierInvoiceHeaderDatumUpdateCacheMut       sync.RWMutex
	sapSupplierInvoiceHeaderDatumUpdateCache          = make(map[string]updateCache)
	sapSupplierInvoiceHeaderDatumUpsertCacheMut       sync.RWMutex
	sapSupplierInvoiceHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapSupplierInvoiceHeaderDatumAfterSelectHooks []SapSupplierInvoiceHeaderDatumHook

var sapSupplierInvoiceHeaderDatumBeforeInsertHooks []SapSupplierInvoiceHeaderDatumHook
var sapSupplierInvoiceHeaderDatumAfterInsertHooks []SapSupplierInvoiceHeaderDatumHook

var sapSupplierInvoiceHeaderDatumBeforeUpdateHooks []SapSupplierInvoiceHeaderDatumHook
var sapSupplierInvoiceHeaderDatumAfterUpdateHooks []SapSupplierInvoiceHeaderDatumHook

var sapSupplierInvoiceHeaderDatumBeforeDeleteHooks []SapSupplierInvoiceHeaderDatumHook
var sapSupplierInvoiceHeaderDatumAfterDeleteHooks []SapSupplierInvoiceHeaderDatumHook

var sapSupplierInvoiceHeaderDatumBeforeUpsertHooks []SapSupplierInvoiceHeaderDatumHook
var sapSupplierInvoiceHeaderDatumAfterUpsertHooks []SapSupplierInvoiceHeaderDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapSupplierInvoiceHeaderDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSupplierInvoiceHeaderDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapSupplierInvoiceHeaderDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSupplierInvoiceHeaderDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapSupplierInvoiceHeaderDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSupplierInvoiceHeaderDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapSupplierInvoiceHeaderDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSupplierInvoiceHeaderDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapSupplierInvoiceHeaderDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSupplierInvoiceHeaderDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapSupplierInvoiceHeaderDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSupplierInvoiceHeaderDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapSupplierInvoiceHeaderDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSupplierInvoiceHeaderDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapSupplierInvoiceHeaderDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSupplierInvoiceHeaderDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapSupplierInvoiceHeaderDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSupplierInvoiceHeaderDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapSupplierInvoiceHeaderDatumHook registers your hook function for all future operations.
func AddSapSupplierInvoiceHeaderDatumHook(hookPoint boil.HookPoint, sapSupplierInvoiceHeaderDatumHook SapSupplierInvoiceHeaderDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapSupplierInvoiceHeaderDatumAfterSelectHooks = append(sapSupplierInvoiceHeaderDatumAfterSelectHooks, sapSupplierInvoiceHeaderDatumHook)
	case boil.BeforeInsertHook:
		sapSupplierInvoiceHeaderDatumBeforeInsertHooks = append(sapSupplierInvoiceHeaderDatumBeforeInsertHooks, sapSupplierInvoiceHeaderDatumHook)
	case boil.AfterInsertHook:
		sapSupplierInvoiceHeaderDatumAfterInsertHooks = append(sapSupplierInvoiceHeaderDatumAfterInsertHooks, sapSupplierInvoiceHeaderDatumHook)
	case boil.BeforeUpdateHook:
		sapSupplierInvoiceHeaderDatumBeforeUpdateHooks = append(sapSupplierInvoiceHeaderDatumBeforeUpdateHooks, sapSupplierInvoiceHeaderDatumHook)
	case boil.AfterUpdateHook:
		sapSupplierInvoiceHeaderDatumAfterUpdateHooks = append(sapSupplierInvoiceHeaderDatumAfterUpdateHooks, sapSupplierInvoiceHeaderDatumHook)
	case boil.BeforeDeleteHook:
		sapSupplierInvoiceHeaderDatumBeforeDeleteHooks = append(sapSupplierInvoiceHeaderDatumBeforeDeleteHooks, sapSupplierInvoiceHeaderDatumHook)
	case boil.AfterDeleteHook:
		sapSupplierInvoiceHeaderDatumAfterDeleteHooks = append(sapSupplierInvoiceHeaderDatumAfterDeleteHooks, sapSupplierInvoiceHeaderDatumHook)
	case boil.BeforeUpsertHook:
		sapSupplierInvoiceHeaderDatumBeforeUpsertHooks = append(sapSupplierInvoiceHeaderDatumBeforeUpsertHooks, sapSupplierInvoiceHeaderDatumHook)
	case boil.AfterUpsertHook:
		sapSupplierInvoiceHeaderDatumAfterUpsertHooks = append(sapSupplierInvoiceHeaderDatumAfterUpsertHooks, sapSupplierInvoiceHeaderDatumHook)
	}
}

// One returns a single sapSupplierInvoiceHeaderDatum record from the query.
func (q sapSupplierInvoiceHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapSupplierInvoiceHeaderDatum, error) {
	o := &SapSupplierInvoiceHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_supplier_invoice_header_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapSupplierInvoiceHeaderDatum records from the query.
func (q sapSupplierInvoiceHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapSupplierInvoiceHeaderDatumSlice, error) {
	var o []*SapSupplierInvoiceHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapSupplierInvoiceHeaderDatum slice")
	}

	if len(sapSupplierInvoiceHeaderDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapSupplierInvoiceHeaderDatum records in the query.
func (q sapSupplierInvoiceHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_supplier_invoice_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapSupplierInvoiceHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_supplier_invoice_header_data exists")
	}

	return count > 0, nil
}

// SapSupplierInvoiceHeaderData retrieves all the records using an executor.
func SapSupplierInvoiceHeaderData(mods ...qm.QueryMod) sapSupplierInvoiceHeaderDatumQuery {
	mods = append(mods, qm.From("`sap_supplier_invoice_header_data`"))
	return sapSupplierInvoiceHeaderDatumQuery{NewQuery(mods...)}
}

// FindSapSupplierInvoiceHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapSupplierInvoiceHeaderDatum(ctx context.Context, exec boil.ContextExecutor, supplierInvoice string, fiscalYear string, selectCols ...string) (*SapSupplierInvoiceHeaderDatum, error) {
	sapSupplierInvoiceHeaderDatumObj := &SapSupplierInvoiceHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_supplier_invoice_header_data` where `SupplierInvoice`=? AND `FiscalYear`=?", sel,
	)

	q := queries.Raw(query, supplierInvoice, fiscalYear)

	err := q.Bind(ctx, exec, sapSupplierInvoiceHeaderDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_supplier_invoice_header_data")
	}

	if err = sapSupplierInvoiceHeaderDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapSupplierInvoiceHeaderDatumObj, err
	}

	return sapSupplierInvoiceHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapSupplierInvoiceHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_supplier_invoice_header_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapSupplierInvoiceHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapSupplierInvoiceHeaderDatumInsertCacheMut.RLock()
	cache, cached := sapSupplierInvoiceHeaderDatumInsertCache[key]
	sapSupplierInvoiceHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapSupplierInvoiceHeaderDatumAllColumns,
			sapSupplierInvoiceHeaderDatumColumnsWithDefault,
			sapSupplierInvoiceHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapSupplierInvoiceHeaderDatumType, sapSupplierInvoiceHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapSupplierInvoiceHeaderDatumType, sapSupplierInvoiceHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_supplier_invoice_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_supplier_invoice_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_supplier_invoice_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapSupplierInvoiceHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_supplier_invoice_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.SupplierInvoice,
		o.FiscalYear,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_supplier_invoice_header_data")
	}

CacheNoHooks:
	if !cached {
		sapSupplierInvoiceHeaderDatumInsertCacheMut.Lock()
		sapSupplierInvoiceHeaderDatumInsertCache[key] = cache
		sapSupplierInvoiceHeaderDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapSupplierInvoiceHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapSupplierInvoiceHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapSupplierInvoiceHeaderDatumUpdateCacheMut.RLock()
	cache, cached := sapSupplierInvoiceHeaderDatumUpdateCache[key]
	sapSupplierInvoiceHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapSupplierInvoiceHeaderDatumAllColumns,
			sapSupplierInvoiceHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_supplier_invoice_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_supplier_invoice_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapSupplierInvoiceHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapSupplierInvoiceHeaderDatumType, sapSupplierInvoiceHeaderDatumMapping, append(wl, sapSupplierInvoiceHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_supplier_invoice_header_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_supplier_invoice_header_data")
	}

	if !cached {
		sapSupplierInvoiceHeaderDatumUpdateCacheMut.Lock()
		sapSupplierInvoiceHeaderDatumUpdateCache[key] = cache
		sapSupplierInvoiceHeaderDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapSupplierInvoiceHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_supplier_invoice_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_supplier_invoice_header_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapSupplierInvoiceHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapSupplierInvoiceHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_supplier_invoice_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapSupplierInvoiceHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapSupplierInvoiceHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapSupplierInvoiceHeaderDatum")
	}
	return rowsAff, nil
}

var mySQLSapSupplierInvoiceHeaderDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapSupplierInvoiceHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_supplier_invoice_header_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapSupplierInvoiceHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapSupplierInvoiceHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapSupplierInvoiceHeaderDatumUpsertCacheMut.RLock()
	cache, cached := sapSupplierInvoiceHeaderDatumUpsertCache[key]
	sapSupplierInvoiceHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapSupplierInvoiceHeaderDatumAllColumns,
			sapSupplierInvoiceHeaderDatumColumnsWithDefault,
			sapSupplierInvoiceHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapSupplierInvoiceHeaderDatumAllColumns,
			sapSupplierInvoiceHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_supplier_invoice_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_supplier_invoice_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_supplier_invoice_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapSupplierInvoiceHeaderDatumType, sapSupplierInvoiceHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapSupplierInvoiceHeaderDatumType, sapSupplierInvoiceHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_supplier_invoice_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapSupplierInvoiceHeaderDatumType, sapSupplierInvoiceHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_supplier_invoice_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_supplier_invoice_header_data")
	}

CacheNoHooks:
	if !cached {
		sapSupplierInvoiceHeaderDatumUpsertCacheMut.Lock()
		sapSupplierInvoiceHeaderDatumUpsertCache[key] = cache
		sapSupplierInvoiceHeaderDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapSupplierInvoiceHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapSupplierInvoiceHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapSupplierInvoiceHeaderDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapSupplierInvoiceHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_supplier_invoice_header_data` WHERE `SupplierInvoice`=? AND `FiscalYear`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_supplier_invoice_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_supplier_invoice_header_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapSupplierInvoiceHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapSupplierInvoiceHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_supplier_invoice_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_supplier_invoice_header_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapSupplierInvoiceHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapSupplierInvoiceHeaderDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapSupplierInvoiceHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_supplier_invoice_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapSupplierInvoiceHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapSupplierInvoiceHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_supplier_invoice_header_data")
	}

	if len(sapSupplierInvoiceHeaderDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapSupplierInvoiceHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapSupplierInvoiceHeaderDatum(ctx, exec, o.SupplierInvoice, o.FiscalYear)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapSupplierInvoiceHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapSupplierInvoiceHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapSupplierInvoiceHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_supplier_invoice_header_data`.* FROM `sap_supplier_invoice_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapSupplierInvoiceHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapSupplierInvoiceHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// SapSupplierInvoiceHeaderDatumExists checks if the SapSupplierInvoiceHeaderDatum row exists.
func SapSupplierInvoiceHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, supplierInvoice string, fiscalYear string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_supplier_invoice_header_data` where `SupplierInvoice`=? AND `FiscalYear`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, supplierInvoice, fiscalYear)
	}
	row := exec.QueryRowContext(ctx, sql, supplierInvoice, fiscalYear)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_supplier_invoice_header_data exists")
	}

	return exists, nil
}
