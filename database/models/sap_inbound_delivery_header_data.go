// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapInboundDeliveryHeaderDatum is an object representing the database table.
type SapInboundDeliveryHeaderDatum struct {
	DeliveryDocument              string      `boil:"DeliveryDocument" json:"DeliveryDocument" toml:"DeliveryDocument" yaml:"DeliveryDocument"`
	ReceivingLocationTimeZone     null.String `boil:"ReceivingLocationTimeZone" json:"ReceivingLocationTimeZone,omitempty" toml:"ReceivingLocationTimeZone" yaml:"ReceivingLocationTimeZone,omitempty"`
	ActualDeliveryRoute           null.String `boil:"ActualDeliveryRoute" json:"ActualDeliveryRoute,omitempty" toml:"ActualDeliveryRoute" yaml:"ActualDeliveryRoute,omitempty"`
	ActualGoodsMovementDate       null.String `boil:"ActualGoodsMovementDate" json:"ActualGoodsMovementDate,omitempty" toml:"ActualGoodsMovementDate" yaml:"ActualGoodsMovementDate,omitempty"`
	ActualGoodsMovementTime       null.String `boil:"ActualGoodsMovementTime" json:"ActualGoodsMovementTime,omitempty" toml:"ActualGoodsMovementTime" yaml:"ActualGoodsMovementTime,omitempty"`
	BillingDocumentDate           null.String `boil:"BillingDocumentDate" json:"BillingDocumentDate,omitempty" toml:"BillingDocumentDate" yaml:"BillingDocumentDate,omitempty"`
	CompleteDeliveryIsDefined     null.Bool   `boil:"CompleteDeliveryIsDefined" json:"CompleteDeliveryIsDefined,omitempty" toml:"CompleteDeliveryIsDefined" yaml:"CompleteDeliveryIsDefined,omitempty"`
	ConfirmationTime              null.String `boil:"ConfirmationTime" json:"ConfirmationTime,omitempty" toml:"ConfirmationTime" yaml:"ConfirmationTime,omitempty"`
	CreationDate                  null.String `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	CreationTime                  null.String `boil:"CreationTime" json:"CreationTime,omitempty" toml:"CreationTime" yaml:"CreationTime,omitempty"`
	CustomerGroup                 null.String `boil:"CustomerGroup" json:"CustomerGroup,omitempty" toml:"CustomerGroup" yaml:"CustomerGroup,omitempty"`
	DeliveryBlockReason           null.String `boil:"DeliveryBlockReason" json:"DeliveryBlockReason,omitempty" toml:"DeliveryBlockReason" yaml:"DeliveryBlockReason,omitempty"`
	DeliveryDate                  null.String `boil:"DeliveryDate" json:"DeliveryDate,omitempty" toml:"DeliveryDate" yaml:"DeliveryDate,omitempty"`
	DeliveryDocumentBySupplier    null.String `boil:"DeliveryDocumentBySupplier" json:"DeliveryDocumentBySupplier,omitempty" toml:"DeliveryDocumentBySupplier" yaml:"DeliveryDocumentBySupplier,omitempty"`
	DeliveryDocumentType          null.String `boil:"DeliveryDocumentType" json:"DeliveryDocumentType,omitempty" toml:"DeliveryDocumentType" yaml:"DeliveryDocumentType,omitempty"`
	DeliveryIsInPlant             null.Bool   `boil:"DeliveryIsInPlant" json:"DeliveryIsInPlant,omitempty" toml:"DeliveryIsInPlant" yaml:"DeliveryIsInPlant,omitempty"`
	DeliveryPriority              null.String `boil:"DeliveryPriority" json:"DeliveryPriority,omitempty" toml:"DeliveryPriority" yaml:"DeliveryPriority,omitempty"`
	DeliveryTime                  null.String `boil:"DeliveryTime" json:"DeliveryTime,omitempty" toml:"DeliveryTime" yaml:"DeliveryTime,omitempty"`
	DocumentDate                  null.String `boil:"DocumentDate" json:"DocumentDate,omitempty" toml:"DocumentDate" yaml:"DocumentDate,omitempty"`
	GoodsIssueOrReceiptSlipNumber null.String `boil:"GoodsIssueOrReceiptSlipNumber" json:"GoodsIssueOrReceiptSlipNumber,omitempty" toml:"GoodsIssueOrReceiptSlipNumber" yaml:"GoodsIssueOrReceiptSlipNumber,omitempty"`
	GoodsIssueTime                null.String `boil:"GoodsIssueTime" json:"GoodsIssueTime,omitempty" toml:"GoodsIssueTime" yaml:"GoodsIssueTime,omitempty"`
	HeaderBillgIncompletionStatus null.String `boil:"HeaderBillgIncompletionStatus" json:"HeaderBillgIncompletionStatus,omitempty" toml:"HeaderBillgIncompletionStatus" yaml:"HeaderBillgIncompletionStatus,omitempty"`
	HeaderBillingBlockReason      null.String `boil:"HeaderBillingBlockReason" json:"HeaderBillingBlockReason,omitempty" toml:"HeaderBillingBlockReason" yaml:"HeaderBillingBlockReason,omitempty"`
	HeaderDelivIncompletionStatus null.String `boil:"HeaderDelivIncompletionStatus" json:"HeaderDelivIncompletionStatus,omitempty" toml:"HeaderDelivIncompletionStatus" yaml:"HeaderDelivIncompletionStatus,omitempty"`
	HeaderGrossWeight             null.String `boil:"HeaderGrossWeight" json:"HeaderGrossWeight,omitempty" toml:"HeaderGrossWeight" yaml:"HeaderGrossWeight,omitempty"`
	HeaderNetWeight               null.String `boil:"HeaderNetWeight" json:"HeaderNetWeight,omitempty" toml:"HeaderNetWeight" yaml:"HeaderNetWeight,omitempty"`
	HeaderPackingIncompletionSts  null.String `boil:"HeaderPackingIncompletionSts" json:"HeaderPackingIncompletionSts,omitempty" toml:"HeaderPackingIncompletionSts" yaml:"HeaderPackingIncompletionSts,omitempty"`
	HeaderPickgIncompletionStatus null.String `boil:"HeaderPickgIncompletionStatus" json:"HeaderPickgIncompletionStatus,omitempty" toml:"HeaderPickgIncompletionStatus" yaml:"HeaderPickgIncompletionStatus,omitempty"`
	HeaderVolume                  null.String `boil:"HeaderVolume" json:"HeaderVolume,omitempty" toml:"HeaderVolume" yaml:"HeaderVolume,omitempty"`
	HeaderVolumeUnit              null.String `boil:"HeaderVolumeUnit" json:"HeaderVolumeUnit,omitempty" toml:"HeaderVolumeUnit" yaml:"HeaderVolumeUnit,omitempty"`
	HeaderWeightUnit              null.String `boil:"HeaderWeightUnit" json:"HeaderWeightUnit,omitempty" toml:"HeaderWeightUnit" yaml:"HeaderWeightUnit,omitempty"`
	IncotermsClassification       null.String `boil:"IncotermsClassification" json:"IncotermsClassification,omitempty" toml:"IncotermsClassification" yaml:"IncotermsClassification,omitempty"`
	IsExportDelivery              null.String `boil:"IsExportDelivery" json:"IsExportDelivery,omitempty" toml:"IsExportDelivery" yaml:"IsExportDelivery,omitempty"`
	LastChangeDate                null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	LoadingDate                   null.String `boil:"LoadingDate" json:"LoadingDate,omitempty" toml:"LoadingDate" yaml:"LoadingDate,omitempty"`
	LoadingPoint                  null.String `boil:"LoadingPoint" json:"LoadingPoint,omitempty" toml:"LoadingPoint" yaml:"LoadingPoint,omitempty"`
	LoadingTime                   null.String `boil:"LoadingTime" json:"LoadingTime,omitempty" toml:"LoadingTime" yaml:"LoadingTime,omitempty"`
	MeansOfTransport              null.String `boil:"MeansOfTransport" json:"MeansOfTransport,omitempty" toml:"MeansOfTransport" yaml:"MeansOfTransport,omitempty"`
	OrderCombinationIsAllowed     null.Bool   `boil:"OrderCombinationIsAllowed" json:"OrderCombinationIsAllowed,omitempty" toml:"OrderCombinationIsAllowed" yaml:"OrderCombinationIsAllowed,omitempty"`
	OrderID                       null.String `boil:"OrderID" json:"OrderID,omitempty" toml:"OrderID" yaml:"OrderID,omitempty"`
	PickedItemsLocation           null.String `boil:"PickedItemsLocation" json:"PickedItemsLocation,omitempty" toml:"PickedItemsLocation" yaml:"PickedItemsLocation,omitempty"`
	PickingDate                   null.String `boil:"PickingDate" json:"PickingDate,omitempty" toml:"PickingDate" yaml:"PickingDate,omitempty"`
	PickingTime                   null.String `boil:"PickingTime" json:"PickingTime,omitempty" toml:"PickingTime" yaml:"PickingTime,omitempty"`
	PlannedGoodsIssueDate         null.String `boil:"PlannedGoodsIssueDate" json:"PlannedGoodsIssueDate,omitempty" toml:"PlannedGoodsIssueDate" yaml:"PlannedGoodsIssueDate,omitempty"`
	ProposedDeliveryRoute         null.String `boil:"ProposedDeliveryRoute" json:"ProposedDeliveryRoute,omitempty" toml:"ProposedDeliveryRoute" yaml:"ProposedDeliveryRoute,omitempty"`
	ReceivingPlant                null.String `boil:"ReceivingPlant" json:"ReceivingPlant,omitempty" toml:"ReceivingPlant" yaml:"ReceivingPlant,omitempty"`
	RouteSchedule                 null.String `boil:"RouteSchedule" json:"RouteSchedule,omitempty" toml:"RouteSchedule" yaml:"RouteSchedule,omitempty"`
	SalesDistrict                 null.String `boil:"SalesDistrict" json:"SalesDistrict,omitempty" toml:"SalesDistrict" yaml:"SalesDistrict,omitempty"`
	SalesOffice                   null.String `boil:"SalesOffice" json:"SalesOffice,omitempty" toml:"SalesOffice" yaml:"SalesOffice,omitempty"`
	SalesOrganization             null.String `boil:"SalesOrganization" json:"SalesOrganization,omitempty" toml:"SalesOrganization" yaml:"SalesOrganization,omitempty"`
	SDDocumentCategory            null.String `boil:"SDDocumentCategory" json:"SDDocumentCategory,omitempty" toml:"SDDocumentCategory" yaml:"SDDocumentCategory,omitempty"`
	ShipmentBlockReason           null.String `boil:"ShipmentBlockReason" json:"ShipmentBlockReason,omitempty" toml:"ShipmentBlockReason" yaml:"ShipmentBlockReason,omitempty"`
	ShippingCondition             null.String `boil:"ShippingCondition" json:"ShippingCondition,omitempty" toml:"ShippingCondition" yaml:"ShippingCondition,omitempty"`
	ShippingPoint                 null.String `boil:"ShippingPoint" json:"ShippingPoint,omitempty" toml:"ShippingPoint" yaml:"ShippingPoint,omitempty"`
	ShippingType                  null.String `boil:"ShippingType" json:"ShippingType,omitempty" toml:"ShippingType" yaml:"ShippingType,omitempty"`
	ShipToParty                   null.String `boil:"ShipToParty" json:"ShipToParty,omitempty" toml:"ShipToParty" yaml:"ShipToParty,omitempty"`
	SoldToParty                   null.String `boil:"SoldToParty" json:"SoldToParty,omitempty" toml:"SoldToParty" yaml:"SoldToParty,omitempty"`
	Supplier                      null.String `boil:"Supplier" json:"Supplier,omitempty" toml:"Supplier" yaml:"Supplier,omitempty"`
	TotalBlockStatus              null.String `boil:"TotalBlockStatus" json:"TotalBlockStatus,omitempty" toml:"TotalBlockStatus" yaml:"TotalBlockStatus,omitempty"`
	TotalCreditCheckStatus        null.String `boil:"TotalCreditCheckStatus" json:"TotalCreditCheckStatus,omitempty" toml:"TotalCreditCheckStatus" yaml:"TotalCreditCheckStatus,omitempty"`
	TotalNumberOfPackage          null.String `boil:"TotalNumberOfPackage" json:"TotalNumberOfPackage,omitempty" toml:"TotalNumberOfPackage" yaml:"TotalNumberOfPackage,omitempty"`
	TransactionCurrency           null.String `boil:"TransactionCurrency" json:"TransactionCurrency,omitempty" toml:"TransactionCurrency" yaml:"TransactionCurrency,omitempty"`
	TransportationGroup           null.String `boil:"TransportationGroup" json:"TransportationGroup,omitempty" toml:"TransportationGroup" yaml:"TransportationGroup,omitempty"`
	TransportationPlanningDate    null.String `boil:"TransportationPlanningDate" json:"TransportationPlanningDate,omitempty" toml:"TransportationPlanningDate" yaml:"TransportationPlanningDate,omitempty"`
	TransportationPlanningStatus  null.String `boil:"TransportationPlanningStatus" json:"TransportationPlanningStatus,omitempty" toml:"TransportationPlanningStatus" yaml:"TransportationPlanningStatus,omitempty"`
	TransportationPlanningTime    null.String `boil:"TransportationPlanningTime" json:"TransportationPlanningTime,omitempty" toml:"TransportationPlanningTime" yaml:"TransportationPlanningTime,omitempty"`
	UnloadingPointName            null.String `boil:"UnloadingPointName" json:"UnloadingPointName,omitempty" toml:"UnloadingPointName" yaml:"UnloadingPointName,omitempty"`

	R *sapInboundDeliveryHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapInboundDeliveryHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapInboundDeliveryHeaderDatumColumns = struct {
	DeliveryDocument              string
	ReceivingLocationTimeZone     string
	ActualDeliveryRoute           string
	ActualGoodsMovementDate       string
	ActualGoodsMovementTime       string
	BillingDocumentDate           string
	CompleteDeliveryIsDefined     string
	ConfirmationTime              string
	CreationDate                  string
	CreationTime                  string
	CustomerGroup                 string
	DeliveryBlockReason           string
	DeliveryDate                  string
	DeliveryDocumentBySupplier    string
	DeliveryDocumentType          string
	DeliveryIsInPlant             string
	DeliveryPriority              string
	DeliveryTime                  string
	DocumentDate                  string
	GoodsIssueOrReceiptSlipNumber string
	GoodsIssueTime                string
	HeaderBillgIncompletionStatus string
	HeaderBillingBlockReason      string
	HeaderDelivIncompletionStatus string
	HeaderGrossWeight             string
	HeaderNetWeight               string
	HeaderPackingIncompletionSts  string
	HeaderPickgIncompletionStatus string
	HeaderVolume                  string
	HeaderVolumeUnit              string
	HeaderWeightUnit              string
	IncotermsClassification       string
	IsExportDelivery              string
	LastChangeDate                string
	LoadingDate                   string
	LoadingPoint                  string
	LoadingTime                   string
	MeansOfTransport              string
	OrderCombinationIsAllowed     string
	OrderID                       string
	PickedItemsLocation           string
	PickingDate                   string
	PickingTime                   string
	PlannedGoodsIssueDate         string
	ProposedDeliveryRoute         string
	ReceivingPlant                string
	RouteSchedule                 string
	SalesDistrict                 string
	SalesOffice                   string
	SalesOrganization             string
	SDDocumentCategory            string
	ShipmentBlockReason           string
	ShippingCondition             string
	ShippingPoint                 string
	ShippingType                  string
	ShipToParty                   string
	SoldToParty                   string
	Supplier                      string
	TotalBlockStatus              string
	TotalCreditCheckStatus        string
	TotalNumberOfPackage          string
	TransactionCurrency           string
	TransportationGroup           string
	TransportationPlanningDate    string
	TransportationPlanningStatus  string
	TransportationPlanningTime    string
	UnloadingPointName            string
}{
	DeliveryDocument:              "DeliveryDocument",
	ReceivingLocationTimeZone:     "ReceivingLocationTimeZone",
	ActualDeliveryRoute:           "ActualDeliveryRoute",
	ActualGoodsMovementDate:       "ActualGoodsMovementDate",
	ActualGoodsMovementTime:       "ActualGoodsMovementTime",
	BillingDocumentDate:           "BillingDocumentDate",
	CompleteDeliveryIsDefined:     "CompleteDeliveryIsDefined",
	ConfirmationTime:              "ConfirmationTime",
	CreationDate:                  "CreationDate",
	CreationTime:                  "CreationTime",
	CustomerGroup:                 "CustomerGroup",
	DeliveryBlockReason:           "DeliveryBlockReason",
	DeliveryDate:                  "DeliveryDate",
	DeliveryDocumentBySupplier:    "DeliveryDocumentBySupplier",
	DeliveryDocumentType:          "DeliveryDocumentType",
	DeliveryIsInPlant:             "DeliveryIsInPlant",
	DeliveryPriority:              "DeliveryPriority",
	DeliveryTime:                  "DeliveryTime",
	DocumentDate:                  "DocumentDate",
	GoodsIssueOrReceiptSlipNumber: "GoodsIssueOrReceiptSlipNumber",
	GoodsIssueTime:                "GoodsIssueTime",
	HeaderBillgIncompletionStatus: "HeaderBillgIncompletionStatus",
	HeaderBillingBlockReason:      "HeaderBillingBlockReason",
	HeaderDelivIncompletionStatus: "HeaderDelivIncompletionStatus",
	HeaderGrossWeight:             "HeaderGrossWeight",
	HeaderNetWeight:               "HeaderNetWeight",
	HeaderPackingIncompletionSts:  "HeaderPackingIncompletionSts",
	HeaderPickgIncompletionStatus: "HeaderPickgIncompletionStatus",
	HeaderVolume:                  "HeaderVolume",
	HeaderVolumeUnit:              "HeaderVolumeUnit",
	HeaderWeightUnit:              "HeaderWeightUnit",
	IncotermsClassification:       "IncotermsClassification",
	IsExportDelivery:              "IsExportDelivery",
	LastChangeDate:                "LastChangeDate",
	LoadingDate:                   "LoadingDate",
	LoadingPoint:                  "LoadingPoint",
	LoadingTime:                   "LoadingTime",
	MeansOfTransport:              "MeansOfTransport",
	OrderCombinationIsAllowed:     "OrderCombinationIsAllowed",
	OrderID:                       "OrderID",
	PickedItemsLocation:           "PickedItemsLocation",
	PickingDate:                   "PickingDate",
	PickingTime:                   "PickingTime",
	PlannedGoodsIssueDate:         "PlannedGoodsIssueDate",
	ProposedDeliveryRoute:         "ProposedDeliveryRoute",
	ReceivingPlant:                "ReceivingPlant",
	RouteSchedule:                 "RouteSchedule",
	SalesDistrict:                 "SalesDistrict",
	SalesOffice:                   "SalesOffice",
	SalesOrganization:             "SalesOrganization",
	SDDocumentCategory:            "SDDocumentCategory",
	ShipmentBlockReason:           "ShipmentBlockReason",
	ShippingCondition:             "ShippingCondition",
	ShippingPoint:                 "ShippingPoint",
	ShippingType:                  "ShippingType",
	ShipToParty:                   "ShipToParty",
	SoldToParty:                   "SoldToParty",
	Supplier:                      "Supplier",
	TotalBlockStatus:              "TotalBlockStatus",
	TotalCreditCheckStatus:        "TotalCreditCheckStatus",
	TotalNumberOfPackage:          "TotalNumberOfPackage",
	TransactionCurrency:           "TransactionCurrency",
	TransportationGroup:           "TransportationGroup",
	TransportationPlanningDate:    "TransportationPlanningDate",
	TransportationPlanningStatus:  "TransportationPlanningStatus",
	TransportationPlanningTime:    "TransportationPlanningTime",
	UnloadingPointName:            "UnloadingPointName",
}

var SapInboundDeliveryHeaderDatumTableColumns = struct {
	DeliveryDocument              string
	ReceivingLocationTimeZone     string
	ActualDeliveryRoute           string
	ActualGoodsMovementDate       string
	ActualGoodsMovementTime       string
	BillingDocumentDate           string
	CompleteDeliveryIsDefined     string
	ConfirmationTime              string
	CreationDate                  string
	CreationTime                  string
	CustomerGroup                 string
	DeliveryBlockReason           string
	DeliveryDate                  string
	DeliveryDocumentBySupplier    string
	DeliveryDocumentType          string
	DeliveryIsInPlant             string
	DeliveryPriority              string
	DeliveryTime                  string
	DocumentDate                  string
	GoodsIssueOrReceiptSlipNumber string
	GoodsIssueTime                string
	HeaderBillgIncompletionStatus string
	HeaderBillingBlockReason      string
	HeaderDelivIncompletionStatus string
	HeaderGrossWeight             string
	HeaderNetWeight               string
	HeaderPackingIncompletionSts  string
	HeaderPickgIncompletionStatus string
	HeaderVolume                  string
	HeaderVolumeUnit              string
	HeaderWeightUnit              string
	IncotermsClassification       string
	IsExportDelivery              string
	LastChangeDate                string
	LoadingDate                   string
	LoadingPoint                  string
	LoadingTime                   string
	MeansOfTransport              string
	OrderCombinationIsAllowed     string
	OrderID                       string
	PickedItemsLocation           string
	PickingDate                   string
	PickingTime                   string
	PlannedGoodsIssueDate         string
	ProposedDeliveryRoute         string
	ReceivingPlant                string
	RouteSchedule                 string
	SalesDistrict                 string
	SalesOffice                   string
	SalesOrganization             string
	SDDocumentCategory            string
	ShipmentBlockReason           string
	ShippingCondition             string
	ShippingPoint                 string
	ShippingType                  string
	ShipToParty                   string
	SoldToParty                   string
	Supplier                      string
	TotalBlockStatus              string
	TotalCreditCheckStatus        string
	TotalNumberOfPackage          string
	TransactionCurrency           string
	TransportationGroup           string
	TransportationPlanningDate    string
	TransportationPlanningStatus  string
	TransportationPlanningTime    string
	UnloadingPointName            string
}{
	DeliveryDocument:              "sap_inbound_delivery_header_data.DeliveryDocument",
	ReceivingLocationTimeZone:     "sap_inbound_delivery_header_data.ReceivingLocationTimeZone",
	ActualDeliveryRoute:           "sap_inbound_delivery_header_data.ActualDeliveryRoute",
	ActualGoodsMovementDate:       "sap_inbound_delivery_header_data.ActualGoodsMovementDate",
	ActualGoodsMovementTime:       "sap_inbound_delivery_header_data.ActualGoodsMovementTime",
	BillingDocumentDate:           "sap_inbound_delivery_header_data.BillingDocumentDate",
	CompleteDeliveryIsDefined:     "sap_inbound_delivery_header_data.CompleteDeliveryIsDefined",
	ConfirmationTime:              "sap_inbound_delivery_header_data.ConfirmationTime",
	CreationDate:                  "sap_inbound_delivery_header_data.CreationDate",
	CreationTime:                  "sap_inbound_delivery_header_data.CreationTime",
	CustomerGroup:                 "sap_inbound_delivery_header_data.CustomerGroup",
	DeliveryBlockReason:           "sap_inbound_delivery_header_data.DeliveryBlockReason",
	DeliveryDate:                  "sap_inbound_delivery_header_data.DeliveryDate",
	DeliveryDocumentBySupplier:    "sap_inbound_delivery_header_data.DeliveryDocumentBySupplier",
	DeliveryDocumentType:          "sap_inbound_delivery_header_data.DeliveryDocumentType",
	DeliveryIsInPlant:             "sap_inbound_delivery_header_data.DeliveryIsInPlant",
	DeliveryPriority:              "sap_inbound_delivery_header_data.DeliveryPriority",
	DeliveryTime:                  "sap_inbound_delivery_header_data.DeliveryTime",
	DocumentDate:                  "sap_inbound_delivery_header_data.DocumentDate",
	GoodsIssueOrReceiptSlipNumber: "sap_inbound_delivery_header_data.GoodsIssueOrReceiptSlipNumber",
	GoodsIssueTime:                "sap_inbound_delivery_header_data.GoodsIssueTime",
	HeaderBillgIncompletionStatus: "sap_inbound_delivery_header_data.HeaderBillgIncompletionStatus",
	HeaderBillingBlockReason:      "sap_inbound_delivery_header_data.HeaderBillingBlockReason",
	HeaderDelivIncompletionStatus: "sap_inbound_delivery_header_data.HeaderDelivIncompletionStatus",
	HeaderGrossWeight:             "sap_inbound_delivery_header_data.HeaderGrossWeight",
	HeaderNetWeight:               "sap_inbound_delivery_header_data.HeaderNetWeight",
	HeaderPackingIncompletionSts:  "sap_inbound_delivery_header_data.HeaderPackingIncompletionSts",
	HeaderPickgIncompletionStatus: "sap_inbound_delivery_header_data.HeaderPickgIncompletionStatus",
	HeaderVolume:                  "sap_inbound_delivery_header_data.HeaderVolume",
	HeaderVolumeUnit:              "sap_inbound_delivery_header_data.HeaderVolumeUnit",
	HeaderWeightUnit:              "sap_inbound_delivery_header_data.HeaderWeightUnit",
	IncotermsClassification:       "sap_inbound_delivery_header_data.IncotermsClassification",
	IsExportDelivery:              "sap_inbound_delivery_header_data.IsExportDelivery",
	LastChangeDate:                "sap_inbound_delivery_header_data.LastChangeDate",
	LoadingDate:                   "sap_inbound_delivery_header_data.LoadingDate",
	LoadingPoint:                  "sap_inbound_delivery_header_data.LoadingPoint",
	LoadingTime:                   "sap_inbound_delivery_header_data.LoadingTime",
	MeansOfTransport:              "sap_inbound_delivery_header_data.MeansOfTransport",
	OrderCombinationIsAllowed:     "sap_inbound_delivery_header_data.OrderCombinationIsAllowed",
	OrderID:                       "sap_inbound_delivery_header_data.OrderID",
	PickedItemsLocation:           "sap_inbound_delivery_header_data.PickedItemsLocation",
	PickingDate:                   "sap_inbound_delivery_header_data.PickingDate",
	PickingTime:                   "sap_inbound_delivery_header_data.PickingTime",
	PlannedGoodsIssueDate:         "sap_inbound_delivery_header_data.PlannedGoodsIssueDate",
	ProposedDeliveryRoute:         "sap_inbound_delivery_header_data.ProposedDeliveryRoute",
	ReceivingPlant:                "sap_inbound_delivery_header_data.ReceivingPlant",
	RouteSchedule:                 "sap_inbound_delivery_header_data.RouteSchedule",
	SalesDistrict:                 "sap_inbound_delivery_header_data.SalesDistrict",
	SalesOffice:                   "sap_inbound_delivery_header_data.SalesOffice",
	SalesOrganization:             "sap_inbound_delivery_header_data.SalesOrganization",
	SDDocumentCategory:            "sap_inbound_delivery_header_data.SDDocumentCategory",
	ShipmentBlockReason:           "sap_inbound_delivery_header_data.ShipmentBlockReason",
	ShippingCondition:             "sap_inbound_delivery_header_data.ShippingCondition",
	ShippingPoint:                 "sap_inbound_delivery_header_data.ShippingPoint",
	ShippingType:                  "sap_inbound_delivery_header_data.ShippingType",
	ShipToParty:                   "sap_inbound_delivery_header_data.ShipToParty",
	SoldToParty:                   "sap_inbound_delivery_header_data.SoldToParty",
	Supplier:                      "sap_inbound_delivery_header_data.Supplier",
	TotalBlockStatus:              "sap_inbound_delivery_header_data.TotalBlockStatus",
	TotalCreditCheckStatus:        "sap_inbound_delivery_header_data.TotalCreditCheckStatus",
	TotalNumberOfPackage:          "sap_inbound_delivery_header_data.TotalNumberOfPackage",
	TransactionCurrency:           "sap_inbound_delivery_header_data.TransactionCurrency",
	TransportationGroup:           "sap_inbound_delivery_header_data.TransportationGroup",
	TransportationPlanningDate:    "sap_inbound_delivery_header_data.TransportationPlanningDate",
	TransportationPlanningStatus:  "sap_inbound_delivery_header_data.TransportationPlanningStatus",
	TransportationPlanningTime:    "sap_inbound_delivery_header_data.TransportationPlanningTime",
	UnloadingPointName:            "sap_inbound_delivery_header_data.UnloadingPointName",
}

// Generated where

var SapInboundDeliveryHeaderDatumWhere = struct {
	DeliveryDocument              whereHelperstring
	ReceivingLocationTimeZone     whereHelpernull_String
	ActualDeliveryRoute           whereHelpernull_String
	ActualGoodsMovementDate       whereHelpernull_String
	ActualGoodsMovementTime       whereHelpernull_String
	BillingDocumentDate           whereHelpernull_String
	CompleteDeliveryIsDefined     whereHelpernull_Bool
	ConfirmationTime              whereHelpernull_String
	CreationDate                  whereHelpernull_String
	CreationTime                  whereHelpernull_String
	CustomerGroup                 whereHelpernull_String
	DeliveryBlockReason           whereHelpernull_String
	DeliveryDate                  whereHelpernull_String
	DeliveryDocumentBySupplier    whereHelpernull_String
	DeliveryDocumentType          whereHelpernull_String
	DeliveryIsInPlant             whereHelpernull_Bool
	DeliveryPriority              whereHelpernull_String
	DeliveryTime                  whereHelpernull_String
	DocumentDate                  whereHelpernull_String
	GoodsIssueOrReceiptSlipNumber whereHelpernull_String
	GoodsIssueTime                whereHelpernull_String
	HeaderBillgIncompletionStatus whereHelpernull_String
	HeaderBillingBlockReason      whereHelpernull_String
	HeaderDelivIncompletionStatus whereHelpernull_String
	HeaderGrossWeight             whereHelpernull_String
	HeaderNetWeight               whereHelpernull_String
	HeaderPackingIncompletionSts  whereHelpernull_String
	HeaderPickgIncompletionStatus whereHelpernull_String
	HeaderVolume                  whereHelpernull_String
	HeaderVolumeUnit              whereHelpernull_String
	HeaderWeightUnit              whereHelpernull_String
	IncotermsClassification       whereHelpernull_String
	IsExportDelivery              whereHelpernull_String
	LastChangeDate                whereHelpernull_String
	LoadingDate                   whereHelpernull_String
	LoadingPoint                  whereHelpernull_String
	LoadingTime                   whereHelpernull_String
	MeansOfTransport              whereHelpernull_String
	OrderCombinationIsAllowed     whereHelpernull_Bool
	OrderID                       whereHelpernull_String
	PickedItemsLocation           whereHelpernull_String
	PickingDate                   whereHelpernull_String
	PickingTime                   whereHelpernull_String
	PlannedGoodsIssueDate         whereHelpernull_String
	ProposedDeliveryRoute         whereHelpernull_String
	ReceivingPlant                whereHelpernull_String
	RouteSchedule                 whereHelpernull_String
	SalesDistrict                 whereHelpernull_String
	SalesOffice                   whereHelpernull_String
	SalesOrganization             whereHelpernull_String
	SDDocumentCategory            whereHelpernull_String
	ShipmentBlockReason           whereHelpernull_String
	ShippingCondition             whereHelpernull_String
	ShippingPoint                 whereHelpernull_String
	ShippingType                  whereHelpernull_String
	ShipToParty                   whereHelpernull_String
	SoldToParty                   whereHelpernull_String
	Supplier                      whereHelpernull_String
	TotalBlockStatus              whereHelpernull_String
	TotalCreditCheckStatus        whereHelpernull_String
	TotalNumberOfPackage          whereHelpernull_String
	TransactionCurrency           whereHelpernull_String
	TransportationGroup           whereHelpernull_String
	TransportationPlanningDate    whereHelpernull_String
	TransportationPlanningStatus  whereHelpernull_String
	TransportationPlanningTime    whereHelpernull_String
	UnloadingPointName            whereHelpernull_String
}{
	DeliveryDocument:              whereHelperstring{field: "`sap_inbound_delivery_header_data`.`DeliveryDocument`"},
	ReceivingLocationTimeZone:     whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ReceivingLocationTimeZone`"},
	ActualDeliveryRoute:           whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ActualDeliveryRoute`"},
	ActualGoodsMovementDate:       whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ActualGoodsMovementDate`"},
	ActualGoodsMovementTime:       whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ActualGoodsMovementTime`"},
	BillingDocumentDate:           whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`BillingDocumentDate`"},
	CompleteDeliveryIsDefined:     whereHelpernull_Bool{field: "`sap_inbound_delivery_header_data`.`CompleteDeliveryIsDefined`"},
	ConfirmationTime:              whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ConfirmationTime`"},
	CreationDate:                  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`CreationDate`"},
	CreationTime:                  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`CreationTime`"},
	CustomerGroup:                 whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`CustomerGroup`"},
	DeliveryBlockReason:           whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`DeliveryBlockReason`"},
	DeliveryDate:                  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`DeliveryDate`"},
	DeliveryDocumentBySupplier:    whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`DeliveryDocumentBySupplier`"},
	DeliveryDocumentType:          whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`DeliveryDocumentType`"},
	DeliveryIsInPlant:             whereHelpernull_Bool{field: "`sap_inbound_delivery_header_data`.`DeliveryIsInPlant`"},
	DeliveryPriority:              whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`DeliveryPriority`"},
	DeliveryTime:                  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`DeliveryTime`"},
	DocumentDate:                  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`DocumentDate`"},
	GoodsIssueOrReceiptSlipNumber: whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`GoodsIssueOrReceiptSlipNumber`"},
	GoodsIssueTime:                whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`GoodsIssueTime`"},
	HeaderBillgIncompletionStatus: whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderBillgIncompletionStatus`"},
	HeaderBillingBlockReason:      whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderBillingBlockReason`"},
	HeaderDelivIncompletionStatus: whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderDelivIncompletionStatus`"},
	HeaderGrossWeight:             whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderGrossWeight`"},
	HeaderNetWeight:               whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderNetWeight`"},
	HeaderPackingIncompletionSts:  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderPackingIncompletionSts`"},
	HeaderPickgIncompletionStatus: whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderPickgIncompletionStatus`"},
	HeaderVolume:                  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderVolume`"},
	HeaderVolumeUnit:              whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderVolumeUnit`"},
	HeaderWeightUnit:              whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`HeaderWeightUnit`"},
	IncotermsClassification:       whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`IncotermsClassification`"},
	IsExportDelivery:              whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`IsExportDelivery`"},
	LastChangeDate:                whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`LastChangeDate`"},
	LoadingDate:                   whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`LoadingDate`"},
	LoadingPoint:                  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`LoadingPoint`"},
	LoadingTime:                   whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`LoadingTime`"},
	MeansOfTransport:              whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`MeansOfTransport`"},
	OrderCombinationIsAllowed:     whereHelpernull_Bool{field: "`sap_inbound_delivery_header_data`.`OrderCombinationIsAllowed`"},
	OrderID:                       whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`OrderID`"},
	PickedItemsLocation:           whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`PickedItemsLocation`"},
	PickingDate:                   whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`PickingDate`"},
	PickingTime:                   whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`PickingTime`"},
	PlannedGoodsIssueDate:         whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`PlannedGoodsIssueDate`"},
	ProposedDeliveryRoute:         whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ProposedDeliveryRoute`"},
	ReceivingPlant:                whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ReceivingPlant`"},
	RouteSchedule:                 whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`RouteSchedule`"},
	SalesDistrict:                 whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`SalesDistrict`"},
	SalesOffice:                   whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`SalesOffice`"},
	SalesOrganization:             whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`SalesOrganization`"},
	SDDocumentCategory:            whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`SDDocumentCategory`"},
	ShipmentBlockReason:           whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ShipmentBlockReason`"},
	ShippingCondition:             whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ShippingCondition`"},
	ShippingPoint:                 whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ShippingPoint`"},
	ShippingType:                  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ShippingType`"},
	ShipToParty:                   whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`ShipToParty`"},
	SoldToParty:                   whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`SoldToParty`"},
	Supplier:                      whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`Supplier`"},
	TotalBlockStatus:              whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`TotalBlockStatus`"},
	TotalCreditCheckStatus:        whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`TotalCreditCheckStatus`"},
	TotalNumberOfPackage:          whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`TotalNumberOfPackage`"},
	TransactionCurrency:           whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`TransactionCurrency`"},
	TransportationGroup:           whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`TransportationGroup`"},
	TransportationPlanningDate:    whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`TransportationPlanningDate`"},
	TransportationPlanningStatus:  whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`TransportationPlanningStatus`"},
	TransportationPlanningTime:    whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`TransportationPlanningTime`"},
	UnloadingPointName:            whereHelpernull_String{field: "`sap_inbound_delivery_header_data`.`UnloadingPointName`"},
}

// SapInboundDeliveryHeaderDatumRels is where relationship names are stored.
var SapInboundDeliveryHeaderDatumRels = struct {
	DeliveryDocumentSapInboundDeliveryItemData string
	SDDocumentSapInboundDeliveryPartnerData    string
}{
	DeliveryDocumentSapInboundDeliveryItemData: "DeliveryDocumentSapInboundDeliveryItemData",
	SDDocumentSapInboundDeliveryPartnerData:    "SDDocumentSapInboundDeliveryPartnerData",
}

// sapInboundDeliveryHeaderDatumR is where relationships are stored.
type sapInboundDeliveryHeaderDatumR struct {
	DeliveryDocumentSapInboundDeliveryItemData SapInboundDeliveryItemDatumSlice    `boil:"DeliveryDocumentSapInboundDeliveryItemData" json:"DeliveryDocumentSapInboundDeliveryItemData" toml:"DeliveryDocumentSapInboundDeliveryItemData" yaml:"DeliveryDocumentSapInboundDeliveryItemData"`
	SDDocumentSapInboundDeliveryPartnerData    SapInboundDeliveryPartnerDatumSlice `boil:"SDDocumentSapInboundDeliveryPartnerData" json:"SDDocumentSapInboundDeliveryPartnerData" toml:"SDDocumentSapInboundDeliveryPartnerData" yaml:"SDDocumentSapInboundDeliveryPartnerData"`
}

// NewStruct creates a new relationship struct
func (*sapInboundDeliveryHeaderDatumR) NewStruct() *sapInboundDeliveryHeaderDatumR {
	return &sapInboundDeliveryHeaderDatumR{}
}

// sapInboundDeliveryHeaderDatumL is where Load methods for each relationship are stored.
type sapInboundDeliveryHeaderDatumL struct{}

var (
	sapInboundDeliveryHeaderDatumAllColumns            = []string{"DeliveryDocument", "ReceivingLocationTimeZone", "ActualDeliveryRoute", "ActualGoodsMovementDate", "ActualGoodsMovementTime", "BillingDocumentDate", "CompleteDeliveryIsDefined", "ConfirmationTime", "CreationDate", "CreationTime", "CustomerGroup", "DeliveryBlockReason", "DeliveryDate", "DeliveryDocumentBySupplier", "DeliveryDocumentType", "DeliveryIsInPlant", "DeliveryPriority", "DeliveryTime", "DocumentDate", "GoodsIssueOrReceiptSlipNumber", "GoodsIssueTime", "HeaderBillgIncompletionStatus", "HeaderBillingBlockReason", "HeaderDelivIncompletionStatus", "HeaderGrossWeight", "HeaderNetWeight", "HeaderPackingIncompletionSts", "HeaderPickgIncompletionStatus", "HeaderVolume", "HeaderVolumeUnit", "HeaderWeightUnit", "IncotermsClassification", "IsExportDelivery", "LastChangeDate", "LoadingDate", "LoadingPoint", "LoadingTime", "MeansOfTransport", "OrderCombinationIsAllowed", "OrderID", "PickedItemsLocation", "PickingDate", "PickingTime", "PlannedGoodsIssueDate", "ProposedDeliveryRoute", "ReceivingPlant", "RouteSchedule", "SalesDistrict", "SalesOffice", "SalesOrganization", "SDDocumentCategory", "ShipmentBlockReason", "ShippingCondition", "ShippingPoint", "ShippingType", "ShipToParty", "SoldToParty", "Supplier", "TotalBlockStatus", "TotalCreditCheckStatus", "TotalNumberOfPackage", "TransactionCurrency", "TransportationGroup", "TransportationPlanningDate", "TransportationPlanningStatus", "TransportationPlanningTime", "UnloadingPointName"}
	sapInboundDeliveryHeaderDatumColumnsWithoutDefault = []string{"DeliveryDocument", "ReceivingLocationTimeZone", "ActualDeliveryRoute", "ActualGoodsMovementDate", "ActualGoodsMovementTime", "BillingDocumentDate", "CompleteDeliveryIsDefined", "ConfirmationTime", "CreationDate", "CreationTime", "CustomerGroup", "DeliveryBlockReason", "DeliveryDate", "DeliveryDocumentBySupplier", "DeliveryDocumentType", "DeliveryIsInPlant", "DeliveryPriority", "DeliveryTime", "DocumentDate", "GoodsIssueOrReceiptSlipNumber", "GoodsIssueTime", "HeaderBillgIncompletionStatus", "HeaderBillingBlockReason", "HeaderDelivIncompletionStatus", "HeaderGrossWeight", "HeaderNetWeight", "HeaderPackingIncompletionSts", "HeaderPickgIncompletionStatus", "HeaderVolume", "HeaderVolumeUnit", "HeaderWeightUnit", "IncotermsClassification", "IsExportDelivery", "LastChangeDate", "LoadingDate", "LoadingPoint", "LoadingTime", "MeansOfTransport", "OrderCombinationIsAllowed", "OrderID", "PickedItemsLocation", "PickingDate", "PickingTime", "PlannedGoodsIssueDate", "ProposedDeliveryRoute", "ReceivingPlant", "RouteSchedule", "SalesDistrict", "SalesOffice", "SalesOrganization", "SDDocumentCategory", "ShipmentBlockReason", "ShippingCondition", "ShippingPoint", "ShippingType", "ShipToParty", "SoldToParty", "Supplier", "TotalBlockStatus", "TotalCreditCheckStatus", "TotalNumberOfPackage", "TransactionCurrency", "TransportationGroup", "TransportationPlanningDate", "TransportationPlanningStatus", "TransportationPlanningTime", "UnloadingPointName"}
	sapInboundDeliveryHeaderDatumColumnsWithDefault    = []string{}
	sapInboundDeliveryHeaderDatumPrimaryKeyColumns     = []string{"DeliveryDocument"}
	sapInboundDeliveryHeaderDatumGeneratedColumns      = []string{}
)

type (
	// SapInboundDeliveryHeaderDatumSlice is an alias for a slice of pointers to SapInboundDeliveryHeaderDatum.
	// This should almost always be used instead of []SapInboundDeliveryHeaderDatum.
	SapInboundDeliveryHeaderDatumSlice []*SapInboundDeliveryHeaderDatum
	// SapInboundDeliveryHeaderDatumHook is the signature for custom SapInboundDeliveryHeaderDatum hook methods
	SapInboundDeliveryHeaderDatumHook func(context.Context, boil.ContextExecutor, *SapInboundDeliveryHeaderDatum) error

	sapInboundDeliveryHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapInboundDeliveryHeaderDatumType                 = reflect.TypeOf(&SapInboundDeliveryHeaderDatum{})
	sapInboundDeliveryHeaderDatumMapping              = queries.MakeStructMapping(sapInboundDeliveryHeaderDatumType)
	sapInboundDeliveryHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(sapInboundDeliveryHeaderDatumType, sapInboundDeliveryHeaderDatumMapping, sapInboundDeliveryHeaderDatumPrimaryKeyColumns)
	sapInboundDeliveryHeaderDatumInsertCacheMut       sync.RWMutex
	sapInboundDeliveryHeaderDatumInsertCache          = make(map[string]insertCache)
	sapInboundDeliveryHeaderDatumUpdateCacheMut       sync.RWMutex
	sapInboundDeliveryHeaderDatumUpdateCache          = make(map[string]updateCache)
	sapInboundDeliveryHeaderDatumUpsertCacheMut       sync.RWMutex
	sapInboundDeliveryHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapInboundDeliveryHeaderDatumAfterSelectHooks []SapInboundDeliveryHeaderDatumHook

var sapInboundDeliveryHeaderDatumBeforeInsertHooks []SapInboundDeliveryHeaderDatumHook
var sapInboundDeliveryHeaderDatumAfterInsertHooks []SapInboundDeliveryHeaderDatumHook

var sapInboundDeliveryHeaderDatumBeforeUpdateHooks []SapInboundDeliveryHeaderDatumHook
var sapInboundDeliveryHeaderDatumAfterUpdateHooks []SapInboundDeliveryHeaderDatumHook

var sapInboundDeliveryHeaderDatumBeforeDeleteHooks []SapInboundDeliveryHeaderDatumHook
var sapInboundDeliveryHeaderDatumAfterDeleteHooks []SapInboundDeliveryHeaderDatumHook

var sapInboundDeliveryHeaderDatumBeforeUpsertHooks []SapInboundDeliveryHeaderDatumHook
var sapInboundDeliveryHeaderDatumAfterUpsertHooks []SapInboundDeliveryHeaderDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapInboundDeliveryHeaderDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapInboundDeliveryHeaderDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapInboundDeliveryHeaderDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapInboundDeliveryHeaderDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapInboundDeliveryHeaderDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapInboundDeliveryHeaderDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapInboundDeliveryHeaderDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapInboundDeliveryHeaderDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapInboundDeliveryHeaderDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapInboundDeliveryHeaderDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapInboundDeliveryHeaderDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapInboundDeliveryHeaderDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapInboundDeliveryHeaderDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapInboundDeliveryHeaderDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapInboundDeliveryHeaderDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapInboundDeliveryHeaderDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapInboundDeliveryHeaderDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapInboundDeliveryHeaderDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapInboundDeliveryHeaderDatumHook registers your hook function for all future operations.
func AddSapInboundDeliveryHeaderDatumHook(hookPoint boil.HookPoint, sapInboundDeliveryHeaderDatumHook SapInboundDeliveryHeaderDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapInboundDeliveryHeaderDatumAfterSelectHooks = append(sapInboundDeliveryHeaderDatumAfterSelectHooks, sapInboundDeliveryHeaderDatumHook)
	case boil.BeforeInsertHook:
		sapInboundDeliveryHeaderDatumBeforeInsertHooks = append(sapInboundDeliveryHeaderDatumBeforeInsertHooks, sapInboundDeliveryHeaderDatumHook)
	case boil.AfterInsertHook:
		sapInboundDeliveryHeaderDatumAfterInsertHooks = append(sapInboundDeliveryHeaderDatumAfterInsertHooks, sapInboundDeliveryHeaderDatumHook)
	case boil.BeforeUpdateHook:
		sapInboundDeliveryHeaderDatumBeforeUpdateHooks = append(sapInboundDeliveryHeaderDatumBeforeUpdateHooks, sapInboundDeliveryHeaderDatumHook)
	case boil.AfterUpdateHook:
		sapInboundDeliveryHeaderDatumAfterUpdateHooks = append(sapInboundDeliveryHeaderDatumAfterUpdateHooks, sapInboundDeliveryHeaderDatumHook)
	case boil.BeforeDeleteHook:
		sapInboundDeliveryHeaderDatumBeforeDeleteHooks = append(sapInboundDeliveryHeaderDatumBeforeDeleteHooks, sapInboundDeliveryHeaderDatumHook)
	case boil.AfterDeleteHook:
		sapInboundDeliveryHeaderDatumAfterDeleteHooks = append(sapInboundDeliveryHeaderDatumAfterDeleteHooks, sapInboundDeliveryHeaderDatumHook)
	case boil.BeforeUpsertHook:
		sapInboundDeliveryHeaderDatumBeforeUpsertHooks = append(sapInboundDeliveryHeaderDatumBeforeUpsertHooks, sapInboundDeliveryHeaderDatumHook)
	case boil.AfterUpsertHook:
		sapInboundDeliveryHeaderDatumAfterUpsertHooks = append(sapInboundDeliveryHeaderDatumAfterUpsertHooks, sapInboundDeliveryHeaderDatumHook)
	}
}

// One returns a single sapInboundDeliveryHeaderDatum record from the query.
func (q sapInboundDeliveryHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapInboundDeliveryHeaderDatum, error) {
	o := &SapInboundDeliveryHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_inbound_delivery_header_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapInboundDeliveryHeaderDatum records from the query.
func (q sapInboundDeliveryHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapInboundDeliveryHeaderDatumSlice, error) {
	var o []*SapInboundDeliveryHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapInboundDeliveryHeaderDatum slice")
	}

	if len(sapInboundDeliveryHeaderDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapInboundDeliveryHeaderDatum records in the query.
func (q sapInboundDeliveryHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_inbound_delivery_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapInboundDeliveryHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_inbound_delivery_header_data exists")
	}

	return count > 0, nil
}

// DeliveryDocumentSapInboundDeliveryItemData retrieves all the sap_inbound_delivery_item_datum's SapInboundDeliveryItemData with an executor via DeliveryDocument column.
func (o *SapInboundDeliveryHeaderDatum) DeliveryDocumentSapInboundDeliveryItemData(mods ...qm.QueryMod) sapInboundDeliveryItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_inbound_delivery_item_data`.`DeliveryDocument`=?", o.DeliveryDocument),
	)

	query := SapInboundDeliveryItemData(queryMods...)
	queries.SetFrom(query.Query, "`sap_inbound_delivery_item_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_inbound_delivery_item_data`.*"})
	}

	return query
}

// SDDocumentSapInboundDeliveryPartnerData retrieves all the sap_inbound_delivery_partner_datum's SapInboundDeliveryPartnerData with an executor via SDDocument column.
func (o *SapInboundDeliveryHeaderDatum) SDDocumentSapInboundDeliveryPartnerData(mods ...qm.QueryMod) sapInboundDeliveryPartnerDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_inbound_delivery_partner_data`.`SDDocument`=?", o.DeliveryDocument),
	)

	query := SapInboundDeliveryPartnerData(queryMods...)
	queries.SetFrom(query.Query, "`sap_inbound_delivery_partner_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_inbound_delivery_partner_data`.*"})
	}

	return query
}

// LoadDeliveryDocumentSapInboundDeliveryItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapInboundDeliveryHeaderDatumL) LoadDeliveryDocumentSapInboundDeliveryItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapInboundDeliveryHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapInboundDeliveryHeaderDatum
	var object *SapInboundDeliveryHeaderDatum

	if singular {
		object = maybeSapInboundDeliveryHeaderDatum.(*SapInboundDeliveryHeaderDatum)
	} else {
		slice = *maybeSapInboundDeliveryHeaderDatum.(*[]*SapInboundDeliveryHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapInboundDeliveryHeaderDatumR{}
		}
		args = append(args, object.DeliveryDocument)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapInboundDeliveryHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryDocument {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryDocument)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_inbound_delivery_item_data`),
		qm.WhereIn(`sap_inbound_delivery_item_data.DeliveryDocument in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_inbound_delivery_item_data")
	}

	var resultSlice []*SapInboundDeliveryItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_inbound_delivery_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_inbound_delivery_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_inbound_delivery_item_data")
	}

	if len(sapInboundDeliveryItemDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DeliveryDocumentSapInboundDeliveryItemData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapInboundDeliveryItemDatumR{}
			}
			foreign.R.DeliveryDocumentSapInboundDeliveryHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.DeliveryDocument == foreign.DeliveryDocument {
				local.R.DeliveryDocumentSapInboundDeliveryItemData = append(local.R.DeliveryDocumentSapInboundDeliveryItemData, foreign)
				if foreign.R == nil {
					foreign.R = &sapInboundDeliveryItemDatumR{}
				}
				foreign.R.DeliveryDocumentSapInboundDeliveryHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// LoadSDDocumentSapInboundDeliveryPartnerData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapInboundDeliveryHeaderDatumL) LoadSDDocumentSapInboundDeliveryPartnerData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapInboundDeliveryHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapInboundDeliveryHeaderDatum
	var object *SapInboundDeliveryHeaderDatum

	if singular {
		object = maybeSapInboundDeliveryHeaderDatum.(*SapInboundDeliveryHeaderDatum)
	} else {
		slice = *maybeSapInboundDeliveryHeaderDatum.(*[]*SapInboundDeliveryHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapInboundDeliveryHeaderDatumR{}
		}
		args = append(args, object.DeliveryDocument)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapInboundDeliveryHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryDocument {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryDocument)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_inbound_delivery_partner_data`),
		qm.WhereIn(`sap_inbound_delivery_partner_data.SDDocument in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_inbound_delivery_partner_data")
	}

	var resultSlice []*SapInboundDeliveryPartnerDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_inbound_delivery_partner_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_inbound_delivery_partner_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_inbound_delivery_partner_data")
	}

	if len(sapInboundDeliveryPartnerDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SDDocumentSapInboundDeliveryPartnerData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapInboundDeliveryPartnerDatumR{}
			}
			foreign.R.SDDocumentSapInboundDeliveryHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.DeliveryDocument == foreign.SDDocument {
				local.R.SDDocumentSapInboundDeliveryPartnerData = append(local.R.SDDocumentSapInboundDeliveryPartnerData, foreign)
				if foreign.R == nil {
					foreign.R = &sapInboundDeliveryPartnerDatumR{}
				}
				foreign.R.SDDocumentSapInboundDeliveryHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// AddDeliveryDocumentSapInboundDeliveryItemData adds the given related objects to the existing relationships
// of the sap_inbound_delivery_header_datum, optionally inserting them as new records.
// Appends related to o.R.DeliveryDocumentSapInboundDeliveryItemData.
// Sets related.R.DeliveryDocumentSapInboundDeliveryHeaderDatum appropriately.
func (o *SapInboundDeliveryHeaderDatum) AddDeliveryDocumentSapInboundDeliveryItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapInboundDeliveryItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeliveryDocument = o.DeliveryDocument
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_inbound_delivery_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"DeliveryDocument"}),
				strmangle.WhereClause("`", "`", 0, sapInboundDeliveryItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.DeliveryDocument, rel.DeliveryDocument, rel.DeliveryDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeliveryDocument = o.DeliveryDocument
		}
	}

	if o.R == nil {
		o.R = &sapInboundDeliveryHeaderDatumR{
			DeliveryDocumentSapInboundDeliveryItemData: related,
		}
	} else {
		o.R.DeliveryDocumentSapInboundDeliveryItemData = append(o.R.DeliveryDocumentSapInboundDeliveryItemData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapInboundDeliveryItemDatumR{
				DeliveryDocumentSapInboundDeliveryHeaderDatum: o,
			}
		} else {
			rel.R.DeliveryDocumentSapInboundDeliveryHeaderDatum = o
		}
	}
	return nil
}

// AddSDDocumentSapInboundDeliveryPartnerData adds the given related objects to the existing relationships
// of the sap_inbound_delivery_header_datum, optionally inserting them as new records.
// Appends related to o.R.SDDocumentSapInboundDeliveryPartnerData.
// Sets related.R.SDDocumentSapInboundDeliveryHeaderDatum appropriately.
func (o *SapInboundDeliveryHeaderDatum) AddSDDocumentSapInboundDeliveryPartnerData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapInboundDeliveryPartnerDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SDDocument = o.DeliveryDocument
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_inbound_delivery_partner_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"SDDocument"}),
				strmangle.WhereClause("`", "`", 0, sapInboundDeliveryPartnerDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.DeliveryDocument, rel.SDDocument, rel.SDDocumentItem, rel.PartnerFunction}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SDDocument = o.DeliveryDocument
		}
	}

	if o.R == nil {
		o.R = &sapInboundDeliveryHeaderDatumR{
			SDDocumentSapInboundDeliveryPartnerData: related,
		}
	} else {
		o.R.SDDocumentSapInboundDeliveryPartnerData = append(o.R.SDDocumentSapInboundDeliveryPartnerData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapInboundDeliveryPartnerDatumR{
				SDDocumentSapInboundDeliveryHeaderDatum: o,
			}
		} else {
			rel.R.SDDocumentSapInboundDeliveryHeaderDatum = o
		}
	}
	return nil
}

// SapInboundDeliveryHeaderData retrieves all the records using an executor.
func SapInboundDeliveryHeaderData(mods ...qm.QueryMod) sapInboundDeliveryHeaderDatumQuery {
	mods = append(mods, qm.From("`sap_inbound_delivery_header_data`"))
	return sapInboundDeliveryHeaderDatumQuery{NewQuery(mods...)}
}

// FindSapInboundDeliveryHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapInboundDeliveryHeaderDatum(ctx context.Context, exec boil.ContextExecutor, deliveryDocument string, selectCols ...string) (*SapInboundDeliveryHeaderDatum, error) {
	sapInboundDeliveryHeaderDatumObj := &SapInboundDeliveryHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_inbound_delivery_header_data` where `DeliveryDocument`=?", sel,
	)

	q := queries.Raw(query, deliveryDocument)

	err := q.Bind(ctx, exec, sapInboundDeliveryHeaderDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_inbound_delivery_header_data")
	}

	if err = sapInboundDeliveryHeaderDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapInboundDeliveryHeaderDatumObj, err
	}

	return sapInboundDeliveryHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapInboundDeliveryHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_inbound_delivery_header_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapInboundDeliveryHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapInboundDeliveryHeaderDatumInsertCacheMut.RLock()
	cache, cached := sapInboundDeliveryHeaderDatumInsertCache[key]
	sapInboundDeliveryHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapInboundDeliveryHeaderDatumAllColumns,
			sapInboundDeliveryHeaderDatumColumnsWithDefault,
			sapInboundDeliveryHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapInboundDeliveryHeaderDatumType, sapInboundDeliveryHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapInboundDeliveryHeaderDatumType, sapInboundDeliveryHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_inbound_delivery_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_inbound_delivery_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_inbound_delivery_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapInboundDeliveryHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_inbound_delivery_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.DeliveryDocument,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_inbound_delivery_header_data")
	}

CacheNoHooks:
	if !cached {
		sapInboundDeliveryHeaderDatumInsertCacheMut.Lock()
		sapInboundDeliveryHeaderDatumInsertCache[key] = cache
		sapInboundDeliveryHeaderDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapInboundDeliveryHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapInboundDeliveryHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapInboundDeliveryHeaderDatumUpdateCacheMut.RLock()
	cache, cached := sapInboundDeliveryHeaderDatumUpdateCache[key]
	sapInboundDeliveryHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapInboundDeliveryHeaderDatumAllColumns,
			sapInboundDeliveryHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_inbound_delivery_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_inbound_delivery_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapInboundDeliveryHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapInboundDeliveryHeaderDatumType, sapInboundDeliveryHeaderDatumMapping, append(wl, sapInboundDeliveryHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_inbound_delivery_header_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_inbound_delivery_header_data")
	}

	if !cached {
		sapInboundDeliveryHeaderDatumUpdateCacheMut.Lock()
		sapInboundDeliveryHeaderDatumUpdateCache[key] = cache
		sapInboundDeliveryHeaderDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapInboundDeliveryHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_inbound_delivery_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_inbound_delivery_header_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapInboundDeliveryHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapInboundDeliveryHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_inbound_delivery_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapInboundDeliveryHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapInboundDeliveryHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapInboundDeliveryHeaderDatum")
	}
	return rowsAff, nil
}

var mySQLSapInboundDeliveryHeaderDatumUniqueColumns = []string{
	"DeliveryDocument",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapInboundDeliveryHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_inbound_delivery_header_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapInboundDeliveryHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapInboundDeliveryHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapInboundDeliveryHeaderDatumUpsertCacheMut.RLock()
	cache, cached := sapInboundDeliveryHeaderDatumUpsertCache[key]
	sapInboundDeliveryHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapInboundDeliveryHeaderDatumAllColumns,
			sapInboundDeliveryHeaderDatumColumnsWithDefault,
			sapInboundDeliveryHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapInboundDeliveryHeaderDatumAllColumns,
			sapInboundDeliveryHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_inbound_delivery_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_inbound_delivery_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_inbound_delivery_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapInboundDeliveryHeaderDatumType, sapInboundDeliveryHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapInboundDeliveryHeaderDatumType, sapInboundDeliveryHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_inbound_delivery_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapInboundDeliveryHeaderDatumType, sapInboundDeliveryHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_inbound_delivery_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_inbound_delivery_header_data")
	}

CacheNoHooks:
	if !cached {
		sapInboundDeliveryHeaderDatumUpsertCacheMut.Lock()
		sapInboundDeliveryHeaderDatumUpsertCache[key] = cache
		sapInboundDeliveryHeaderDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapInboundDeliveryHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapInboundDeliveryHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapInboundDeliveryHeaderDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapInboundDeliveryHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_inbound_delivery_header_data` WHERE `DeliveryDocument`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_inbound_delivery_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_inbound_delivery_header_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapInboundDeliveryHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapInboundDeliveryHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_inbound_delivery_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_inbound_delivery_header_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapInboundDeliveryHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapInboundDeliveryHeaderDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapInboundDeliveryHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_inbound_delivery_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapInboundDeliveryHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapInboundDeliveryHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_inbound_delivery_header_data")
	}

	if len(sapInboundDeliveryHeaderDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapInboundDeliveryHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapInboundDeliveryHeaderDatum(ctx, exec, o.DeliveryDocument)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapInboundDeliveryHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapInboundDeliveryHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapInboundDeliveryHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_inbound_delivery_header_data`.* FROM `sap_inbound_delivery_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapInboundDeliveryHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapInboundDeliveryHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// SapInboundDeliveryHeaderDatumExists checks if the SapInboundDeliveryHeaderDatum row exists.
func SapInboundDeliveryHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, deliveryDocument string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_inbound_delivery_header_data` where `DeliveryDocument`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, deliveryDocument)
	}
	row := exec.QueryRowContext(ctx, sql, deliveryDocument)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_inbound_delivery_header_data exists")
	}

	return exists, nil
}
