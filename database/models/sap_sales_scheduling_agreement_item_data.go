// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapSalesSchedulingAgreementItemDatum is an object representing the database table.
type SapSalesSchedulingAgreementItemDatum struct {
	SalesSchedulingAgreement       string      `boil:"SalesSchedulingAgreement" json:"SalesSchedulingAgreement" toml:"SalesSchedulingAgreement" yaml:"SalesSchedulingAgreement"`
	SalesSchedulingAgreementItem   string      `boil:"SalesSchedulingAgreementItem" json:"SalesSchedulingAgreementItem" toml:"SalesSchedulingAgreementItem" yaml:"SalesSchedulingAgreementItem"`
	SalesSchedgAgrmtItemCategory   null.String `boil:"SalesSchedgAgrmtItemCategory" json:"SalesSchedgAgrmtItemCategory,omitempty" toml:"SalesSchedgAgrmtItemCategory" yaml:"SalesSchedgAgrmtItemCategory,omitempty"`
	LastChangeDate                 null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	Material                       null.String `boil:"Material" json:"Material,omitempty" toml:"Material" yaml:"Material,omitempty"`
	MaterialByCustomer             null.String `boil:"MaterialByCustomer" json:"MaterialByCustomer,omitempty" toml:"MaterialByCustomer" yaml:"MaterialByCustomer,omitempty"`
	MaterialGroup                  null.String `boil:"MaterialGroup" json:"MaterialGroup,omitempty" toml:"MaterialGroup" yaml:"MaterialGroup,omitempty"`
	MaterialPricingGroup           null.String `boil:"MaterialPricingGroup" json:"MaterialPricingGroup,omitempty" toml:"MaterialPricingGroup" yaml:"MaterialPricingGroup,omitempty"`
	ProductionPlant                null.String `boil:"ProductionPlant" json:"ProductionPlant,omitempty" toml:"ProductionPlant" yaml:"ProductionPlant,omitempty"`
	StorageLocation                null.String `boil:"StorageLocation" json:"StorageLocation,omitempty" toml:"StorageLocation" yaml:"StorageLocation,omitempty"`
	SalesSchedgAgrmtItemText       null.String `boil:"SalesSchedgAgrmtItemText" json:"SalesSchedgAgrmtItemText,omitempty" toml:"SalesSchedgAgrmtItemText" yaml:"SalesSchedgAgrmtItemText,omitempty"`
	PurchaseOrderByCustomer        null.String `boil:"PurchaseOrderByCustomer" json:"PurchaseOrderByCustomer,omitempty" toml:"PurchaseOrderByCustomer" yaml:"PurchaseOrderByCustomer,omitempty"`
	OrderQuantity                  null.String `boil:"OrderQuantity" json:"OrderQuantity,omitempty" toml:"OrderQuantity" yaml:"OrderQuantity,omitempty"`
	OrderQuantityUnit              null.String `boil:"OrderQuantityUnit" json:"OrderQuantityUnit,omitempty" toml:"OrderQuantityUnit" yaml:"OrderQuantityUnit,omitempty"`
	TargetQuantity                 null.String `boil:"TargetQuantity" json:"TargetQuantity,omitempty" toml:"TargetQuantity" yaml:"TargetQuantity,omitempty"`
	TargetQuantityUnit             null.String `boil:"TargetQuantityUnit" json:"TargetQuantityUnit,omitempty" toml:"TargetQuantityUnit" yaml:"TargetQuantityUnit,omitempty"`
	SalesDocumentRjcnReason        null.String `boil:"SalesDocumentRjcnReason" json:"SalesDocumentRjcnReason,omitempty" toml:"SalesDocumentRjcnReason" yaml:"SalesDocumentRjcnReason,omitempty"`
	NetAmount                      null.String `boil:"NetAmount" json:"NetAmount,omitempty" toml:"NetAmount" yaml:"NetAmount,omitempty"`
	NetPriceAmount                 null.String `boil:"NetPriceAmount" json:"NetPriceAmount,omitempty" toml:"NetPriceAmount" yaml:"NetPriceAmount,omitempty"`
	NetPriceQuantity               null.String `boil:"NetPriceQuantity" json:"NetPriceQuantity,omitempty" toml:"NetPriceQuantity" yaml:"NetPriceQuantity,omitempty"`
	NetPriceQuantityUnit           null.String `boil:"NetPriceQuantityUnit" json:"NetPriceQuantityUnit,omitempty" toml:"NetPriceQuantityUnit" yaml:"NetPriceQuantityUnit,omitempty"`
	TransactionCurrency            null.String `boil:"TransactionCurrency" json:"TransactionCurrency,omitempty" toml:"TransactionCurrency" yaml:"TransactionCurrency,omitempty"`
	PricingDate                    null.String `boil:"PricingDate" json:"PricingDate,omitempty" toml:"PricingDate" yaml:"PricingDate,omitempty"`
	ShippingPoint                  null.String `boil:"ShippingPoint" json:"ShippingPoint,omitempty" toml:"ShippingPoint" yaml:"ShippingPoint,omitempty"`
	ShippingType                   null.String `boil:"ShippingType" json:"ShippingType,omitempty" toml:"ShippingType" yaml:"ShippingType,omitempty"`
	DeliveryPriority               null.String `boil:"DeliveryPriority" json:"DeliveryPriority,omitempty" toml:"DeliveryPriority" yaml:"DeliveryPriority,omitempty"`
	IncotermsClassification        null.String `boil:"IncotermsClassification" json:"IncotermsClassification,omitempty" toml:"IncotermsClassification" yaml:"IncotermsClassification,omitempty"`
	CustomerPaymentTerms           null.String `boil:"CustomerPaymentTerms" json:"CustomerPaymentTerms,omitempty" toml:"CustomerPaymentTerms" yaml:"CustomerPaymentTerms,omitempty"`
	ItemBillingBlockReason         null.String `boil:"ItemBillingBlockReason" json:"ItemBillingBlockReason,omitempty" toml:"ItemBillingBlockReason" yaml:"ItemBillingBlockReason,omitempty"`
	SDProcessStatus                null.String `boil:"SDProcessStatus" json:"SDProcessStatus,omitempty" toml:"SDProcessStatus" yaml:"SDProcessStatus,omitempty"`
	DeliveryStatus                 null.String `boil:"DeliveryStatus" json:"DeliveryStatus,omitempty" toml:"DeliveryStatus" yaml:"DeliveryStatus,omitempty"`
	ItemGeneralIncompletionStatus  null.String `boil:"ItemGeneralIncompletionStatus" json:"ItemGeneralIncompletionStatus,omitempty" toml:"ItemGeneralIncompletionStatus" yaml:"ItemGeneralIncompletionStatus,omitempty"`
	ItemBillingIncompletionStatus  null.String `boil:"ItemBillingIncompletionStatus" json:"ItemBillingIncompletionStatus,omitempty" toml:"ItemBillingIncompletionStatus" yaml:"ItemBillingIncompletionStatus,omitempty"`
	ItemDeliveryIncompletionStatus null.String `boil:"ItemDeliveryIncompletionStatus" json:"ItemDeliveryIncompletionStatus,omitempty" toml:"ItemDeliveryIncompletionStatus" yaml:"ItemDeliveryIncompletionStatus,omitempty"`

	R *sapSalesSchedulingAgreementItemDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapSalesSchedulingAgreementItemDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapSalesSchedulingAgreementItemDatumColumns = struct {
	SalesSchedulingAgreement       string
	SalesSchedulingAgreementItem   string
	SalesSchedgAgrmtItemCategory   string
	LastChangeDate                 string
	Material                       string
	MaterialByCustomer             string
	MaterialGroup                  string
	MaterialPricingGroup           string
	ProductionPlant                string
	StorageLocation                string
	SalesSchedgAgrmtItemText       string
	PurchaseOrderByCustomer        string
	OrderQuantity                  string
	OrderQuantityUnit              string
	TargetQuantity                 string
	TargetQuantityUnit             string
	SalesDocumentRjcnReason        string
	NetAmount                      string
	NetPriceAmount                 string
	NetPriceQuantity               string
	NetPriceQuantityUnit           string
	TransactionCurrency            string
	PricingDate                    string
	ShippingPoint                  string
	ShippingType                   string
	DeliveryPriority               string
	IncotermsClassification        string
	CustomerPaymentTerms           string
	ItemBillingBlockReason         string
	SDProcessStatus                string
	DeliveryStatus                 string
	ItemGeneralIncompletionStatus  string
	ItemBillingIncompletionStatus  string
	ItemDeliveryIncompletionStatus string
}{
	SalesSchedulingAgreement:       "SalesSchedulingAgreement",
	SalesSchedulingAgreementItem:   "SalesSchedulingAgreementItem",
	SalesSchedgAgrmtItemCategory:   "SalesSchedgAgrmtItemCategory",
	LastChangeDate:                 "LastChangeDate",
	Material:                       "Material",
	MaterialByCustomer:             "MaterialByCustomer",
	MaterialGroup:                  "MaterialGroup",
	MaterialPricingGroup:           "MaterialPricingGroup",
	ProductionPlant:                "ProductionPlant",
	StorageLocation:                "StorageLocation",
	SalesSchedgAgrmtItemText:       "SalesSchedgAgrmtItemText",
	PurchaseOrderByCustomer:        "PurchaseOrderByCustomer",
	OrderQuantity:                  "OrderQuantity",
	OrderQuantityUnit:              "OrderQuantityUnit",
	TargetQuantity:                 "TargetQuantity",
	TargetQuantityUnit:             "TargetQuantityUnit",
	SalesDocumentRjcnReason:        "SalesDocumentRjcnReason",
	NetAmount:                      "NetAmount",
	NetPriceAmount:                 "NetPriceAmount",
	NetPriceQuantity:               "NetPriceQuantity",
	NetPriceQuantityUnit:           "NetPriceQuantityUnit",
	TransactionCurrency:            "TransactionCurrency",
	PricingDate:                    "PricingDate",
	ShippingPoint:                  "ShippingPoint",
	ShippingType:                   "ShippingType",
	DeliveryPriority:               "DeliveryPriority",
	IncotermsClassification:        "IncotermsClassification",
	CustomerPaymentTerms:           "CustomerPaymentTerms",
	ItemBillingBlockReason:         "ItemBillingBlockReason",
	SDProcessStatus:                "SDProcessStatus",
	DeliveryStatus:                 "DeliveryStatus",
	ItemGeneralIncompletionStatus:  "ItemGeneralIncompletionStatus",
	ItemBillingIncompletionStatus:  "ItemBillingIncompletionStatus",
	ItemDeliveryIncompletionStatus: "ItemDeliveryIncompletionStatus",
}

var SapSalesSchedulingAgreementItemDatumTableColumns = struct {
	SalesSchedulingAgreement       string
	SalesSchedulingAgreementItem   string
	SalesSchedgAgrmtItemCategory   string
	LastChangeDate                 string
	Material                       string
	MaterialByCustomer             string
	MaterialGroup                  string
	MaterialPricingGroup           string
	ProductionPlant                string
	StorageLocation                string
	SalesSchedgAgrmtItemText       string
	PurchaseOrderByCustomer        string
	OrderQuantity                  string
	OrderQuantityUnit              string
	TargetQuantity                 string
	TargetQuantityUnit             string
	SalesDocumentRjcnReason        string
	NetAmount                      string
	NetPriceAmount                 string
	NetPriceQuantity               string
	NetPriceQuantityUnit           string
	TransactionCurrency            string
	PricingDate                    string
	ShippingPoint                  string
	ShippingType                   string
	DeliveryPriority               string
	IncotermsClassification        string
	CustomerPaymentTerms           string
	ItemBillingBlockReason         string
	SDProcessStatus                string
	DeliveryStatus                 string
	ItemGeneralIncompletionStatus  string
	ItemBillingIncompletionStatus  string
	ItemDeliveryIncompletionStatus string
}{
	SalesSchedulingAgreement:       "sap_sales_scheduling_agreement_item_data.SalesSchedulingAgreement",
	SalesSchedulingAgreementItem:   "sap_sales_scheduling_agreement_item_data.SalesSchedulingAgreementItem",
	SalesSchedgAgrmtItemCategory:   "sap_sales_scheduling_agreement_item_data.SalesSchedgAgrmtItemCategory",
	LastChangeDate:                 "sap_sales_scheduling_agreement_item_data.LastChangeDate",
	Material:                       "sap_sales_scheduling_agreement_item_data.Material",
	MaterialByCustomer:             "sap_sales_scheduling_agreement_item_data.MaterialByCustomer",
	MaterialGroup:                  "sap_sales_scheduling_agreement_item_data.MaterialGroup",
	MaterialPricingGroup:           "sap_sales_scheduling_agreement_item_data.MaterialPricingGroup",
	ProductionPlant:                "sap_sales_scheduling_agreement_item_data.ProductionPlant",
	StorageLocation:                "sap_sales_scheduling_agreement_item_data.StorageLocation",
	SalesSchedgAgrmtItemText:       "sap_sales_scheduling_agreement_item_data.SalesSchedgAgrmtItemText",
	PurchaseOrderByCustomer:        "sap_sales_scheduling_agreement_item_data.PurchaseOrderByCustomer",
	OrderQuantity:                  "sap_sales_scheduling_agreement_item_data.OrderQuantity",
	OrderQuantityUnit:              "sap_sales_scheduling_agreement_item_data.OrderQuantityUnit",
	TargetQuantity:                 "sap_sales_scheduling_agreement_item_data.TargetQuantity",
	TargetQuantityUnit:             "sap_sales_scheduling_agreement_item_data.TargetQuantityUnit",
	SalesDocumentRjcnReason:        "sap_sales_scheduling_agreement_item_data.SalesDocumentRjcnReason",
	NetAmount:                      "sap_sales_scheduling_agreement_item_data.NetAmount",
	NetPriceAmount:                 "sap_sales_scheduling_agreement_item_data.NetPriceAmount",
	NetPriceQuantity:               "sap_sales_scheduling_agreement_item_data.NetPriceQuantity",
	NetPriceQuantityUnit:           "sap_sales_scheduling_agreement_item_data.NetPriceQuantityUnit",
	TransactionCurrency:            "sap_sales_scheduling_agreement_item_data.TransactionCurrency",
	PricingDate:                    "sap_sales_scheduling_agreement_item_data.PricingDate",
	ShippingPoint:                  "sap_sales_scheduling_agreement_item_data.ShippingPoint",
	ShippingType:                   "sap_sales_scheduling_agreement_item_data.ShippingType",
	DeliveryPriority:               "sap_sales_scheduling_agreement_item_data.DeliveryPriority",
	IncotermsClassification:        "sap_sales_scheduling_agreement_item_data.IncotermsClassification",
	CustomerPaymentTerms:           "sap_sales_scheduling_agreement_item_data.CustomerPaymentTerms",
	ItemBillingBlockReason:         "sap_sales_scheduling_agreement_item_data.ItemBillingBlockReason",
	SDProcessStatus:                "sap_sales_scheduling_agreement_item_data.SDProcessStatus",
	DeliveryStatus:                 "sap_sales_scheduling_agreement_item_data.DeliveryStatus",
	ItemGeneralIncompletionStatus:  "sap_sales_scheduling_agreement_item_data.ItemGeneralIncompletionStatus",
	ItemBillingIncompletionStatus:  "sap_sales_scheduling_agreement_item_data.ItemBillingIncompletionStatus",
	ItemDeliveryIncompletionStatus: "sap_sales_scheduling_agreement_item_data.ItemDeliveryIncompletionStatus",
}

// Generated where

var SapSalesSchedulingAgreementItemDatumWhere = struct {
	SalesSchedulingAgreement       whereHelperstring
	SalesSchedulingAgreementItem   whereHelperstring
	SalesSchedgAgrmtItemCategory   whereHelpernull_String
	LastChangeDate                 whereHelpernull_String
	Material                       whereHelpernull_String
	MaterialByCustomer             whereHelpernull_String
	MaterialGroup                  whereHelpernull_String
	MaterialPricingGroup           whereHelpernull_String
	ProductionPlant                whereHelpernull_String
	StorageLocation                whereHelpernull_String
	SalesSchedgAgrmtItemText       whereHelpernull_String
	PurchaseOrderByCustomer        whereHelpernull_String
	OrderQuantity                  whereHelpernull_String
	OrderQuantityUnit              whereHelpernull_String
	TargetQuantity                 whereHelpernull_String
	TargetQuantityUnit             whereHelpernull_String
	SalesDocumentRjcnReason        whereHelpernull_String
	NetAmount                      whereHelpernull_String
	NetPriceAmount                 whereHelpernull_String
	NetPriceQuantity               whereHelpernull_String
	NetPriceQuantityUnit           whereHelpernull_String
	TransactionCurrency            whereHelpernull_String
	PricingDate                    whereHelpernull_String
	ShippingPoint                  whereHelpernull_String
	ShippingType                   whereHelpernull_String
	DeliveryPriority               whereHelpernull_String
	IncotermsClassification        whereHelpernull_String
	CustomerPaymentTerms           whereHelpernull_String
	ItemBillingBlockReason         whereHelpernull_String
	SDProcessStatus                whereHelpernull_String
	DeliveryStatus                 whereHelpernull_String
	ItemGeneralIncompletionStatus  whereHelpernull_String
	ItemBillingIncompletionStatus  whereHelpernull_String
	ItemDeliveryIncompletionStatus whereHelpernull_String
}{
	SalesSchedulingAgreement:       whereHelperstring{field: "`sap_sales_scheduling_agreement_item_data`.`SalesSchedulingAgreement`"},
	SalesSchedulingAgreementItem:   whereHelperstring{field: "`sap_sales_scheduling_agreement_item_data`.`SalesSchedulingAgreementItem`"},
	SalesSchedgAgrmtItemCategory:   whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`SalesSchedgAgrmtItemCategory`"},
	LastChangeDate:                 whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`LastChangeDate`"},
	Material:                       whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`Material`"},
	MaterialByCustomer:             whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`MaterialByCustomer`"},
	MaterialGroup:                  whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`MaterialGroup`"},
	MaterialPricingGroup:           whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`MaterialPricingGroup`"},
	ProductionPlant:                whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`ProductionPlant`"},
	StorageLocation:                whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`StorageLocation`"},
	SalesSchedgAgrmtItemText:       whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`SalesSchedgAgrmtItemText`"},
	PurchaseOrderByCustomer:        whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`PurchaseOrderByCustomer`"},
	OrderQuantity:                  whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`OrderQuantity`"},
	OrderQuantityUnit:              whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`OrderQuantityUnit`"},
	TargetQuantity:                 whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`TargetQuantity`"},
	TargetQuantityUnit:             whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`TargetQuantityUnit`"},
	SalesDocumentRjcnReason:        whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`SalesDocumentRjcnReason`"},
	NetAmount:                      whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`NetAmount`"},
	NetPriceAmount:                 whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`NetPriceAmount`"},
	NetPriceQuantity:               whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`NetPriceQuantity`"},
	NetPriceQuantityUnit:           whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`NetPriceQuantityUnit`"},
	TransactionCurrency:            whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`TransactionCurrency`"},
	PricingDate:                    whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`PricingDate`"},
	ShippingPoint:                  whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`ShippingPoint`"},
	ShippingType:                   whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`ShippingType`"},
	DeliveryPriority:               whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`DeliveryPriority`"},
	IncotermsClassification:        whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`IncotermsClassification`"},
	CustomerPaymentTerms:           whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`CustomerPaymentTerms`"},
	ItemBillingBlockReason:         whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`ItemBillingBlockReason`"},
	SDProcessStatus:                whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`SDProcessStatus`"},
	DeliveryStatus:                 whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`DeliveryStatus`"},
	ItemGeneralIncompletionStatus:  whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`ItemGeneralIncompletionStatus`"},
	ItemBillingIncompletionStatus:  whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`ItemBillingIncompletionStatus`"},
	ItemDeliveryIncompletionStatus: whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_data`.`ItemDeliveryIncompletionStatus`"},
}

// SapSalesSchedulingAgreementItemDatumRels is where relationship names are stored.
var SapSalesSchedulingAgreementItemDatumRels = struct {
	SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum string
}{
	SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum: "SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum",
}

// sapSalesSchedulingAgreementItemDatumR is where relationships are stored.
type sapSalesSchedulingAgreementItemDatumR struct {
	SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum *SapSalesSchedulingAgreementHeaderDatum `boil:"SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum" json:"SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum" toml:"SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum" yaml:"SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum"`
}

// NewStruct creates a new relationship struct
func (*sapSalesSchedulingAgreementItemDatumR) NewStruct() *sapSalesSchedulingAgreementItemDatumR {
	return &sapSalesSchedulingAgreementItemDatumR{}
}

func (r *sapSalesSchedulingAgreementItemDatumR) GetSalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum() *SapSalesSchedulingAgreementHeaderDatum {
	if r == nil {
		return nil
	}
	return r.SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum
}

// sapSalesSchedulingAgreementItemDatumL is where Load methods for each relationship are stored.
type sapSalesSchedulingAgreementItemDatumL struct{}

var (
	sapSalesSchedulingAgreementItemDatumAllColumns            = []string{"SalesSchedulingAgreement", "SalesSchedulingAgreementItem", "SalesSchedgAgrmtItemCategory", "LastChangeDate", "Material", "MaterialByCustomer", "MaterialGroup", "MaterialPricingGroup", "ProductionPlant", "StorageLocation", "SalesSchedgAgrmtItemText", "PurchaseOrderByCustomer", "OrderQuantity", "OrderQuantityUnit", "TargetQuantity", "TargetQuantityUnit", "SalesDocumentRjcnReason", "NetAmount", "NetPriceAmount", "NetPriceQuantity", "NetPriceQuantityUnit", "TransactionCurrency", "PricingDate", "ShippingPoint", "ShippingType", "DeliveryPriority", "IncotermsClassification", "CustomerPaymentTerms", "ItemBillingBlockReason", "SDProcessStatus", "DeliveryStatus", "ItemGeneralIncompletionStatus", "ItemBillingIncompletionStatus", "ItemDeliveryIncompletionStatus"}
	sapSalesSchedulingAgreementItemDatumColumnsWithoutDefault = []string{"SalesSchedulingAgreement", "SalesSchedulingAgreementItem", "SalesSchedgAgrmtItemCategory", "LastChangeDate", "Material", "MaterialByCustomer", "MaterialGroup", "MaterialPricingGroup", "ProductionPlant", "StorageLocation", "SalesSchedgAgrmtItemText", "PurchaseOrderByCustomer", "OrderQuantity", "OrderQuantityUnit", "TargetQuantity", "TargetQuantityUnit", "SalesDocumentRjcnReason", "NetAmount", "NetPriceAmount", "NetPriceQuantity", "NetPriceQuantityUnit", "TransactionCurrency", "PricingDate", "ShippingPoint", "ShippingType", "DeliveryPriority", "IncotermsClassification", "CustomerPaymentTerms", "ItemBillingBlockReason", "SDProcessStatus", "DeliveryStatus", "ItemGeneralIncompletionStatus", "ItemBillingIncompletionStatus", "ItemDeliveryIncompletionStatus"}
	sapSalesSchedulingAgreementItemDatumColumnsWithDefault    = []string{}
	sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns     = []string{"SalesSchedulingAgreement", "SalesSchedulingAgreementItem"}
	sapSalesSchedulingAgreementItemDatumGeneratedColumns      = []string{}
)

type (
	// SapSalesSchedulingAgreementItemDatumSlice is an alias for a slice of pointers to SapSalesSchedulingAgreementItemDatum.
	// This should almost always be used instead of []SapSalesSchedulingAgreementItemDatum.
	SapSalesSchedulingAgreementItemDatumSlice []*SapSalesSchedulingAgreementItemDatum
	// SapSalesSchedulingAgreementItemDatumHook is the signature for custom SapSalesSchedulingAgreementItemDatum hook methods
	SapSalesSchedulingAgreementItemDatumHook func(context.Context, boil.ContextExecutor, *SapSalesSchedulingAgreementItemDatum) error

	sapSalesSchedulingAgreementItemDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapSalesSchedulingAgreementItemDatumType                 = reflect.TypeOf(&SapSalesSchedulingAgreementItemDatum{})
	sapSalesSchedulingAgreementItemDatumMapping              = queries.MakeStructMapping(sapSalesSchedulingAgreementItemDatumType)
	sapSalesSchedulingAgreementItemDatumPrimaryKeyMapping, _ = queries.BindMapping(sapSalesSchedulingAgreementItemDatumType, sapSalesSchedulingAgreementItemDatumMapping, sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns)
	sapSalesSchedulingAgreementItemDatumInsertCacheMut       sync.RWMutex
	sapSalesSchedulingAgreementItemDatumInsertCache          = make(map[string]insertCache)
	sapSalesSchedulingAgreementItemDatumUpdateCacheMut       sync.RWMutex
	sapSalesSchedulingAgreementItemDatumUpdateCache          = make(map[string]updateCache)
	sapSalesSchedulingAgreementItemDatumUpsertCacheMut       sync.RWMutex
	sapSalesSchedulingAgreementItemDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapSalesSchedulingAgreementItemDatumAfterSelectHooks []SapSalesSchedulingAgreementItemDatumHook

var sapSalesSchedulingAgreementItemDatumBeforeInsertHooks []SapSalesSchedulingAgreementItemDatumHook
var sapSalesSchedulingAgreementItemDatumAfterInsertHooks []SapSalesSchedulingAgreementItemDatumHook

var sapSalesSchedulingAgreementItemDatumBeforeUpdateHooks []SapSalesSchedulingAgreementItemDatumHook
var sapSalesSchedulingAgreementItemDatumAfterUpdateHooks []SapSalesSchedulingAgreementItemDatumHook

var sapSalesSchedulingAgreementItemDatumBeforeDeleteHooks []SapSalesSchedulingAgreementItemDatumHook
var sapSalesSchedulingAgreementItemDatumAfterDeleteHooks []SapSalesSchedulingAgreementItemDatumHook

var sapSalesSchedulingAgreementItemDatumBeforeUpsertHooks []SapSalesSchedulingAgreementItemDatumHook
var sapSalesSchedulingAgreementItemDatumAfterUpsertHooks []SapSalesSchedulingAgreementItemDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapSalesSchedulingAgreementItemDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapSalesSchedulingAgreementItemDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapSalesSchedulingAgreementItemDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapSalesSchedulingAgreementItemDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapSalesSchedulingAgreementItemDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapSalesSchedulingAgreementItemDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapSalesSchedulingAgreementItemDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapSalesSchedulingAgreementItemDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapSalesSchedulingAgreementItemDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapSalesSchedulingAgreementItemDatumHook registers your hook function for all future operations.
func AddSapSalesSchedulingAgreementItemDatumHook(hookPoint boil.HookPoint, sapSalesSchedulingAgreementItemDatumHook SapSalesSchedulingAgreementItemDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapSalesSchedulingAgreementItemDatumAfterSelectHooks = append(sapSalesSchedulingAgreementItemDatumAfterSelectHooks, sapSalesSchedulingAgreementItemDatumHook)
	case boil.BeforeInsertHook:
		sapSalesSchedulingAgreementItemDatumBeforeInsertHooks = append(sapSalesSchedulingAgreementItemDatumBeforeInsertHooks, sapSalesSchedulingAgreementItemDatumHook)
	case boil.AfterInsertHook:
		sapSalesSchedulingAgreementItemDatumAfterInsertHooks = append(sapSalesSchedulingAgreementItemDatumAfterInsertHooks, sapSalesSchedulingAgreementItemDatumHook)
	case boil.BeforeUpdateHook:
		sapSalesSchedulingAgreementItemDatumBeforeUpdateHooks = append(sapSalesSchedulingAgreementItemDatumBeforeUpdateHooks, sapSalesSchedulingAgreementItemDatumHook)
	case boil.AfterUpdateHook:
		sapSalesSchedulingAgreementItemDatumAfterUpdateHooks = append(sapSalesSchedulingAgreementItemDatumAfterUpdateHooks, sapSalesSchedulingAgreementItemDatumHook)
	case boil.BeforeDeleteHook:
		sapSalesSchedulingAgreementItemDatumBeforeDeleteHooks = append(sapSalesSchedulingAgreementItemDatumBeforeDeleteHooks, sapSalesSchedulingAgreementItemDatumHook)
	case boil.AfterDeleteHook:
		sapSalesSchedulingAgreementItemDatumAfterDeleteHooks = append(sapSalesSchedulingAgreementItemDatumAfterDeleteHooks, sapSalesSchedulingAgreementItemDatumHook)
	case boil.BeforeUpsertHook:
		sapSalesSchedulingAgreementItemDatumBeforeUpsertHooks = append(sapSalesSchedulingAgreementItemDatumBeforeUpsertHooks, sapSalesSchedulingAgreementItemDatumHook)
	case boil.AfterUpsertHook:
		sapSalesSchedulingAgreementItemDatumAfterUpsertHooks = append(sapSalesSchedulingAgreementItemDatumAfterUpsertHooks, sapSalesSchedulingAgreementItemDatumHook)
	}
}

// One returns a single sapSalesSchedulingAgreementItemDatum record from the query.
func (q sapSalesSchedulingAgreementItemDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapSalesSchedulingAgreementItemDatum, error) {
	o := &SapSalesSchedulingAgreementItemDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_sales_scheduling_agreement_item_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapSalesSchedulingAgreementItemDatum records from the query.
func (q sapSalesSchedulingAgreementItemDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapSalesSchedulingAgreementItemDatumSlice, error) {
	var o []*SapSalesSchedulingAgreementItemDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapSalesSchedulingAgreementItemDatum slice")
	}

	if len(sapSalesSchedulingAgreementItemDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapSalesSchedulingAgreementItemDatum records in the query.
func (q sapSalesSchedulingAgreementItemDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_sales_scheduling_agreement_item_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapSalesSchedulingAgreementItemDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_sales_scheduling_agreement_item_data exists")
	}

	return count > 0, nil
}

// SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum pointed to by the foreign key.
func (o *SapSalesSchedulingAgreementItemDatum) SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum(mods ...qm.QueryMod) sapSalesSchedulingAgreementHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`SalesSchedulingAgreement` = ?", o.SalesSchedulingAgreement),
	}

	queryMods = append(queryMods, mods...)

	return SapSalesSchedulingAgreementHeaderData(queryMods...)
}

// LoadSalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (sapSalesSchedulingAgreementItemDatumL) LoadSalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapSalesSchedulingAgreementItemDatum interface{}, mods queries.Applicator) error {
	var slice []*SapSalesSchedulingAgreementItemDatum
	var object *SapSalesSchedulingAgreementItemDatum

	if singular {
		object = maybeSapSalesSchedulingAgreementItemDatum.(*SapSalesSchedulingAgreementItemDatum)
	} else {
		slice = *maybeSapSalesSchedulingAgreementItemDatum.(*[]*SapSalesSchedulingAgreementItemDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapSalesSchedulingAgreementItemDatumR{}
		}
		args = append(args, object.SalesSchedulingAgreement)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapSalesSchedulingAgreementItemDatumR{}
			}

			for _, a := range args {
				if a == obj.SalesSchedulingAgreement {
					continue Outer
				}
			}

			args = append(args, obj.SalesSchedulingAgreement)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_sales_scheduling_agreement_header_data`),
		qm.WhereIn(`sap_sales_scheduling_agreement_header_data.SalesSchedulingAgreement in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SapSalesSchedulingAgreementHeaderDatum")
	}

	var resultSlice []*SapSalesSchedulingAgreementHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SapSalesSchedulingAgreementHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for sap_sales_scheduling_agreement_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_sales_scheduling_agreement_header_data")
	}

	if len(sapSalesSchedulingAgreementItemDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum = foreign
		if foreign.R == nil {
			foreign.R = &sapSalesSchedulingAgreementHeaderDatumR{}
		}
		foreign.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemData = append(foreign.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.SalesSchedulingAgreement == foreign.SalesSchedulingAgreement {
				local.R.SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum = foreign
				if foreign.R == nil {
					foreign.R = &sapSalesSchedulingAgreementHeaderDatumR{}
				}
				foreign.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemData = append(foreign.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemData, local)
				break
			}
		}
	}

	return nil
}

// SetSalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum of the sapSalesSchedulingAgreementItemDatum to the related item.
// Sets o.R.SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum to related.
// Adds o to related.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemData.
func (o *SapSalesSchedulingAgreementItemDatum) SetSalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SapSalesSchedulingAgreementHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `sap_sales_scheduling_agreement_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"SalesSchedulingAgreement"}),
		strmangle.WhereClause("`", "`", 0, sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.SalesSchedulingAgreement, o.SalesSchedulingAgreement, o.SalesSchedulingAgreementItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.SalesSchedulingAgreement = related.SalesSchedulingAgreement
	if o.R == nil {
		o.R = &sapSalesSchedulingAgreementItemDatumR{
			SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum: related,
		}
	} else {
		o.R.SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum = related
	}

	if related.R == nil {
		related.R = &sapSalesSchedulingAgreementHeaderDatumR{
			SalesSchedulingAgreementSapSalesSchedulingAgreementItemData: SapSalesSchedulingAgreementItemDatumSlice{o},
		}
	} else {
		related.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemData = append(related.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemData, o)
	}

	return nil
}

// SapSalesSchedulingAgreementItemData retrieves all the records using an executor.
func SapSalesSchedulingAgreementItemData(mods ...qm.QueryMod) sapSalesSchedulingAgreementItemDatumQuery {
	mods = append(mods, qm.From("`sap_sales_scheduling_agreement_item_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`sap_sales_scheduling_agreement_item_data`.*"})
	}

	return sapSalesSchedulingAgreementItemDatumQuery{q}
}

// FindSapSalesSchedulingAgreementItemDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapSalesSchedulingAgreementItemDatum(ctx context.Context, exec boil.ContextExecutor, salesSchedulingAgreement string, salesSchedulingAgreementItem string, selectCols ...string) (*SapSalesSchedulingAgreementItemDatum, error) {
	sapSalesSchedulingAgreementItemDatumObj := &SapSalesSchedulingAgreementItemDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_sales_scheduling_agreement_item_data` where `SalesSchedulingAgreement`=? AND `SalesSchedulingAgreementItem`=?", sel,
	)

	q := queries.Raw(query, salesSchedulingAgreement, salesSchedulingAgreementItem)

	err := q.Bind(ctx, exec, sapSalesSchedulingAgreementItemDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_sales_scheduling_agreement_item_data")
	}

	if err = sapSalesSchedulingAgreementItemDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapSalesSchedulingAgreementItemDatumObj, err
	}

	return sapSalesSchedulingAgreementItemDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapSalesSchedulingAgreementItemDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_sales_scheduling_agreement_item_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapSalesSchedulingAgreementItemDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapSalesSchedulingAgreementItemDatumInsertCacheMut.RLock()
	cache, cached := sapSalesSchedulingAgreementItemDatumInsertCache[key]
	sapSalesSchedulingAgreementItemDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapSalesSchedulingAgreementItemDatumAllColumns,
			sapSalesSchedulingAgreementItemDatumColumnsWithDefault,
			sapSalesSchedulingAgreementItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDatumType, sapSalesSchedulingAgreementItemDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDatumType, sapSalesSchedulingAgreementItemDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_sales_scheduling_agreement_item_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_sales_scheduling_agreement_item_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_sales_scheduling_agreement_item_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_sales_scheduling_agreement_item_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.SalesSchedulingAgreement,
		o.SalesSchedulingAgreementItem,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_sales_scheduling_agreement_item_data")
	}

CacheNoHooks:
	if !cached {
		sapSalesSchedulingAgreementItemDatumInsertCacheMut.Lock()
		sapSalesSchedulingAgreementItemDatumInsertCache[key] = cache
		sapSalesSchedulingAgreementItemDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapSalesSchedulingAgreementItemDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapSalesSchedulingAgreementItemDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapSalesSchedulingAgreementItemDatumUpdateCacheMut.RLock()
	cache, cached := sapSalesSchedulingAgreementItemDatumUpdateCache[key]
	sapSalesSchedulingAgreementItemDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapSalesSchedulingAgreementItemDatumAllColumns,
			sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_sales_scheduling_agreement_item_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_sales_scheduling_agreement_item_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDatumType, sapSalesSchedulingAgreementItemDatumMapping, append(wl, sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_sales_scheduling_agreement_item_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_sales_scheduling_agreement_item_data")
	}

	if !cached {
		sapSalesSchedulingAgreementItemDatumUpdateCacheMut.Lock()
		sapSalesSchedulingAgreementItemDatumUpdateCache[key] = cache
		sapSalesSchedulingAgreementItemDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapSalesSchedulingAgreementItemDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_sales_scheduling_agreement_item_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_sales_scheduling_agreement_item_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapSalesSchedulingAgreementItemDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapSalesSchedulingAgreementItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_sales_scheduling_agreement_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapSalesSchedulingAgreementItemDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapSalesSchedulingAgreementItemDatum")
	}
	return rowsAff, nil
}

var mySQLSapSalesSchedulingAgreementItemDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapSalesSchedulingAgreementItemDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_sales_scheduling_agreement_item_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapSalesSchedulingAgreementItemDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapSalesSchedulingAgreementItemDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapSalesSchedulingAgreementItemDatumUpsertCacheMut.RLock()
	cache, cached := sapSalesSchedulingAgreementItemDatumUpsertCache[key]
	sapSalesSchedulingAgreementItemDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapSalesSchedulingAgreementItemDatumAllColumns,
			sapSalesSchedulingAgreementItemDatumColumnsWithDefault,
			sapSalesSchedulingAgreementItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapSalesSchedulingAgreementItemDatumAllColumns,
			sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_sales_scheduling_agreement_item_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_sales_scheduling_agreement_item_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_sales_scheduling_agreement_item_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDatumType, sapSalesSchedulingAgreementItemDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDatumType, sapSalesSchedulingAgreementItemDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_sales_scheduling_agreement_item_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapSalesSchedulingAgreementItemDatumType, sapSalesSchedulingAgreementItemDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_sales_scheduling_agreement_item_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_sales_scheduling_agreement_item_data")
	}

CacheNoHooks:
	if !cached {
		sapSalesSchedulingAgreementItemDatumUpsertCacheMut.Lock()
		sapSalesSchedulingAgreementItemDatumUpsertCache[key] = cache
		sapSalesSchedulingAgreementItemDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapSalesSchedulingAgreementItemDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapSalesSchedulingAgreementItemDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapSalesSchedulingAgreementItemDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapSalesSchedulingAgreementItemDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_sales_scheduling_agreement_item_data` WHERE `SalesSchedulingAgreement`=? AND `SalesSchedulingAgreementItem`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_sales_scheduling_agreement_item_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_sales_scheduling_agreement_item_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapSalesSchedulingAgreementItemDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapSalesSchedulingAgreementItemDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_sales_scheduling_agreement_item_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_sales_scheduling_agreement_item_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapSalesSchedulingAgreementItemDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapSalesSchedulingAgreementItemDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapSalesSchedulingAgreementItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_sales_scheduling_agreement_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapSalesSchedulingAgreementItemDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_sales_scheduling_agreement_item_data")
	}

	if len(sapSalesSchedulingAgreementItemDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapSalesSchedulingAgreementItemDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapSalesSchedulingAgreementItemDatum(ctx, exec, o.SalesSchedulingAgreement, o.SalesSchedulingAgreementItem)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapSalesSchedulingAgreementItemDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapSalesSchedulingAgreementItemDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapSalesSchedulingAgreementItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_sales_scheduling_agreement_item_data`.* FROM `sap_sales_scheduling_agreement_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapSalesSchedulingAgreementItemDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapSalesSchedulingAgreementItemDatumSlice")
	}

	*o = slice

	return nil
}

// SapSalesSchedulingAgreementItemDatumExists checks if the SapSalesSchedulingAgreementItemDatum row exists.
func SapSalesSchedulingAgreementItemDatumExists(ctx context.Context, exec boil.ContextExecutor, salesSchedulingAgreement string, salesSchedulingAgreementItem string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_sales_scheduling_agreement_item_data` where `SalesSchedulingAgreement`=? AND `SalesSchedulingAgreementItem`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, salesSchedulingAgreement, salesSchedulingAgreementItem)
	}
	row := exec.QueryRowContext(ctx, sql, salesSchedulingAgreement, salesSchedulingAgreementItem)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_sales_scheduling_agreement_item_data exists")
	}

	return exists, nil
}
