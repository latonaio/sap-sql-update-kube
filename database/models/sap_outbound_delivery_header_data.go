// Code generated by SQLBoiler 4.8.3 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapOutboundDeliveryHeaderDatum is an object representing the database table.
type SapOutboundDeliveryHeaderDatum struct {
	DeliveryDocument              string      `boil:"DeliveryDocument" json:"DeliveryDocument" toml:"DeliveryDocument" yaml:"DeliveryDocument"`
	DeliveryDocumentType          null.String `boil:"DeliveryDocumentType" json:"DeliveryDocumentType,omitempty" toml:"DeliveryDocumentType" yaml:"DeliveryDocumentType,omitempty"`
	DocumentDate                  null.String `boil:"DocumentDate" json:"DocumentDate,omitempty" toml:"DocumentDate" yaml:"DocumentDate,omitempty"`
	ActualGoodsMovementDate       null.String `boil:"ActualGoodsMovementDate" json:"ActualGoodsMovementDate,omitempty" toml:"ActualGoodsMovementDate" yaml:"ActualGoodsMovementDate,omitempty"`
	ActualDeliveryRoute           null.String `boil:"ActualDeliveryRoute" json:"ActualDeliveryRoute,omitempty" toml:"ActualDeliveryRoute" yaml:"ActualDeliveryRoute,omitempty"`
	ActualGoodsMovementTime       null.String `boil:"ActualGoodsMovementTime" json:"ActualGoodsMovementTime,omitempty" toml:"ActualGoodsMovementTime" yaml:"ActualGoodsMovementTime,omitempty"`
	BillingDocumentDate           null.String `boil:"BillingDocumentDate" json:"BillingDocumentDate,omitempty" toml:"BillingDocumentDate" yaml:"BillingDocumentDate,omitempty"`
	CompleteDeliveryIsDefined     null.Bool   `boil:"CompleteDeliveryIsDefined" json:"CompleteDeliveryIsDefined,omitempty" toml:"CompleteDeliveryIsDefined" yaml:"CompleteDeliveryIsDefined,omitempty"`
	ConfirmationTime              null.String `boil:"ConfirmationTime" json:"ConfirmationTime,omitempty" toml:"ConfirmationTime" yaml:"ConfirmationTime,omitempty"`
	CreationDate                  null.String `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	CreationTime                  null.String `boil:"CreationTime" json:"CreationTime,omitempty" toml:"CreationTime" yaml:"CreationTime,omitempty"`
	CustomerGroup                 null.String `boil:"CustomerGroup" json:"CustomerGroup,omitempty" toml:"CustomerGroup" yaml:"CustomerGroup,omitempty"`
	DeliveryBlockReason           null.String `boil:"DeliveryBlockReason" json:"DeliveryBlockReason,omitempty" toml:"DeliveryBlockReason" yaml:"DeliveryBlockReason,omitempty"`
	DeliveryDate                  null.String `boil:"DeliveryDate" json:"DeliveryDate,omitempty" toml:"DeliveryDate" yaml:"DeliveryDate,omitempty"`
	DeliveryDocumentBySupplier    null.String `boil:"DeliveryDocumentBySupplier" json:"DeliveryDocumentBySupplier,omitempty" toml:"DeliveryDocumentBySupplier" yaml:"DeliveryDocumentBySupplier,omitempty"`
	DeliveryIsInPlant             null.Bool   `boil:"DeliveryIsInPlant" json:"DeliveryIsInPlant,omitempty" toml:"DeliveryIsInPlant" yaml:"DeliveryIsInPlant,omitempty"`
	DeliveryPriority              null.String `boil:"DeliveryPriority" json:"DeliveryPriority,omitempty" toml:"DeliveryPriority" yaml:"DeliveryPriority,omitempty"`
	DeliveryTime                  null.String `boil:"DeliveryTime" json:"DeliveryTime,omitempty" toml:"DeliveryTime" yaml:"DeliveryTime,omitempty"`
	GoodsIssueOrReceiptSlipNumber null.String `boil:"GoodsIssueOrReceiptSlipNumber" json:"GoodsIssueOrReceiptSlipNumber,omitempty" toml:"GoodsIssueOrReceiptSlipNumber" yaml:"GoodsIssueOrReceiptSlipNumber,omitempty"`
	GoodsIssueTime                null.String `boil:"GoodsIssueTime" json:"GoodsIssueTime,omitempty" toml:"GoodsIssueTime" yaml:"GoodsIssueTime,omitempty"`
	HeaderBillingBlockReason      null.String `boil:"HeaderBillingBlockReason" json:"HeaderBillingBlockReason,omitempty" toml:"HeaderBillingBlockReason" yaml:"HeaderBillingBlockReason,omitempty"`
	HeaderGrossWeight             null.String `boil:"HeaderGrossWeight" json:"HeaderGrossWeight,omitempty" toml:"HeaderGrossWeight" yaml:"HeaderGrossWeight,omitempty"`
	HeaderNetWeight               null.String `boil:"HeaderNetWeight" json:"HeaderNetWeight,omitempty" toml:"HeaderNetWeight" yaml:"HeaderNetWeight,omitempty"`
	HeaderVolume                  null.String `boil:"HeaderVolume" json:"HeaderVolume,omitempty" toml:"HeaderVolume" yaml:"HeaderVolume,omitempty"`
	HeaderVolumeUnit              null.String `boil:"HeaderVolumeUnit" json:"HeaderVolumeUnit,omitempty" toml:"HeaderVolumeUnit" yaml:"HeaderVolumeUnit,omitempty"`
	HeaderWeightUnit              null.String `boil:"HeaderWeightUnit" json:"HeaderWeightUnit,omitempty" toml:"HeaderWeightUnit" yaml:"HeaderWeightUnit,omitempty"`
	IncotermsClassification       null.String `boil:"IncotermsClassification" json:"IncotermsClassification,omitempty" toml:"IncotermsClassification" yaml:"IncotermsClassification,omitempty"`
	IsExportDelivery              null.String `boil:"IsExportDelivery" json:"IsExportDelivery,omitempty" toml:"IsExportDelivery" yaml:"IsExportDelivery,omitempty"`
	LastChangeDate                null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	LoadingDate                   null.String `boil:"LoadingDate" json:"LoadingDate,omitempty" toml:"LoadingDate" yaml:"LoadingDate,omitempty"`
	LoadingPoint                  null.String `boil:"LoadingPoint" json:"LoadingPoint,omitempty" toml:"LoadingPoint" yaml:"LoadingPoint,omitempty"`
	LoadingTime                   null.String `boil:"LoadingTime" json:"LoadingTime,omitempty" toml:"LoadingTime" yaml:"LoadingTime,omitempty"`
	MeansOfTransport              null.String `boil:"MeansOfTransport" json:"MeansOfTransport,omitempty" toml:"MeansOfTransport" yaml:"MeansOfTransport,omitempty"`
	OrderCombinationIsAllowed     null.Bool   `boil:"OrderCombinationIsAllowed" json:"OrderCombinationIsAllowed,omitempty" toml:"OrderCombinationIsAllowed" yaml:"OrderCombinationIsAllowed,omitempty"`
	OrderID                       null.String `boil:"OrderID" json:"OrderID,omitempty" toml:"OrderID" yaml:"OrderID,omitempty"`
	OverallDelivConfStatus        null.String `boil:"OverallDelivConfStatus" json:"OverallDelivConfStatus,omitempty" toml:"OverallDelivConfStatus" yaml:"OverallDelivConfStatus,omitempty"`
	OverallDelivReltdBillgStatus  null.String `boil:"OverallDelivReltdBillgStatus" json:"OverallDelivReltdBillgStatus,omitempty" toml:"OverallDelivReltdBillgStatus" yaml:"OverallDelivReltdBillgStatus,omitempty"`
	OverallGoodsMovementStatus    null.String `boil:"OverallGoodsMovementStatus" json:"OverallGoodsMovementStatus,omitempty" toml:"OverallGoodsMovementStatus" yaml:"OverallGoodsMovementStatus,omitempty"`
	OverallPackingStatus          null.String `boil:"OverallPackingStatus" json:"OverallPackingStatus,omitempty" toml:"OverallPackingStatus" yaml:"OverallPackingStatus,omitempty"`
	OverallPickingConfStatus      null.String `boil:"OverallPickingConfStatus" json:"OverallPickingConfStatus,omitempty" toml:"OverallPickingConfStatus" yaml:"OverallPickingConfStatus,omitempty"`
	OverallPickingStatus          null.String `boil:"OverallPickingStatus" json:"OverallPickingStatus,omitempty" toml:"OverallPickingStatus" yaml:"OverallPickingStatus,omitempty"`
	PickingDate                   null.String `boil:"PickingDate" json:"PickingDate,omitempty" toml:"PickingDate" yaml:"PickingDate,omitempty"`
	PickingTime                   null.String `boil:"PickingTime" json:"PickingTime,omitempty" toml:"PickingTime" yaml:"PickingTime,omitempty"`
	PlannedGoodsIssueDate         null.String `boil:"PlannedGoodsIssueDate" json:"PlannedGoodsIssueDate,omitempty" toml:"PlannedGoodsIssueDate" yaml:"PlannedGoodsIssueDate,omitempty"`
	ReceivingPlant                null.String `boil:"ReceivingPlant" json:"ReceivingPlant,omitempty" toml:"ReceivingPlant" yaml:"ReceivingPlant,omitempty"`
	ShippingCondition             null.String `boil:"ShippingCondition" json:"ShippingCondition,omitempty" toml:"ShippingCondition" yaml:"ShippingCondition,omitempty"`
	ShippingPoint                 null.String `boil:"ShippingPoint" json:"ShippingPoint,omitempty" toml:"ShippingPoint" yaml:"ShippingPoint,omitempty"`
	ShippingType                  null.String `boil:"ShippingType" json:"ShippingType,omitempty" toml:"ShippingType" yaml:"ShippingType,omitempty"`
	ShipToParty                   null.String `boil:"ShipToParty" json:"ShipToParty,omitempty" toml:"ShipToParty" yaml:"ShipToParty,omitempty"`
	SoldToParty                   null.String `boil:"SoldToParty" json:"SoldToParty,omitempty" toml:"SoldToParty" yaml:"SoldToParty,omitempty"`
	Supplier                      null.String `boil:"Supplier" json:"Supplier,omitempty" toml:"Supplier" yaml:"Supplier,omitempty"`
	TransportationGroup           null.String `boil:"TransportationGroup" json:"TransportationGroup,omitempty" toml:"TransportationGroup" yaml:"TransportationGroup,omitempty"`
	TransportationPlanningDate    null.String `boil:"TransportationPlanningDate" json:"TransportationPlanningDate,omitempty" toml:"TransportationPlanningDate" yaml:"TransportationPlanningDate,omitempty"`
	TransportationPlanningTime    null.String `boil:"TransportationPlanningTime" json:"TransportationPlanningTime,omitempty" toml:"TransportationPlanningTime" yaml:"TransportationPlanningTime,omitempty"`
	Shippinglocationtimezone      null.String `boil:"Shippinglocationtimezone" json:"Shippinglocationtimezone,omitempty" toml:"Shippinglocationtimezone" yaml:"Shippinglocationtimezone,omitempty"`
	Receivinglocationtimezone     null.String `boil:"Receivinglocationtimezone" json:"Receivinglocationtimezone,omitempty" toml:"Receivinglocationtimezone" yaml:"Receivinglocationtimezone,omitempty"`

	R *sapOutboundDeliveryHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapOutboundDeliveryHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapOutboundDeliveryHeaderDatumColumns = struct {
	DeliveryDocument              string
	DeliveryDocumentType          string
	DocumentDate                  string
	ActualGoodsMovementDate       string
	ActualDeliveryRoute           string
	ActualGoodsMovementTime       string
	BillingDocumentDate           string
	CompleteDeliveryIsDefined     string
	ConfirmationTime              string
	CreationDate                  string
	CreationTime                  string
	CustomerGroup                 string
	DeliveryBlockReason           string
	DeliveryDate                  string
	DeliveryDocumentBySupplier    string
	DeliveryIsInPlant             string
	DeliveryPriority              string
	DeliveryTime                  string
	GoodsIssueOrReceiptSlipNumber string
	GoodsIssueTime                string
	HeaderBillingBlockReason      string
	HeaderGrossWeight             string
	HeaderNetWeight               string
	HeaderVolume                  string
	HeaderVolumeUnit              string
	HeaderWeightUnit              string
	IncotermsClassification       string
	IsExportDelivery              string
	LastChangeDate                string
	LoadingDate                   string
	LoadingPoint                  string
	LoadingTime                   string
	MeansOfTransport              string
	OrderCombinationIsAllowed     string
	OrderID                       string
	OverallDelivConfStatus        string
	OverallDelivReltdBillgStatus  string
	OverallGoodsMovementStatus    string
	OverallPackingStatus          string
	OverallPickingConfStatus      string
	OverallPickingStatus          string
	PickingDate                   string
	PickingTime                   string
	PlannedGoodsIssueDate         string
	ReceivingPlant                string
	ShippingCondition             string
	ShippingPoint                 string
	ShippingType                  string
	ShipToParty                   string
	SoldToParty                   string
	Supplier                      string
	TransportationGroup           string
	TransportationPlanningDate    string
	TransportationPlanningTime    string
	Shippinglocationtimezone      string
	Receivinglocationtimezone     string
}{
	DeliveryDocument:              "DeliveryDocument",
	DeliveryDocumentType:          "DeliveryDocumentType",
	DocumentDate:                  "DocumentDate",
	ActualGoodsMovementDate:       "ActualGoodsMovementDate",
	ActualDeliveryRoute:           "ActualDeliveryRoute",
	ActualGoodsMovementTime:       "ActualGoodsMovementTime",
	BillingDocumentDate:           "BillingDocumentDate",
	CompleteDeliveryIsDefined:     "CompleteDeliveryIsDefined",
	ConfirmationTime:              "ConfirmationTime",
	CreationDate:                  "CreationDate",
	CreationTime:                  "CreationTime",
	CustomerGroup:                 "CustomerGroup",
	DeliveryBlockReason:           "DeliveryBlockReason",
	DeliveryDate:                  "DeliveryDate",
	DeliveryDocumentBySupplier:    "DeliveryDocumentBySupplier",
	DeliveryIsInPlant:             "DeliveryIsInPlant",
	DeliveryPriority:              "DeliveryPriority",
	DeliveryTime:                  "DeliveryTime",
	GoodsIssueOrReceiptSlipNumber: "GoodsIssueOrReceiptSlipNumber",
	GoodsIssueTime:                "GoodsIssueTime",
	HeaderBillingBlockReason:      "HeaderBillingBlockReason",
	HeaderGrossWeight:             "HeaderGrossWeight",
	HeaderNetWeight:               "HeaderNetWeight",
	HeaderVolume:                  "HeaderVolume",
	HeaderVolumeUnit:              "HeaderVolumeUnit",
	HeaderWeightUnit:              "HeaderWeightUnit",
	IncotermsClassification:       "IncotermsClassification",
	IsExportDelivery:              "IsExportDelivery",
	LastChangeDate:                "LastChangeDate",
	LoadingDate:                   "LoadingDate",
	LoadingPoint:                  "LoadingPoint",
	LoadingTime:                   "LoadingTime",
	MeansOfTransport:              "MeansOfTransport",
	OrderCombinationIsAllowed:     "OrderCombinationIsAllowed",
	OrderID:                       "OrderID",
	OverallDelivConfStatus:        "OverallDelivConfStatus",
	OverallDelivReltdBillgStatus:  "OverallDelivReltdBillgStatus",
	OverallGoodsMovementStatus:    "OverallGoodsMovementStatus",
	OverallPackingStatus:          "OverallPackingStatus",
	OverallPickingConfStatus:      "OverallPickingConfStatus",
	OverallPickingStatus:          "OverallPickingStatus",
	PickingDate:                   "PickingDate",
	PickingTime:                   "PickingTime",
	PlannedGoodsIssueDate:         "PlannedGoodsIssueDate",
	ReceivingPlant:                "ReceivingPlant",
	ShippingCondition:             "ShippingCondition",
	ShippingPoint:                 "ShippingPoint",
	ShippingType:                  "ShippingType",
	ShipToParty:                   "ShipToParty",
	SoldToParty:                   "SoldToParty",
	Supplier:                      "Supplier",
	TransportationGroup:           "TransportationGroup",
	TransportationPlanningDate:    "TransportationPlanningDate",
	TransportationPlanningTime:    "TransportationPlanningTime",
	Shippinglocationtimezone:      "Shippinglocationtimezone",
	Receivinglocationtimezone:     "Receivinglocationtimezone",
}

var SapOutboundDeliveryHeaderDatumTableColumns = struct {
	DeliveryDocument              string
	DeliveryDocumentType          string
	DocumentDate                  string
	ActualGoodsMovementDate       string
	ActualDeliveryRoute           string
	ActualGoodsMovementTime       string
	BillingDocumentDate           string
	CompleteDeliveryIsDefined     string
	ConfirmationTime              string
	CreationDate                  string
	CreationTime                  string
	CustomerGroup                 string
	DeliveryBlockReason           string
	DeliveryDate                  string
	DeliveryDocumentBySupplier    string
	DeliveryIsInPlant             string
	DeliveryPriority              string
	DeliveryTime                  string
	GoodsIssueOrReceiptSlipNumber string
	GoodsIssueTime                string
	HeaderBillingBlockReason      string
	HeaderGrossWeight             string
	HeaderNetWeight               string
	HeaderVolume                  string
	HeaderVolumeUnit              string
	HeaderWeightUnit              string
	IncotermsClassification       string
	IsExportDelivery              string
	LastChangeDate                string
	LoadingDate                   string
	LoadingPoint                  string
	LoadingTime                   string
	MeansOfTransport              string
	OrderCombinationIsAllowed     string
	OrderID                       string
	OverallDelivConfStatus        string
	OverallDelivReltdBillgStatus  string
	OverallGoodsMovementStatus    string
	OverallPackingStatus          string
	OverallPickingConfStatus      string
	OverallPickingStatus          string
	PickingDate                   string
	PickingTime                   string
	PlannedGoodsIssueDate         string
	ReceivingPlant                string
	ShippingCondition             string
	ShippingPoint                 string
	ShippingType                  string
	ShipToParty                   string
	SoldToParty                   string
	Supplier                      string
	TransportationGroup           string
	TransportationPlanningDate    string
	TransportationPlanningTime    string
	Shippinglocationtimezone      string
	Receivinglocationtimezone     string
}{
	DeliveryDocument:              "sap_outbound_delivery_header_data.DeliveryDocument",
	DeliveryDocumentType:          "sap_outbound_delivery_header_data.DeliveryDocumentType",
	DocumentDate:                  "sap_outbound_delivery_header_data.DocumentDate",
	ActualGoodsMovementDate:       "sap_outbound_delivery_header_data.ActualGoodsMovementDate",
	ActualDeliveryRoute:           "sap_outbound_delivery_header_data.ActualDeliveryRoute",
	ActualGoodsMovementTime:       "sap_outbound_delivery_header_data.ActualGoodsMovementTime",
	BillingDocumentDate:           "sap_outbound_delivery_header_data.BillingDocumentDate",
	CompleteDeliveryIsDefined:     "sap_outbound_delivery_header_data.CompleteDeliveryIsDefined",
	ConfirmationTime:              "sap_outbound_delivery_header_data.ConfirmationTime",
	CreationDate:                  "sap_outbound_delivery_header_data.CreationDate",
	CreationTime:                  "sap_outbound_delivery_header_data.CreationTime",
	CustomerGroup:                 "sap_outbound_delivery_header_data.CustomerGroup",
	DeliveryBlockReason:           "sap_outbound_delivery_header_data.DeliveryBlockReason",
	DeliveryDate:                  "sap_outbound_delivery_header_data.DeliveryDate",
	DeliveryDocumentBySupplier:    "sap_outbound_delivery_header_data.DeliveryDocumentBySupplier",
	DeliveryIsInPlant:             "sap_outbound_delivery_header_data.DeliveryIsInPlant",
	DeliveryPriority:              "sap_outbound_delivery_header_data.DeliveryPriority",
	DeliveryTime:                  "sap_outbound_delivery_header_data.DeliveryTime",
	GoodsIssueOrReceiptSlipNumber: "sap_outbound_delivery_header_data.GoodsIssueOrReceiptSlipNumber",
	GoodsIssueTime:                "sap_outbound_delivery_header_data.GoodsIssueTime",
	HeaderBillingBlockReason:      "sap_outbound_delivery_header_data.HeaderBillingBlockReason",
	HeaderGrossWeight:             "sap_outbound_delivery_header_data.HeaderGrossWeight",
	HeaderNetWeight:               "sap_outbound_delivery_header_data.HeaderNetWeight",
	HeaderVolume:                  "sap_outbound_delivery_header_data.HeaderVolume",
	HeaderVolumeUnit:              "sap_outbound_delivery_header_data.HeaderVolumeUnit",
	HeaderWeightUnit:              "sap_outbound_delivery_header_data.HeaderWeightUnit",
	IncotermsClassification:       "sap_outbound_delivery_header_data.IncotermsClassification",
	IsExportDelivery:              "sap_outbound_delivery_header_data.IsExportDelivery",
	LastChangeDate:                "sap_outbound_delivery_header_data.LastChangeDate",
	LoadingDate:                   "sap_outbound_delivery_header_data.LoadingDate",
	LoadingPoint:                  "sap_outbound_delivery_header_data.LoadingPoint",
	LoadingTime:                   "sap_outbound_delivery_header_data.LoadingTime",
	MeansOfTransport:              "sap_outbound_delivery_header_data.MeansOfTransport",
	OrderCombinationIsAllowed:     "sap_outbound_delivery_header_data.OrderCombinationIsAllowed",
	OrderID:                       "sap_outbound_delivery_header_data.OrderID",
	OverallDelivConfStatus:        "sap_outbound_delivery_header_data.OverallDelivConfStatus",
	OverallDelivReltdBillgStatus:  "sap_outbound_delivery_header_data.OverallDelivReltdBillgStatus",
	OverallGoodsMovementStatus:    "sap_outbound_delivery_header_data.OverallGoodsMovementStatus",
	OverallPackingStatus:          "sap_outbound_delivery_header_data.OverallPackingStatus",
	OverallPickingConfStatus:      "sap_outbound_delivery_header_data.OverallPickingConfStatus",
	OverallPickingStatus:          "sap_outbound_delivery_header_data.OverallPickingStatus",
	PickingDate:                   "sap_outbound_delivery_header_data.PickingDate",
	PickingTime:                   "sap_outbound_delivery_header_data.PickingTime",
	PlannedGoodsIssueDate:         "sap_outbound_delivery_header_data.PlannedGoodsIssueDate",
	ReceivingPlant:                "sap_outbound_delivery_header_data.ReceivingPlant",
	ShippingCondition:             "sap_outbound_delivery_header_data.ShippingCondition",
	ShippingPoint:                 "sap_outbound_delivery_header_data.ShippingPoint",
	ShippingType:                  "sap_outbound_delivery_header_data.ShippingType",
	ShipToParty:                   "sap_outbound_delivery_header_data.ShipToParty",
	SoldToParty:                   "sap_outbound_delivery_header_data.SoldToParty",
	Supplier:                      "sap_outbound_delivery_header_data.Supplier",
	TransportationGroup:           "sap_outbound_delivery_header_data.TransportationGroup",
	TransportationPlanningDate:    "sap_outbound_delivery_header_data.TransportationPlanningDate",
	TransportationPlanningTime:    "sap_outbound_delivery_header_data.TransportationPlanningTime",
	Shippinglocationtimezone:      "sap_outbound_delivery_header_data.Shippinglocationtimezone",
	Receivinglocationtimezone:     "sap_outbound_delivery_header_data.Receivinglocationtimezone",
}

// Generated where

var SapOutboundDeliveryHeaderDatumWhere = struct {
	DeliveryDocument              whereHelperstring
	DeliveryDocumentType          whereHelpernull_String
	DocumentDate                  whereHelpernull_String
	ActualGoodsMovementDate       whereHelpernull_String
	ActualDeliveryRoute           whereHelpernull_String
	ActualGoodsMovementTime       whereHelpernull_String
	BillingDocumentDate           whereHelpernull_String
	CompleteDeliveryIsDefined     whereHelpernull_Bool
	ConfirmationTime              whereHelpernull_String
	CreationDate                  whereHelpernull_String
	CreationTime                  whereHelpernull_String
	CustomerGroup                 whereHelpernull_String
	DeliveryBlockReason           whereHelpernull_String
	DeliveryDate                  whereHelpernull_String
	DeliveryDocumentBySupplier    whereHelpernull_String
	DeliveryIsInPlant             whereHelpernull_Bool
	DeliveryPriority              whereHelpernull_String
	DeliveryTime                  whereHelpernull_String
	GoodsIssueOrReceiptSlipNumber whereHelpernull_String
	GoodsIssueTime                whereHelpernull_String
	HeaderBillingBlockReason      whereHelpernull_String
	HeaderGrossWeight             whereHelpernull_String
	HeaderNetWeight               whereHelpernull_String
	HeaderVolume                  whereHelpernull_String
	HeaderVolumeUnit              whereHelpernull_String
	HeaderWeightUnit              whereHelpernull_String
	IncotermsClassification       whereHelpernull_String
	IsExportDelivery              whereHelpernull_String
	LastChangeDate                whereHelpernull_String
	LoadingDate                   whereHelpernull_String
	LoadingPoint                  whereHelpernull_String
	LoadingTime                   whereHelpernull_String
	MeansOfTransport              whereHelpernull_String
	OrderCombinationIsAllowed     whereHelpernull_Bool
	OrderID                       whereHelpernull_String
	OverallDelivConfStatus        whereHelpernull_String
	OverallDelivReltdBillgStatus  whereHelpernull_String
	OverallGoodsMovementStatus    whereHelpernull_String
	OverallPackingStatus          whereHelpernull_String
	OverallPickingConfStatus      whereHelpernull_String
	OverallPickingStatus          whereHelpernull_String
	PickingDate                   whereHelpernull_String
	PickingTime                   whereHelpernull_String
	PlannedGoodsIssueDate         whereHelpernull_String
	ReceivingPlant                whereHelpernull_String
	ShippingCondition             whereHelpernull_String
	ShippingPoint                 whereHelpernull_String
	ShippingType                  whereHelpernull_String
	ShipToParty                   whereHelpernull_String
	SoldToParty                   whereHelpernull_String
	Supplier                      whereHelpernull_String
	TransportationGroup           whereHelpernull_String
	TransportationPlanningDate    whereHelpernull_String
	TransportationPlanningTime    whereHelpernull_String
	Shippinglocationtimezone      whereHelpernull_String
	Receivinglocationtimezone     whereHelpernull_String
}{
	DeliveryDocument:              whereHelperstring{field: "`sap_outbound_delivery_header_data`.`DeliveryDocument`"},
	DeliveryDocumentType:          whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`DeliveryDocumentType`"},
	DocumentDate:                  whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`DocumentDate`"},
	ActualGoodsMovementDate:       whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`ActualGoodsMovementDate`"},
	ActualDeliveryRoute:           whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`ActualDeliveryRoute`"},
	ActualGoodsMovementTime:       whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`ActualGoodsMovementTime`"},
	BillingDocumentDate:           whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`BillingDocumentDate`"},
	CompleteDeliveryIsDefined:     whereHelpernull_Bool{field: "`sap_outbound_delivery_header_data`.`CompleteDeliveryIsDefined`"},
	ConfirmationTime:              whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`ConfirmationTime`"},
	CreationDate:                  whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`CreationDate`"},
	CreationTime:                  whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`CreationTime`"},
	CustomerGroup:                 whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`CustomerGroup`"},
	DeliveryBlockReason:           whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`DeliveryBlockReason`"},
	DeliveryDate:                  whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`DeliveryDate`"},
	DeliveryDocumentBySupplier:    whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`DeliveryDocumentBySupplier`"},
	DeliveryIsInPlant:             whereHelpernull_Bool{field: "`sap_outbound_delivery_header_data`.`DeliveryIsInPlant`"},
	DeliveryPriority:              whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`DeliveryPriority`"},
	DeliveryTime:                  whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`DeliveryTime`"},
	GoodsIssueOrReceiptSlipNumber: whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`GoodsIssueOrReceiptSlipNumber`"},
	GoodsIssueTime:                whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`GoodsIssueTime`"},
	HeaderBillingBlockReason:      whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`HeaderBillingBlockReason`"},
	HeaderGrossWeight:             whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`HeaderGrossWeight`"},
	HeaderNetWeight:               whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`HeaderNetWeight`"},
	HeaderVolume:                  whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`HeaderVolume`"},
	HeaderVolumeUnit:              whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`HeaderVolumeUnit`"},
	HeaderWeightUnit:              whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`HeaderWeightUnit`"},
	IncotermsClassification:       whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`IncotermsClassification`"},
	IsExportDelivery:              whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`IsExportDelivery`"},
	LastChangeDate:                whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`LastChangeDate`"},
	LoadingDate:                   whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`LoadingDate`"},
	LoadingPoint:                  whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`LoadingPoint`"},
	LoadingTime:                   whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`LoadingTime`"},
	MeansOfTransport:              whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`MeansOfTransport`"},
	OrderCombinationIsAllowed:     whereHelpernull_Bool{field: "`sap_outbound_delivery_header_data`.`OrderCombinationIsAllowed`"},
	OrderID:                       whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`OrderID`"},
	OverallDelivConfStatus:        whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`OverallDelivConfStatus`"},
	OverallDelivReltdBillgStatus:  whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`OverallDelivReltdBillgStatus`"},
	OverallGoodsMovementStatus:    whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`OverallGoodsMovementStatus`"},
	OverallPackingStatus:          whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`OverallPackingStatus`"},
	OverallPickingConfStatus:      whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`OverallPickingConfStatus`"},
	OverallPickingStatus:          whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`OverallPickingStatus`"},
	PickingDate:                   whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`PickingDate`"},
	PickingTime:                   whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`PickingTime`"},
	PlannedGoodsIssueDate:         whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`PlannedGoodsIssueDate`"},
	ReceivingPlant:                whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`ReceivingPlant`"},
	ShippingCondition:             whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`ShippingCondition`"},
	ShippingPoint:                 whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`ShippingPoint`"},
	ShippingType:                  whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`ShippingType`"},
	ShipToParty:                   whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`ShipToParty`"},
	SoldToParty:                   whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`SoldToParty`"},
	Supplier:                      whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`Supplier`"},
	TransportationGroup:           whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`TransportationGroup`"},
	TransportationPlanningDate:    whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`TransportationPlanningDate`"},
	TransportationPlanningTime:    whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`TransportationPlanningTime`"},
	Shippinglocationtimezone:      whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`Shippinglocationtimezone`"},
	Receivinglocationtimezone:     whereHelpernull_String{field: "`sap_outbound_delivery_header_data`.`Receivinglocationtimezone`"},
}

// SapOutboundDeliveryHeaderDatumRels is where relationship names are stored.
var SapOutboundDeliveryHeaderDatumRels = struct {
	SDDocumentSapOutboundDeliveryHeaderPartnerDatum          string
	DeliveryDocumentSapOutboundDeliveryItemData              string
	PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData string
}{
	SDDocumentSapOutboundDeliveryHeaderPartnerDatum:          "SDDocumentSapOutboundDeliveryHeaderPartnerDatum",
	DeliveryDocumentSapOutboundDeliveryItemData:              "DeliveryDocumentSapOutboundDeliveryItemData",
	PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData: "PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData",
}

// sapOutboundDeliveryHeaderDatumR is where relationships are stored.
type sapOutboundDeliveryHeaderDatumR struct {
	SDDocumentSapOutboundDeliveryHeaderPartnerDatum          *SapOutboundDeliveryHeaderPartnerDatum        `boil:"SDDocumentSapOutboundDeliveryHeaderPartnerDatum" json:"SDDocumentSapOutboundDeliveryHeaderPartnerDatum" toml:"SDDocumentSapOutboundDeliveryHeaderPartnerDatum" yaml:"SDDocumentSapOutboundDeliveryHeaderPartnerDatum"`
	DeliveryDocumentSapOutboundDeliveryItemData              SapOutboundDeliveryItemDatumSlice             `boil:"DeliveryDocumentSapOutboundDeliveryItemData" json:"DeliveryDocumentSapOutboundDeliveryItemData" toml:"DeliveryDocumentSapOutboundDeliveryItemData" yaml:"DeliveryDocumentSapOutboundDeliveryItemData"`
	PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData SapOutboundDeliveryItemDocumentFlowDatumSlice `boil:"PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData" json:"PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData" toml:"PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData" yaml:"PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData"`
}

// NewStruct creates a new relationship struct
func (*sapOutboundDeliveryHeaderDatumR) NewStruct() *sapOutboundDeliveryHeaderDatumR {
	return &sapOutboundDeliveryHeaderDatumR{}
}

// sapOutboundDeliveryHeaderDatumL is where Load methods for each relationship are stored.
type sapOutboundDeliveryHeaderDatumL struct{}

var (
	sapOutboundDeliveryHeaderDatumAllColumns            = []string{"DeliveryDocument", "DeliveryDocumentType", "DocumentDate", "ActualGoodsMovementDate", "ActualDeliveryRoute", "ActualGoodsMovementTime", "BillingDocumentDate", "CompleteDeliveryIsDefined", "ConfirmationTime", "CreationDate", "CreationTime", "CustomerGroup", "DeliveryBlockReason", "DeliveryDate", "DeliveryDocumentBySupplier", "DeliveryIsInPlant", "DeliveryPriority", "DeliveryTime", "GoodsIssueOrReceiptSlipNumber", "GoodsIssueTime", "HeaderBillingBlockReason", "HeaderGrossWeight", "HeaderNetWeight", "HeaderVolume", "HeaderVolumeUnit", "HeaderWeightUnit", "IncotermsClassification", "IsExportDelivery", "LastChangeDate", "LoadingDate", "LoadingPoint", "LoadingTime", "MeansOfTransport", "OrderCombinationIsAllowed", "OrderID", "OverallDelivConfStatus", "OverallDelivReltdBillgStatus", "OverallGoodsMovementStatus", "OverallPackingStatus", "OverallPickingConfStatus", "OverallPickingStatus", "PickingDate", "PickingTime", "PlannedGoodsIssueDate", "ReceivingPlant", "ShippingCondition", "ShippingPoint", "ShippingType", "ShipToParty", "SoldToParty", "Supplier", "TransportationGroup", "TransportationPlanningDate", "TransportationPlanningTime", "Shippinglocationtimezone", "Receivinglocationtimezone"}
	sapOutboundDeliveryHeaderDatumColumnsWithoutDefault = []string{"DeliveryDocument", "DeliveryDocumentType", "DocumentDate", "ActualGoodsMovementDate", "ActualDeliveryRoute", "ActualGoodsMovementTime", "BillingDocumentDate", "CompleteDeliveryIsDefined", "ConfirmationTime", "CreationDate", "CreationTime", "CustomerGroup", "DeliveryBlockReason", "DeliveryDate", "DeliveryDocumentBySupplier", "DeliveryIsInPlant", "DeliveryPriority", "DeliveryTime", "GoodsIssueOrReceiptSlipNumber", "GoodsIssueTime", "HeaderBillingBlockReason", "HeaderGrossWeight", "HeaderNetWeight", "HeaderVolume", "HeaderVolumeUnit", "HeaderWeightUnit", "IncotermsClassification", "IsExportDelivery", "LastChangeDate", "LoadingDate", "LoadingPoint", "LoadingTime", "MeansOfTransport", "OrderCombinationIsAllowed", "OrderID", "OverallDelivConfStatus", "OverallDelivReltdBillgStatus", "OverallGoodsMovementStatus", "OverallPackingStatus", "OverallPickingConfStatus", "OverallPickingStatus", "PickingDate", "PickingTime", "PlannedGoodsIssueDate", "ReceivingPlant", "ShippingCondition", "ShippingPoint", "ShippingType", "ShipToParty", "SoldToParty", "Supplier", "TransportationGroup", "TransportationPlanningDate", "TransportationPlanningTime", "Shippinglocationtimezone", "Receivinglocationtimezone"}
	sapOutboundDeliveryHeaderDatumColumnsWithDefault    = []string{}
	sapOutboundDeliveryHeaderDatumPrimaryKeyColumns     = []string{"DeliveryDocument"}
)

type (
	// SapOutboundDeliveryHeaderDatumSlice is an alias for a slice of pointers to SapOutboundDeliveryHeaderDatum.
	// This should almost always be used instead of []SapOutboundDeliveryHeaderDatum.
	SapOutboundDeliveryHeaderDatumSlice []*SapOutboundDeliveryHeaderDatum
	// SapOutboundDeliveryHeaderDatumHook is the signature for custom SapOutboundDeliveryHeaderDatum hook methods
	SapOutboundDeliveryHeaderDatumHook func(context.Context, boil.ContextExecutor, *SapOutboundDeliveryHeaderDatum) error

	sapOutboundDeliveryHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapOutboundDeliveryHeaderDatumType                 = reflect.TypeOf(&SapOutboundDeliveryHeaderDatum{})
	sapOutboundDeliveryHeaderDatumMapping              = queries.MakeStructMapping(sapOutboundDeliveryHeaderDatumType)
	sapOutboundDeliveryHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(sapOutboundDeliveryHeaderDatumType, sapOutboundDeliveryHeaderDatumMapping, sapOutboundDeliveryHeaderDatumPrimaryKeyColumns)
	sapOutboundDeliveryHeaderDatumInsertCacheMut       sync.RWMutex
	sapOutboundDeliveryHeaderDatumInsertCache          = make(map[string]insertCache)
	sapOutboundDeliveryHeaderDatumUpdateCacheMut       sync.RWMutex
	sapOutboundDeliveryHeaderDatumUpdateCache          = make(map[string]updateCache)
	sapOutboundDeliveryHeaderDatumUpsertCacheMut       sync.RWMutex
	sapOutboundDeliveryHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapOutboundDeliveryHeaderDatumBeforeInsertHooks []SapOutboundDeliveryHeaderDatumHook
var sapOutboundDeliveryHeaderDatumBeforeUpdateHooks []SapOutboundDeliveryHeaderDatumHook
var sapOutboundDeliveryHeaderDatumBeforeDeleteHooks []SapOutboundDeliveryHeaderDatumHook
var sapOutboundDeliveryHeaderDatumBeforeUpsertHooks []SapOutboundDeliveryHeaderDatumHook

var sapOutboundDeliveryHeaderDatumAfterInsertHooks []SapOutboundDeliveryHeaderDatumHook
var sapOutboundDeliveryHeaderDatumAfterSelectHooks []SapOutboundDeliveryHeaderDatumHook
var sapOutboundDeliveryHeaderDatumAfterUpdateHooks []SapOutboundDeliveryHeaderDatumHook
var sapOutboundDeliveryHeaderDatumAfterDeleteHooks []SapOutboundDeliveryHeaderDatumHook
var sapOutboundDeliveryHeaderDatumAfterUpsertHooks []SapOutboundDeliveryHeaderDatumHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapOutboundDeliveryHeaderDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapOutboundDeliveryHeaderDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapOutboundDeliveryHeaderDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapOutboundDeliveryHeaderDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapOutboundDeliveryHeaderDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapOutboundDeliveryHeaderDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapOutboundDeliveryHeaderDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapOutboundDeliveryHeaderDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapOutboundDeliveryHeaderDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapOutboundDeliveryHeaderDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapOutboundDeliveryHeaderDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapOutboundDeliveryHeaderDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapOutboundDeliveryHeaderDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapOutboundDeliveryHeaderDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapOutboundDeliveryHeaderDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapOutboundDeliveryHeaderDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapOutboundDeliveryHeaderDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapOutboundDeliveryHeaderDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapOutboundDeliveryHeaderDatumHook registers your hook function for all future operations.
func AddSapOutboundDeliveryHeaderDatumHook(hookPoint boil.HookPoint, sapOutboundDeliveryHeaderDatumHook SapOutboundDeliveryHeaderDatumHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		sapOutboundDeliveryHeaderDatumBeforeInsertHooks = append(sapOutboundDeliveryHeaderDatumBeforeInsertHooks, sapOutboundDeliveryHeaderDatumHook)
	case boil.BeforeUpdateHook:
		sapOutboundDeliveryHeaderDatumBeforeUpdateHooks = append(sapOutboundDeliveryHeaderDatumBeforeUpdateHooks, sapOutboundDeliveryHeaderDatumHook)
	case boil.BeforeDeleteHook:
		sapOutboundDeliveryHeaderDatumBeforeDeleteHooks = append(sapOutboundDeliveryHeaderDatumBeforeDeleteHooks, sapOutboundDeliveryHeaderDatumHook)
	case boil.BeforeUpsertHook:
		sapOutboundDeliveryHeaderDatumBeforeUpsertHooks = append(sapOutboundDeliveryHeaderDatumBeforeUpsertHooks, sapOutboundDeliveryHeaderDatumHook)
	case boil.AfterInsertHook:
		sapOutboundDeliveryHeaderDatumAfterInsertHooks = append(sapOutboundDeliveryHeaderDatumAfterInsertHooks, sapOutboundDeliveryHeaderDatumHook)
	case boil.AfterSelectHook:
		sapOutboundDeliveryHeaderDatumAfterSelectHooks = append(sapOutboundDeliveryHeaderDatumAfterSelectHooks, sapOutboundDeliveryHeaderDatumHook)
	case boil.AfterUpdateHook:
		sapOutboundDeliveryHeaderDatumAfterUpdateHooks = append(sapOutboundDeliveryHeaderDatumAfterUpdateHooks, sapOutboundDeliveryHeaderDatumHook)
	case boil.AfterDeleteHook:
		sapOutboundDeliveryHeaderDatumAfterDeleteHooks = append(sapOutboundDeliveryHeaderDatumAfterDeleteHooks, sapOutboundDeliveryHeaderDatumHook)
	case boil.AfterUpsertHook:
		sapOutboundDeliveryHeaderDatumAfterUpsertHooks = append(sapOutboundDeliveryHeaderDatumAfterUpsertHooks, sapOutboundDeliveryHeaderDatumHook)
	}
}

// One returns a single sapOutboundDeliveryHeaderDatum record from the query.
func (q sapOutboundDeliveryHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapOutboundDeliveryHeaderDatum, error) {
	o := &SapOutboundDeliveryHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_outbound_delivery_header_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapOutboundDeliveryHeaderDatum records from the query.
func (q sapOutboundDeliveryHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapOutboundDeliveryHeaderDatumSlice, error) {
	var o []*SapOutboundDeliveryHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapOutboundDeliveryHeaderDatum slice")
	}

	if len(sapOutboundDeliveryHeaderDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapOutboundDeliveryHeaderDatum records in the query.
func (q sapOutboundDeliveryHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_outbound_delivery_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapOutboundDeliveryHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_outbound_delivery_header_data exists")
	}

	return count > 0, nil
}

// SDDocumentSapOutboundDeliveryHeaderPartnerDatum pointed to by the foreign key.
func (o *SapOutboundDeliveryHeaderDatum) SDDocumentSapOutboundDeliveryHeaderPartnerDatum(mods ...qm.QueryMod) sapOutboundDeliveryHeaderPartnerDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`SDDocument` = ?", o.DeliveryDocument),
	}

	queryMods = append(queryMods, mods...)

	query := SapOutboundDeliveryHeaderPartnerData(queryMods...)
	queries.SetFrom(query.Query, "`sap_outbound_delivery_header_partner_data`")

	return query
}

// DeliveryDocumentSapOutboundDeliveryItemData retrieves all the sap_outbound_delivery_item_datum's SapOutboundDeliveryItemData with an executor via DeliveryDocument column.
func (o *SapOutboundDeliveryHeaderDatum) DeliveryDocumentSapOutboundDeliveryItemData(mods ...qm.QueryMod) sapOutboundDeliveryItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_outbound_delivery_item_data`.`DeliveryDocument`=?", o.DeliveryDocument),
	)

	query := SapOutboundDeliveryItemData(queryMods...)
	queries.SetFrom(query.Query, "`sap_outbound_delivery_item_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_outbound_delivery_item_data`.*"})
	}

	return query
}

// PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData retrieves all the sap_outbound_delivery_item_document_flow_datum's SapOutboundDeliveryItemDocumentFlowData with an executor via PrecedingDocument column.
func (o *SapOutboundDeliveryHeaderDatum) PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData(mods ...qm.QueryMod) sapOutboundDeliveryItemDocumentFlowDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_outbound_delivery_item_document_flow_data`.`PrecedingDocument`=?", o.DeliveryDocument),
	)

	query := SapOutboundDeliveryItemDocumentFlowData(queryMods...)
	queries.SetFrom(query.Query, "`sap_outbound_delivery_item_document_flow_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_outbound_delivery_item_document_flow_data`.*"})
	}

	return query
}

// LoadSDDocumentSapOutboundDeliveryHeaderPartnerDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (sapOutboundDeliveryHeaderDatumL) LoadSDDocumentSapOutboundDeliveryHeaderPartnerDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapOutboundDeliveryHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapOutboundDeliveryHeaderDatum
	var object *SapOutboundDeliveryHeaderDatum

	if singular {
		object = maybeSapOutboundDeliveryHeaderDatum.(*SapOutboundDeliveryHeaderDatum)
	} else {
		slice = *maybeSapOutboundDeliveryHeaderDatum.(*[]*SapOutboundDeliveryHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapOutboundDeliveryHeaderDatumR{}
		}
		args = append(args, object.DeliveryDocument)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapOutboundDeliveryHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryDocument {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryDocument)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_outbound_delivery_header_partner_data`),
		qm.WhereIn(`sap_outbound_delivery_header_partner_data.SDDocument in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SapOutboundDeliveryHeaderPartnerDatum")
	}

	var resultSlice []*SapOutboundDeliveryHeaderPartnerDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SapOutboundDeliveryHeaderPartnerDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for sap_outbound_delivery_header_partner_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_outbound_delivery_header_partner_data")
	}

	if len(sapOutboundDeliveryHeaderDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SDDocumentSapOutboundDeliveryHeaderPartnerDatum = foreign
		if foreign.R == nil {
			foreign.R = &sapOutboundDeliveryHeaderPartnerDatumR{}
		}
		foreign.R.SDDocumentSapOutboundDeliveryHeaderDatum = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeliveryDocument == foreign.SDDocument {
				local.R.SDDocumentSapOutboundDeliveryHeaderPartnerDatum = foreign
				if foreign.R == nil {
					foreign.R = &sapOutboundDeliveryHeaderPartnerDatumR{}
				}
				foreign.R.SDDocumentSapOutboundDeliveryHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// LoadDeliveryDocumentSapOutboundDeliveryItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapOutboundDeliveryHeaderDatumL) LoadDeliveryDocumentSapOutboundDeliveryItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapOutboundDeliveryHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapOutboundDeliveryHeaderDatum
	var object *SapOutboundDeliveryHeaderDatum

	if singular {
		object = maybeSapOutboundDeliveryHeaderDatum.(*SapOutboundDeliveryHeaderDatum)
	} else {
		slice = *maybeSapOutboundDeliveryHeaderDatum.(*[]*SapOutboundDeliveryHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapOutboundDeliveryHeaderDatumR{}
		}
		args = append(args, object.DeliveryDocument)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapOutboundDeliveryHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryDocument {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryDocument)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_outbound_delivery_item_data`),
		qm.WhereIn(`sap_outbound_delivery_item_data.DeliveryDocument in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_outbound_delivery_item_data")
	}

	var resultSlice []*SapOutboundDeliveryItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_outbound_delivery_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_outbound_delivery_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_outbound_delivery_item_data")
	}

	if len(sapOutboundDeliveryItemDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DeliveryDocumentSapOutboundDeliveryItemData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapOutboundDeliveryItemDatumR{}
			}
			foreign.R.DeliveryDocumentSapOutboundDeliveryHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.DeliveryDocument == foreign.DeliveryDocument {
				local.R.DeliveryDocumentSapOutboundDeliveryItemData = append(local.R.DeliveryDocumentSapOutboundDeliveryItemData, foreign)
				if foreign.R == nil {
					foreign.R = &sapOutboundDeliveryItemDatumR{}
				}
				foreign.R.DeliveryDocumentSapOutboundDeliveryHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// LoadPrecedingDocumentSapOutboundDeliveryItemDocumentFlowData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapOutboundDeliveryHeaderDatumL) LoadPrecedingDocumentSapOutboundDeliveryItemDocumentFlowData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapOutboundDeliveryHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*SapOutboundDeliveryHeaderDatum
	var object *SapOutboundDeliveryHeaderDatum

	if singular {
		object = maybeSapOutboundDeliveryHeaderDatum.(*SapOutboundDeliveryHeaderDatum)
	} else {
		slice = *maybeSapOutboundDeliveryHeaderDatum.(*[]*SapOutboundDeliveryHeaderDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapOutboundDeliveryHeaderDatumR{}
		}
		args = append(args, object.DeliveryDocument)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapOutboundDeliveryHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryDocument {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryDocument)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_outbound_delivery_item_document_flow_data`),
		qm.WhereIn(`sap_outbound_delivery_item_document_flow_data.PrecedingDocument in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_outbound_delivery_item_document_flow_data")
	}

	var resultSlice []*SapOutboundDeliveryItemDocumentFlowDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_outbound_delivery_item_document_flow_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_outbound_delivery_item_document_flow_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_outbound_delivery_item_document_flow_data")
	}

	if len(sapOutboundDeliveryItemDocumentFlowDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapOutboundDeliveryItemDocumentFlowDatumR{}
			}
			foreign.R.PrecedingDocumentSapOutboundDeliveryHeaderDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.DeliveryDocument == foreign.PrecedingDocument {
				local.R.PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData = append(local.R.PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData, foreign)
				if foreign.R == nil {
					foreign.R = &sapOutboundDeliveryItemDocumentFlowDatumR{}
				}
				foreign.R.PrecedingDocumentSapOutboundDeliveryHeaderDatum = local
				break
			}
		}
	}

	return nil
}

// SetSDDocumentSapOutboundDeliveryHeaderPartnerDatum of the sapOutboundDeliveryHeaderDatum to the related item.
// Sets o.R.SDDocumentSapOutboundDeliveryHeaderPartnerDatum to related.
// Adds o to related.R.SDDocumentSapOutboundDeliveryHeaderDatum.
func (o *SapOutboundDeliveryHeaderDatum) SetSDDocumentSapOutboundDeliveryHeaderPartnerDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SapOutboundDeliveryHeaderPartnerDatum) error {
	var err error

	if insert {
		related.SDDocument = o.DeliveryDocument

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `sap_outbound_delivery_header_partner_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"SDDocument"}),
			strmangle.WhereClause("`", "`", 0, sapOutboundDeliveryHeaderPartnerDatumPrimaryKeyColumns),
		)
		values := []interface{}{o.DeliveryDocument, related.SDDocument}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.SDDocument = o.DeliveryDocument

	}

	if o.R == nil {
		o.R = &sapOutboundDeliveryHeaderDatumR{
			SDDocumentSapOutboundDeliveryHeaderPartnerDatum: related,
		}
	} else {
		o.R.SDDocumentSapOutboundDeliveryHeaderPartnerDatum = related
	}

	if related.R == nil {
		related.R = &sapOutboundDeliveryHeaderPartnerDatumR{
			SDDocumentSapOutboundDeliveryHeaderDatum: o,
		}
	} else {
		related.R.SDDocumentSapOutboundDeliveryHeaderDatum = o
	}
	return nil
}

// AddDeliveryDocumentSapOutboundDeliveryItemData adds the given related objects to the existing relationships
// of the sap_outbound_delivery_header_datum, optionally inserting them as new records.
// Appends related to o.R.DeliveryDocumentSapOutboundDeliveryItemData.
// Sets related.R.DeliveryDocumentSapOutboundDeliveryHeaderDatum appropriately.
func (o *SapOutboundDeliveryHeaderDatum) AddDeliveryDocumentSapOutboundDeliveryItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapOutboundDeliveryItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeliveryDocument = o.DeliveryDocument
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_outbound_delivery_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"DeliveryDocument"}),
				strmangle.WhereClause("`", "`", 0, sapOutboundDeliveryItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.DeliveryDocument, rel.DeliveryDocument, rel.DeliveryDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeliveryDocument = o.DeliveryDocument
		}
	}

	if o.R == nil {
		o.R = &sapOutboundDeliveryHeaderDatumR{
			DeliveryDocumentSapOutboundDeliveryItemData: related,
		}
	} else {
		o.R.DeliveryDocumentSapOutboundDeliveryItemData = append(o.R.DeliveryDocumentSapOutboundDeliveryItemData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapOutboundDeliveryItemDatumR{
				DeliveryDocumentSapOutboundDeliveryHeaderDatum: o,
			}
		} else {
			rel.R.DeliveryDocumentSapOutboundDeliveryHeaderDatum = o
		}
	}
	return nil
}

// AddPrecedingDocumentSapOutboundDeliveryItemDocumentFlowData adds the given related objects to the existing relationships
// of the sap_outbound_delivery_header_datum, optionally inserting them as new records.
// Appends related to o.R.PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData.
// Sets related.R.PrecedingDocumentSapOutboundDeliveryHeaderDatum appropriately.
func (o *SapOutboundDeliveryHeaderDatum) AddPrecedingDocumentSapOutboundDeliveryItemDocumentFlowData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapOutboundDeliveryItemDocumentFlowDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PrecedingDocument = o.DeliveryDocument
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_outbound_delivery_item_document_flow_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"PrecedingDocument"}),
				strmangle.WhereClause("`", "`", 0, sapOutboundDeliveryItemDocumentFlowDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.DeliveryDocument, rel.PrecedingDocument, rel.PrecedingDocumentItem, rel.Deliveryversion, rel.Subsequentdocument, rel.SubsequentDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PrecedingDocument = o.DeliveryDocument
		}
	}

	if o.R == nil {
		o.R = &sapOutboundDeliveryHeaderDatumR{
			PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData: related,
		}
	} else {
		o.R.PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData = append(o.R.PrecedingDocumentSapOutboundDeliveryItemDocumentFlowData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapOutboundDeliveryItemDocumentFlowDatumR{
				PrecedingDocumentSapOutboundDeliveryHeaderDatum: o,
			}
		} else {
			rel.R.PrecedingDocumentSapOutboundDeliveryHeaderDatum = o
		}
	}
	return nil
}

// SapOutboundDeliveryHeaderData retrieves all the records using an executor.
func SapOutboundDeliveryHeaderData(mods ...qm.QueryMod) sapOutboundDeliveryHeaderDatumQuery {
	mods = append(mods, qm.From("`sap_outbound_delivery_header_data`"))
	return sapOutboundDeliveryHeaderDatumQuery{NewQuery(mods...)}
}

// FindSapOutboundDeliveryHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapOutboundDeliveryHeaderDatum(ctx context.Context, exec boil.ContextExecutor, deliveryDocument string, selectCols ...string) (*SapOutboundDeliveryHeaderDatum, error) {
	sapOutboundDeliveryHeaderDatumObj := &SapOutboundDeliveryHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_outbound_delivery_header_data` where `DeliveryDocument`=?", sel,
	)

	q := queries.Raw(query, deliveryDocument)

	err := q.Bind(ctx, exec, sapOutboundDeliveryHeaderDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_outbound_delivery_header_data")
	}

	if err = sapOutboundDeliveryHeaderDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapOutboundDeliveryHeaderDatumObj, err
	}

	return sapOutboundDeliveryHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapOutboundDeliveryHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_outbound_delivery_header_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapOutboundDeliveryHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapOutboundDeliveryHeaderDatumInsertCacheMut.RLock()
	cache, cached := sapOutboundDeliveryHeaderDatumInsertCache[key]
	sapOutboundDeliveryHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapOutboundDeliveryHeaderDatumAllColumns,
			sapOutboundDeliveryHeaderDatumColumnsWithDefault,
			sapOutboundDeliveryHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapOutboundDeliveryHeaderDatumType, sapOutboundDeliveryHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapOutboundDeliveryHeaderDatumType, sapOutboundDeliveryHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_outbound_delivery_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_outbound_delivery_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_outbound_delivery_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapOutboundDeliveryHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_outbound_delivery_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.DeliveryDocument,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_outbound_delivery_header_data")
	}

CacheNoHooks:
	if !cached {
		sapOutboundDeliveryHeaderDatumInsertCacheMut.Lock()
		sapOutboundDeliveryHeaderDatumInsertCache[key] = cache
		sapOutboundDeliveryHeaderDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapOutboundDeliveryHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapOutboundDeliveryHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapOutboundDeliveryHeaderDatumUpdateCacheMut.RLock()
	cache, cached := sapOutboundDeliveryHeaderDatumUpdateCache[key]
	sapOutboundDeliveryHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapOutboundDeliveryHeaderDatumAllColumns,
			sapOutboundDeliveryHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_outbound_delivery_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_outbound_delivery_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapOutboundDeliveryHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapOutboundDeliveryHeaderDatumType, sapOutboundDeliveryHeaderDatumMapping, append(wl, sapOutboundDeliveryHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_outbound_delivery_header_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_outbound_delivery_header_data")
	}

	if !cached {
		sapOutboundDeliveryHeaderDatumUpdateCacheMut.Lock()
		sapOutboundDeliveryHeaderDatumUpdateCache[key] = cache
		sapOutboundDeliveryHeaderDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapOutboundDeliveryHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_outbound_delivery_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_outbound_delivery_header_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapOutboundDeliveryHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapOutboundDeliveryHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_outbound_delivery_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapOutboundDeliveryHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapOutboundDeliveryHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapOutboundDeliveryHeaderDatum")
	}
	return rowsAff, nil
}

var mySQLSapOutboundDeliveryHeaderDatumUniqueColumns = []string{
	"DeliveryDocument",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapOutboundDeliveryHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_outbound_delivery_header_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapOutboundDeliveryHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapOutboundDeliveryHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapOutboundDeliveryHeaderDatumUpsertCacheMut.RLock()
	cache, cached := sapOutboundDeliveryHeaderDatumUpsertCache[key]
	sapOutboundDeliveryHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapOutboundDeliveryHeaderDatumAllColumns,
			sapOutboundDeliveryHeaderDatumColumnsWithDefault,
			sapOutboundDeliveryHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			sapOutboundDeliveryHeaderDatumAllColumns,
			sapOutboundDeliveryHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_outbound_delivery_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_outbound_delivery_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_outbound_delivery_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapOutboundDeliveryHeaderDatumType, sapOutboundDeliveryHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapOutboundDeliveryHeaderDatumType, sapOutboundDeliveryHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_outbound_delivery_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapOutboundDeliveryHeaderDatumType, sapOutboundDeliveryHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_outbound_delivery_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_outbound_delivery_header_data")
	}

CacheNoHooks:
	if !cached {
		sapOutboundDeliveryHeaderDatumUpsertCacheMut.Lock()
		sapOutboundDeliveryHeaderDatumUpsertCache[key] = cache
		sapOutboundDeliveryHeaderDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapOutboundDeliveryHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapOutboundDeliveryHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapOutboundDeliveryHeaderDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapOutboundDeliveryHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_outbound_delivery_header_data` WHERE `DeliveryDocument`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_outbound_delivery_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_outbound_delivery_header_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapOutboundDeliveryHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapOutboundDeliveryHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_outbound_delivery_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_outbound_delivery_header_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapOutboundDeliveryHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapOutboundDeliveryHeaderDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapOutboundDeliveryHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_outbound_delivery_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapOutboundDeliveryHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapOutboundDeliveryHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_outbound_delivery_header_data")
	}

	if len(sapOutboundDeliveryHeaderDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapOutboundDeliveryHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapOutboundDeliveryHeaderDatum(ctx, exec, o.DeliveryDocument)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapOutboundDeliveryHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapOutboundDeliveryHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapOutboundDeliveryHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_outbound_delivery_header_data`.* FROM `sap_outbound_delivery_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapOutboundDeliveryHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapOutboundDeliveryHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// SapOutboundDeliveryHeaderDatumExists checks if the SapOutboundDeliveryHeaderDatum row exists.
func SapOutboundDeliveryHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, deliveryDocument string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_outbound_delivery_header_data` where `DeliveryDocument`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, deliveryDocument)
	}
	row := exec.QueryRowContext(ctx, sql, deliveryDocument)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_outbound_delivery_header_data exists")
	}

	return exists, nil
}
