// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapBillOfMaterialWhereUsedListDatum is an object representing the database table.
type SapBillOfMaterialWhereUsedListDatum struct {
	BillOfMaterialItemUUID         string      `boil:"BillOfMaterialItemUUID" json:"BillOfMaterialItemUUID" toml:"BillOfMaterialItemUUID" yaml:"BillOfMaterialItemUUID"`
	BillOfMaterialComponent        null.String `boil:"BillOfMaterialComponent" json:"BillOfMaterialComponent,omitempty" toml:"BillOfMaterialComponent" yaml:"BillOfMaterialComponent,omitempty"`
	BillOfMaterialItemNumber       null.String `boil:"BillOfMaterialItemNumber" json:"BillOfMaterialItemNumber,omitempty" toml:"BillOfMaterialItemNumber" yaml:"BillOfMaterialItemNumber,omitempty"`
	HeaderChangeDocument           null.String `boil:"HeaderChangeDocument" json:"HeaderChangeDocument,omitempty" toml:"HeaderChangeDocument" yaml:"HeaderChangeDocument,omitempty"`
	BillOfMaterialCategory         null.String `boil:"BillOfMaterialCategory" json:"BillOfMaterialCategory,omitempty" toml:"BillOfMaterialCategory" yaml:"BillOfMaterialCategory,omitempty"`
	BillOfMaterial                 null.String `boil:"BillOfMaterial" json:"BillOfMaterial,omitempty" toml:"BillOfMaterial" yaml:"BillOfMaterial,omitempty"`
	BillOfMaterialVariant          null.String `boil:"BillOfMaterialVariant" json:"BillOfMaterialVariant,omitempty" toml:"BillOfMaterialVariant" yaml:"BillOfMaterialVariant,omitempty"`
	BillOfMaterialVersion          null.String `boil:"BillOfMaterialVersion" json:"BillOfMaterialVersion,omitempty" toml:"BillOfMaterialVersion" yaml:"BillOfMaterialVersion,omitempty"`
	BillOfMaterialItemCategory     null.String `boil:"BillOfMaterialItemCategory" json:"BillOfMaterialItemCategory,omitempty" toml:"BillOfMaterialItemCategory" yaml:"BillOfMaterialItemCategory,omitempty"`
	BillOfMaterialItemUnit         null.String `boil:"BillOfMaterialItemUnit" json:"BillOfMaterialItemUnit,omitempty" toml:"BillOfMaterialItemUnit" yaml:"BillOfMaterialItemUnit,omitempty"`
	BillOfMaterialItemQuantity     null.String `boil:"BillOfMaterialItemQuantity" json:"BillOfMaterialItemQuantity,omitempty" toml:"BillOfMaterialItemQuantity" yaml:"BillOfMaterialItemQuantity,omitempty"`
	EngineeringChangeDocument      null.String `boil:"EngineeringChangeDocument" json:"EngineeringChangeDocument,omitempty" toml:"EngineeringChangeDocument" yaml:"EngineeringChangeDocument,omitempty"`
	ValidityStartDate              null.String `boil:"ValidityStartDate" json:"ValidityStartDate,omitempty" toml:"ValidityStartDate" yaml:"ValidityStartDate,omitempty"`
	ValidityEndDate                null.String `boil:"ValidityEndDate" json:"ValidityEndDate,omitempty" toml:"ValidityEndDate" yaml:"ValidityEndDate,omitempty"`
	BillOfMaterialItemNodeNumber   null.String `boil:"BillOfMaterialItemNodeNumber" json:"BillOfMaterialItemNodeNumber,omitempty" toml:"BillOfMaterialItemNodeNumber" yaml:"BillOfMaterialItemNodeNumber,omitempty"`
	BOMItemDescription             null.String `boil:"BOMItemDescription" json:"BOMItemDescription,omitempty" toml:"BOMItemDescription" yaml:"BOMItemDescription,omitempty"`
	Material                       null.String `boil:"Material" json:"Material,omitempty" toml:"Material" yaml:"Material,omitempty"`
	MaterialName                   null.String `boil:"MaterialName" json:"MaterialName,omitempty" toml:"MaterialName" yaml:"MaterialName,omitempty"`
	PlantName                      null.String `boil:"PlantName" json:"PlantName,omitempty" toml:"PlantName" yaml:"PlantName,omitempty"`
	BillOfMaterialVariantUsageDesc null.String `boil:"BillOfMaterialVariantUsageDesc" json:"BillOfMaterialVariantUsageDesc,omitempty" toml:"BillOfMaterialVariantUsageDesc" yaml:"BillOfMaterialVariantUsageDesc,omitempty"`
	Plant                          null.String `boil:"Plant" json:"Plant,omitempty" toml:"Plant" yaml:"Plant,omitempty"`
	BillOfMaterialVariantUsage     null.String `boil:"BillOfMaterialVariantUsage" json:"BillOfMaterialVariantUsage,omitempty" toml:"BillOfMaterialVariantUsage" yaml:"BillOfMaterialVariantUsage,omitempty"`
	BOMVersionStatus               null.String `boil:"BOMVersionStatus" json:"BOMVersionStatus,omitempty" toml:"BOMVersionStatus" yaml:"BOMVersionStatus,omitempty"`
	BOMVersionStatusDescription    null.String `boil:"BOMVersionStatusDescription" json:"BOMVersionStatusDescription,omitempty" toml:"BOMVersionStatusDescription" yaml:"BOMVersionStatusDescription,omitempty"`

	R *sapBillOfMaterialWhereUsedListDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapBillOfMaterialWhereUsedListDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapBillOfMaterialWhereUsedListDatumColumns = struct {
	BillOfMaterialItemUUID         string
	BillOfMaterialComponent        string
	BillOfMaterialItemNumber       string
	HeaderChangeDocument           string
	BillOfMaterialCategory         string
	BillOfMaterial                 string
	BillOfMaterialVariant          string
	BillOfMaterialVersion          string
	BillOfMaterialItemCategory     string
	BillOfMaterialItemUnit         string
	BillOfMaterialItemQuantity     string
	EngineeringChangeDocument      string
	ValidityStartDate              string
	ValidityEndDate                string
	BillOfMaterialItemNodeNumber   string
	BOMItemDescription             string
	Material                       string
	MaterialName                   string
	PlantName                      string
	BillOfMaterialVariantUsageDesc string
	Plant                          string
	BillOfMaterialVariantUsage     string
	BOMVersionStatus               string
	BOMVersionStatusDescription    string
}{
	BillOfMaterialItemUUID:         "BillOfMaterialItemUUID",
	BillOfMaterialComponent:        "BillOfMaterialComponent",
	BillOfMaterialItemNumber:       "BillOfMaterialItemNumber",
	HeaderChangeDocument:           "HeaderChangeDocument",
	BillOfMaterialCategory:         "BillOfMaterialCategory",
	BillOfMaterial:                 "BillOfMaterial",
	BillOfMaterialVariant:          "BillOfMaterialVariant",
	BillOfMaterialVersion:          "BillOfMaterialVersion",
	BillOfMaterialItemCategory:     "BillOfMaterialItemCategory",
	BillOfMaterialItemUnit:         "BillOfMaterialItemUnit",
	BillOfMaterialItemQuantity:     "BillOfMaterialItemQuantity",
	EngineeringChangeDocument:      "EngineeringChangeDocument",
	ValidityStartDate:              "ValidityStartDate",
	ValidityEndDate:                "ValidityEndDate",
	BillOfMaterialItemNodeNumber:   "BillOfMaterialItemNodeNumber",
	BOMItemDescription:             "BOMItemDescription",
	Material:                       "Material",
	MaterialName:                   "MaterialName",
	PlantName:                      "PlantName",
	BillOfMaterialVariantUsageDesc: "BillOfMaterialVariantUsageDesc",
	Plant:                          "Plant",
	BillOfMaterialVariantUsage:     "BillOfMaterialVariantUsage",
	BOMVersionStatus:               "BOMVersionStatus",
	BOMVersionStatusDescription:    "BOMVersionStatusDescription",
}

var SapBillOfMaterialWhereUsedListDatumTableColumns = struct {
	BillOfMaterialItemUUID         string
	BillOfMaterialComponent        string
	BillOfMaterialItemNumber       string
	HeaderChangeDocument           string
	BillOfMaterialCategory         string
	BillOfMaterial                 string
	BillOfMaterialVariant          string
	BillOfMaterialVersion          string
	BillOfMaterialItemCategory     string
	BillOfMaterialItemUnit         string
	BillOfMaterialItemQuantity     string
	EngineeringChangeDocument      string
	ValidityStartDate              string
	ValidityEndDate                string
	BillOfMaterialItemNodeNumber   string
	BOMItemDescription             string
	Material                       string
	MaterialName                   string
	PlantName                      string
	BillOfMaterialVariantUsageDesc string
	Plant                          string
	BillOfMaterialVariantUsage     string
	BOMVersionStatus               string
	BOMVersionStatusDescription    string
}{
	BillOfMaterialItemUUID:         "sap_bill_of_material_where_used_list_data.BillOfMaterialItemUUID",
	BillOfMaterialComponent:        "sap_bill_of_material_where_used_list_data.BillOfMaterialComponent",
	BillOfMaterialItemNumber:       "sap_bill_of_material_where_used_list_data.BillOfMaterialItemNumber",
	HeaderChangeDocument:           "sap_bill_of_material_where_used_list_data.HeaderChangeDocument",
	BillOfMaterialCategory:         "sap_bill_of_material_where_used_list_data.BillOfMaterialCategory",
	BillOfMaterial:                 "sap_bill_of_material_where_used_list_data.BillOfMaterial",
	BillOfMaterialVariant:          "sap_bill_of_material_where_used_list_data.BillOfMaterialVariant",
	BillOfMaterialVersion:          "sap_bill_of_material_where_used_list_data.BillOfMaterialVersion",
	BillOfMaterialItemCategory:     "sap_bill_of_material_where_used_list_data.BillOfMaterialItemCategory",
	BillOfMaterialItemUnit:         "sap_bill_of_material_where_used_list_data.BillOfMaterialItemUnit",
	BillOfMaterialItemQuantity:     "sap_bill_of_material_where_used_list_data.BillOfMaterialItemQuantity",
	EngineeringChangeDocument:      "sap_bill_of_material_where_used_list_data.EngineeringChangeDocument",
	ValidityStartDate:              "sap_bill_of_material_where_used_list_data.ValidityStartDate",
	ValidityEndDate:                "sap_bill_of_material_where_used_list_data.ValidityEndDate",
	BillOfMaterialItemNodeNumber:   "sap_bill_of_material_where_used_list_data.BillOfMaterialItemNodeNumber",
	BOMItemDescription:             "sap_bill_of_material_where_used_list_data.BOMItemDescription",
	Material:                       "sap_bill_of_material_where_used_list_data.Material",
	MaterialName:                   "sap_bill_of_material_where_used_list_data.MaterialName",
	PlantName:                      "sap_bill_of_material_where_used_list_data.PlantName",
	BillOfMaterialVariantUsageDesc: "sap_bill_of_material_where_used_list_data.BillOfMaterialVariantUsageDesc",
	Plant:                          "sap_bill_of_material_where_used_list_data.Plant",
	BillOfMaterialVariantUsage:     "sap_bill_of_material_where_used_list_data.BillOfMaterialVariantUsage",
	BOMVersionStatus:               "sap_bill_of_material_where_used_list_data.BOMVersionStatus",
	BOMVersionStatusDescription:    "sap_bill_of_material_where_used_list_data.BOMVersionStatusDescription",
}

// Generated where

var SapBillOfMaterialWhereUsedListDatumWhere = struct {
	BillOfMaterialItemUUID         whereHelperstring
	BillOfMaterialComponent        whereHelpernull_String
	BillOfMaterialItemNumber       whereHelpernull_String
	HeaderChangeDocument           whereHelpernull_String
	BillOfMaterialCategory         whereHelpernull_String
	BillOfMaterial                 whereHelpernull_String
	BillOfMaterialVariant          whereHelpernull_String
	BillOfMaterialVersion          whereHelpernull_String
	BillOfMaterialItemCategory     whereHelpernull_String
	BillOfMaterialItemUnit         whereHelpernull_String
	BillOfMaterialItemQuantity     whereHelpernull_String
	EngineeringChangeDocument      whereHelpernull_String
	ValidityStartDate              whereHelpernull_String
	ValidityEndDate                whereHelpernull_String
	BillOfMaterialItemNodeNumber   whereHelpernull_String
	BOMItemDescription             whereHelpernull_String
	Material                       whereHelpernull_String
	MaterialName                   whereHelpernull_String
	PlantName                      whereHelpernull_String
	BillOfMaterialVariantUsageDesc whereHelpernull_String
	Plant                          whereHelpernull_String
	BillOfMaterialVariantUsage     whereHelpernull_String
	BOMVersionStatus               whereHelpernull_String
	BOMVersionStatusDescription    whereHelpernull_String
}{
	BillOfMaterialItemUUID:         whereHelperstring{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialItemUUID`"},
	BillOfMaterialComponent:        whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialComponent`"},
	BillOfMaterialItemNumber:       whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialItemNumber`"},
	HeaderChangeDocument:           whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`HeaderChangeDocument`"},
	BillOfMaterialCategory:         whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialCategory`"},
	BillOfMaterial:                 whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterial`"},
	BillOfMaterialVariant:          whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialVariant`"},
	BillOfMaterialVersion:          whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialVersion`"},
	BillOfMaterialItemCategory:     whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialItemCategory`"},
	BillOfMaterialItemUnit:         whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialItemUnit`"},
	BillOfMaterialItemQuantity:     whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialItemQuantity`"},
	EngineeringChangeDocument:      whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`EngineeringChangeDocument`"},
	ValidityStartDate:              whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`ValidityStartDate`"},
	ValidityEndDate:                whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`ValidityEndDate`"},
	BillOfMaterialItemNodeNumber:   whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialItemNodeNumber`"},
	BOMItemDescription:             whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BOMItemDescription`"},
	Material:                       whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`Material`"},
	MaterialName:                   whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`MaterialName`"},
	PlantName:                      whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`PlantName`"},
	BillOfMaterialVariantUsageDesc: whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialVariantUsageDesc`"},
	Plant:                          whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`Plant`"},
	BillOfMaterialVariantUsage:     whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BillOfMaterialVariantUsage`"},
	BOMVersionStatus:               whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BOMVersionStatus`"},
	BOMVersionStatusDescription:    whereHelpernull_String{field: "`sap_bill_of_material_where_used_list_data`.`BOMVersionStatusDescription`"},
}

// SapBillOfMaterialWhereUsedListDatumRels is where relationship names are stored.
var SapBillOfMaterialWhereUsedListDatumRels = struct {
}{}

// sapBillOfMaterialWhereUsedListDatumR is where relationships are stored.
type sapBillOfMaterialWhereUsedListDatumR struct {
}

// NewStruct creates a new relationship struct
func (*sapBillOfMaterialWhereUsedListDatumR) NewStruct() *sapBillOfMaterialWhereUsedListDatumR {
	return &sapBillOfMaterialWhereUsedListDatumR{}
}

// sapBillOfMaterialWhereUsedListDatumL is where Load methods for each relationship are stored.
type sapBillOfMaterialWhereUsedListDatumL struct{}

var (
	sapBillOfMaterialWhereUsedListDatumAllColumns            = []string{"BillOfMaterialItemUUID", "BillOfMaterialComponent", "BillOfMaterialItemNumber", "HeaderChangeDocument", "BillOfMaterialCategory", "BillOfMaterial", "BillOfMaterialVariant", "BillOfMaterialVersion", "BillOfMaterialItemCategory", "BillOfMaterialItemUnit", "BillOfMaterialItemQuantity", "EngineeringChangeDocument", "ValidityStartDate", "ValidityEndDate", "BillOfMaterialItemNodeNumber", "BOMItemDescription", "Material", "MaterialName", "PlantName", "BillOfMaterialVariantUsageDesc", "Plant", "BillOfMaterialVariantUsage", "BOMVersionStatus", "BOMVersionStatusDescription"}
	sapBillOfMaterialWhereUsedListDatumColumnsWithoutDefault = []string{"BillOfMaterialItemUUID", "BillOfMaterialComponent", "BillOfMaterialItemNumber", "HeaderChangeDocument", "BillOfMaterialCategory", "BillOfMaterial", "BillOfMaterialVariant", "BillOfMaterialVersion", "BillOfMaterialItemCategory", "BillOfMaterialItemUnit", "BillOfMaterialItemQuantity", "EngineeringChangeDocument", "ValidityStartDate", "ValidityEndDate", "BillOfMaterialItemNodeNumber", "BOMItemDescription", "Material", "MaterialName", "PlantName", "BillOfMaterialVariantUsageDesc", "Plant", "BillOfMaterialVariantUsage", "BOMVersionStatus", "BOMVersionStatusDescription"}
	sapBillOfMaterialWhereUsedListDatumColumnsWithDefault    = []string{}
	sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns     = []string{"BillOfMaterialItemUUID"}
	sapBillOfMaterialWhereUsedListDatumGeneratedColumns      = []string{}
)

type (
	// SapBillOfMaterialWhereUsedListDatumSlice is an alias for a slice of pointers to SapBillOfMaterialWhereUsedListDatum.
	// This should almost always be used instead of []SapBillOfMaterialWhereUsedListDatum.
	SapBillOfMaterialWhereUsedListDatumSlice []*SapBillOfMaterialWhereUsedListDatum
	// SapBillOfMaterialWhereUsedListDatumHook is the signature for custom SapBillOfMaterialWhereUsedListDatum hook methods
	SapBillOfMaterialWhereUsedListDatumHook func(context.Context, boil.ContextExecutor, *SapBillOfMaterialWhereUsedListDatum) error

	sapBillOfMaterialWhereUsedListDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapBillOfMaterialWhereUsedListDatumType                 = reflect.TypeOf(&SapBillOfMaterialWhereUsedListDatum{})
	sapBillOfMaterialWhereUsedListDatumMapping              = queries.MakeStructMapping(sapBillOfMaterialWhereUsedListDatumType)
	sapBillOfMaterialWhereUsedListDatumPrimaryKeyMapping, _ = queries.BindMapping(sapBillOfMaterialWhereUsedListDatumType, sapBillOfMaterialWhereUsedListDatumMapping, sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns)
	sapBillOfMaterialWhereUsedListDatumInsertCacheMut       sync.RWMutex
	sapBillOfMaterialWhereUsedListDatumInsertCache          = make(map[string]insertCache)
	sapBillOfMaterialWhereUsedListDatumUpdateCacheMut       sync.RWMutex
	sapBillOfMaterialWhereUsedListDatumUpdateCache          = make(map[string]updateCache)
	sapBillOfMaterialWhereUsedListDatumUpsertCacheMut       sync.RWMutex
	sapBillOfMaterialWhereUsedListDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapBillOfMaterialWhereUsedListDatumAfterSelectHooks []SapBillOfMaterialWhereUsedListDatumHook

var sapBillOfMaterialWhereUsedListDatumBeforeInsertHooks []SapBillOfMaterialWhereUsedListDatumHook
var sapBillOfMaterialWhereUsedListDatumAfterInsertHooks []SapBillOfMaterialWhereUsedListDatumHook

var sapBillOfMaterialWhereUsedListDatumBeforeUpdateHooks []SapBillOfMaterialWhereUsedListDatumHook
var sapBillOfMaterialWhereUsedListDatumAfterUpdateHooks []SapBillOfMaterialWhereUsedListDatumHook

var sapBillOfMaterialWhereUsedListDatumBeforeDeleteHooks []SapBillOfMaterialWhereUsedListDatumHook
var sapBillOfMaterialWhereUsedListDatumAfterDeleteHooks []SapBillOfMaterialWhereUsedListDatumHook

var sapBillOfMaterialWhereUsedListDatumBeforeUpsertHooks []SapBillOfMaterialWhereUsedListDatumHook
var sapBillOfMaterialWhereUsedListDatumAfterUpsertHooks []SapBillOfMaterialWhereUsedListDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapBillOfMaterialWhereUsedListDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBillOfMaterialWhereUsedListDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapBillOfMaterialWhereUsedListDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBillOfMaterialWhereUsedListDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapBillOfMaterialWhereUsedListDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBillOfMaterialWhereUsedListDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapBillOfMaterialWhereUsedListDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBillOfMaterialWhereUsedListDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapBillOfMaterialWhereUsedListDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBillOfMaterialWhereUsedListDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapBillOfMaterialWhereUsedListDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBillOfMaterialWhereUsedListDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapBillOfMaterialWhereUsedListDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBillOfMaterialWhereUsedListDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapBillOfMaterialWhereUsedListDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBillOfMaterialWhereUsedListDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapBillOfMaterialWhereUsedListDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBillOfMaterialWhereUsedListDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapBillOfMaterialWhereUsedListDatumHook registers your hook function for all future operations.
func AddSapBillOfMaterialWhereUsedListDatumHook(hookPoint boil.HookPoint, sapBillOfMaterialWhereUsedListDatumHook SapBillOfMaterialWhereUsedListDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapBillOfMaterialWhereUsedListDatumAfterSelectHooks = append(sapBillOfMaterialWhereUsedListDatumAfterSelectHooks, sapBillOfMaterialWhereUsedListDatumHook)
	case boil.BeforeInsertHook:
		sapBillOfMaterialWhereUsedListDatumBeforeInsertHooks = append(sapBillOfMaterialWhereUsedListDatumBeforeInsertHooks, sapBillOfMaterialWhereUsedListDatumHook)
	case boil.AfterInsertHook:
		sapBillOfMaterialWhereUsedListDatumAfterInsertHooks = append(sapBillOfMaterialWhereUsedListDatumAfterInsertHooks, sapBillOfMaterialWhereUsedListDatumHook)
	case boil.BeforeUpdateHook:
		sapBillOfMaterialWhereUsedListDatumBeforeUpdateHooks = append(sapBillOfMaterialWhereUsedListDatumBeforeUpdateHooks, sapBillOfMaterialWhereUsedListDatumHook)
	case boil.AfterUpdateHook:
		sapBillOfMaterialWhereUsedListDatumAfterUpdateHooks = append(sapBillOfMaterialWhereUsedListDatumAfterUpdateHooks, sapBillOfMaterialWhereUsedListDatumHook)
	case boil.BeforeDeleteHook:
		sapBillOfMaterialWhereUsedListDatumBeforeDeleteHooks = append(sapBillOfMaterialWhereUsedListDatumBeforeDeleteHooks, sapBillOfMaterialWhereUsedListDatumHook)
	case boil.AfterDeleteHook:
		sapBillOfMaterialWhereUsedListDatumAfterDeleteHooks = append(sapBillOfMaterialWhereUsedListDatumAfterDeleteHooks, sapBillOfMaterialWhereUsedListDatumHook)
	case boil.BeforeUpsertHook:
		sapBillOfMaterialWhereUsedListDatumBeforeUpsertHooks = append(sapBillOfMaterialWhereUsedListDatumBeforeUpsertHooks, sapBillOfMaterialWhereUsedListDatumHook)
	case boil.AfterUpsertHook:
		sapBillOfMaterialWhereUsedListDatumAfterUpsertHooks = append(sapBillOfMaterialWhereUsedListDatumAfterUpsertHooks, sapBillOfMaterialWhereUsedListDatumHook)
	}
}

// One returns a single sapBillOfMaterialWhereUsedListDatum record from the query.
func (q sapBillOfMaterialWhereUsedListDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapBillOfMaterialWhereUsedListDatum, error) {
	o := &SapBillOfMaterialWhereUsedListDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_bill_of_material_where_used_list_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapBillOfMaterialWhereUsedListDatum records from the query.
func (q sapBillOfMaterialWhereUsedListDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapBillOfMaterialWhereUsedListDatumSlice, error) {
	var o []*SapBillOfMaterialWhereUsedListDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapBillOfMaterialWhereUsedListDatum slice")
	}

	if len(sapBillOfMaterialWhereUsedListDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapBillOfMaterialWhereUsedListDatum records in the query.
func (q sapBillOfMaterialWhereUsedListDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_bill_of_material_where_used_list_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapBillOfMaterialWhereUsedListDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_bill_of_material_where_used_list_data exists")
	}

	return count > 0, nil
}

// SapBillOfMaterialWhereUsedListData retrieves all the records using an executor.
func SapBillOfMaterialWhereUsedListData(mods ...qm.QueryMod) sapBillOfMaterialWhereUsedListDatumQuery {
	mods = append(mods, qm.From("`sap_bill_of_material_where_used_list_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`sap_bill_of_material_where_used_list_data`.*"})
	}

	return sapBillOfMaterialWhereUsedListDatumQuery{q}
}

// FindSapBillOfMaterialWhereUsedListDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapBillOfMaterialWhereUsedListDatum(ctx context.Context, exec boil.ContextExecutor, billOfMaterialItemUUID string, selectCols ...string) (*SapBillOfMaterialWhereUsedListDatum, error) {
	sapBillOfMaterialWhereUsedListDatumObj := &SapBillOfMaterialWhereUsedListDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_bill_of_material_where_used_list_data` where `BillOfMaterialItemUUID`=?", sel,
	)

	q := queries.Raw(query, billOfMaterialItemUUID)

	err := q.Bind(ctx, exec, sapBillOfMaterialWhereUsedListDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_bill_of_material_where_used_list_data")
	}

	if err = sapBillOfMaterialWhereUsedListDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapBillOfMaterialWhereUsedListDatumObj, err
	}

	return sapBillOfMaterialWhereUsedListDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapBillOfMaterialWhereUsedListDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_bill_of_material_where_used_list_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapBillOfMaterialWhereUsedListDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapBillOfMaterialWhereUsedListDatumInsertCacheMut.RLock()
	cache, cached := sapBillOfMaterialWhereUsedListDatumInsertCache[key]
	sapBillOfMaterialWhereUsedListDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapBillOfMaterialWhereUsedListDatumAllColumns,
			sapBillOfMaterialWhereUsedListDatumColumnsWithDefault,
			sapBillOfMaterialWhereUsedListDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapBillOfMaterialWhereUsedListDatumType, sapBillOfMaterialWhereUsedListDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapBillOfMaterialWhereUsedListDatumType, sapBillOfMaterialWhereUsedListDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_bill_of_material_where_used_list_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_bill_of_material_where_used_list_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_bill_of_material_where_used_list_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_bill_of_material_where_used_list_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.BillOfMaterialItemUUID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_bill_of_material_where_used_list_data")
	}

CacheNoHooks:
	if !cached {
		sapBillOfMaterialWhereUsedListDatumInsertCacheMut.Lock()
		sapBillOfMaterialWhereUsedListDatumInsertCache[key] = cache
		sapBillOfMaterialWhereUsedListDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapBillOfMaterialWhereUsedListDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapBillOfMaterialWhereUsedListDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapBillOfMaterialWhereUsedListDatumUpdateCacheMut.RLock()
	cache, cached := sapBillOfMaterialWhereUsedListDatumUpdateCache[key]
	sapBillOfMaterialWhereUsedListDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapBillOfMaterialWhereUsedListDatumAllColumns,
			sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_bill_of_material_where_used_list_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_bill_of_material_where_used_list_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapBillOfMaterialWhereUsedListDatumType, sapBillOfMaterialWhereUsedListDatumMapping, append(wl, sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_bill_of_material_where_used_list_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_bill_of_material_where_used_list_data")
	}

	if !cached {
		sapBillOfMaterialWhereUsedListDatumUpdateCacheMut.Lock()
		sapBillOfMaterialWhereUsedListDatumUpdateCache[key] = cache
		sapBillOfMaterialWhereUsedListDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapBillOfMaterialWhereUsedListDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_bill_of_material_where_used_list_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_bill_of_material_where_used_list_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapBillOfMaterialWhereUsedListDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapBillOfMaterialWhereUsedListDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_bill_of_material_where_used_list_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapBillOfMaterialWhereUsedListDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapBillOfMaterialWhereUsedListDatum")
	}
	return rowsAff, nil
}

var mySQLSapBillOfMaterialWhereUsedListDatumUniqueColumns = []string{
	"BillOfMaterialItemUUID",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapBillOfMaterialWhereUsedListDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_bill_of_material_where_used_list_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapBillOfMaterialWhereUsedListDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapBillOfMaterialWhereUsedListDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapBillOfMaterialWhereUsedListDatumUpsertCacheMut.RLock()
	cache, cached := sapBillOfMaterialWhereUsedListDatumUpsertCache[key]
	sapBillOfMaterialWhereUsedListDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapBillOfMaterialWhereUsedListDatumAllColumns,
			sapBillOfMaterialWhereUsedListDatumColumnsWithDefault,
			sapBillOfMaterialWhereUsedListDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapBillOfMaterialWhereUsedListDatumAllColumns,
			sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_bill_of_material_where_used_list_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_bill_of_material_where_used_list_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_bill_of_material_where_used_list_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapBillOfMaterialWhereUsedListDatumType, sapBillOfMaterialWhereUsedListDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapBillOfMaterialWhereUsedListDatumType, sapBillOfMaterialWhereUsedListDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_bill_of_material_where_used_list_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapBillOfMaterialWhereUsedListDatumType, sapBillOfMaterialWhereUsedListDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_bill_of_material_where_used_list_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_bill_of_material_where_used_list_data")
	}

CacheNoHooks:
	if !cached {
		sapBillOfMaterialWhereUsedListDatumUpsertCacheMut.Lock()
		sapBillOfMaterialWhereUsedListDatumUpsertCache[key] = cache
		sapBillOfMaterialWhereUsedListDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapBillOfMaterialWhereUsedListDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapBillOfMaterialWhereUsedListDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapBillOfMaterialWhereUsedListDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapBillOfMaterialWhereUsedListDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_bill_of_material_where_used_list_data` WHERE `BillOfMaterialItemUUID`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_bill_of_material_where_used_list_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_bill_of_material_where_used_list_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapBillOfMaterialWhereUsedListDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapBillOfMaterialWhereUsedListDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_bill_of_material_where_used_list_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_bill_of_material_where_used_list_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapBillOfMaterialWhereUsedListDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapBillOfMaterialWhereUsedListDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapBillOfMaterialWhereUsedListDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_bill_of_material_where_used_list_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapBillOfMaterialWhereUsedListDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_bill_of_material_where_used_list_data")
	}

	if len(sapBillOfMaterialWhereUsedListDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapBillOfMaterialWhereUsedListDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapBillOfMaterialWhereUsedListDatum(ctx, exec, o.BillOfMaterialItemUUID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapBillOfMaterialWhereUsedListDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapBillOfMaterialWhereUsedListDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapBillOfMaterialWhereUsedListDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_bill_of_material_where_used_list_data`.* FROM `sap_bill_of_material_where_used_list_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapBillOfMaterialWhereUsedListDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapBillOfMaterialWhereUsedListDatumSlice")
	}

	*o = slice

	return nil
}

// SapBillOfMaterialWhereUsedListDatumExists checks if the SapBillOfMaterialWhereUsedListDatum row exists.
func SapBillOfMaterialWhereUsedListDatumExists(ctx context.Context, exec boil.ContextExecutor, billOfMaterialItemUUID string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_bill_of_material_where_used_list_data` where `BillOfMaterialItemUUID`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, billOfMaterialItemUUID)
	}
	row := exec.QueryRowContext(ctx, sql, billOfMaterialItemUUID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_bill_of_material_where_used_list_data exists")
	}

	return exists, nil
}
