// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapSalesSchedulingAgreementItemDeliveryScheduleDatum is an object representing the database table.
type SapSalesSchedulingAgreementItemDeliveryScheduleDatum struct {
	SalesSchedulingAgreement       string      `boil:"SalesSchedulingAgreement" json:"SalesSchedulingAgreement" toml:"SalesSchedulingAgreement" yaml:"SalesSchedulingAgreement"`
	SalesSchedulingAgreementItem   string      `boil:"SalesSchedulingAgreementItem" json:"SalesSchedulingAgreementItem" toml:"SalesSchedulingAgreementItem" yaml:"SalesSchedulingAgreementItem"`
	IntDeliveryScheduleNumber      string      `boil:"IntDeliveryScheduleNumber" json:"IntDeliveryScheduleNumber" toml:"IntDeliveryScheduleNumber" yaml:"IntDeliveryScheduleNumber"`
	SchedulingAgreementReleaseType null.String `boil:"SchedulingAgreementReleaseType" json:"SchedulingAgreementReleaseType,omitempty" toml:"SchedulingAgreementReleaseType" yaml:"SchedulingAgreementReleaseType,omitempty"`
	DeliveryScheduleStartDate      null.String `boil:"DeliveryScheduleStartDate" json:"DeliveryScheduleStartDate,omitempty" toml:"DeliveryScheduleStartDate" yaml:"DeliveryScheduleStartDate,omitempty"`
	DeliveryScheduleEndDate        null.String `boil:"DeliveryScheduleEndDate" json:"DeliveryScheduleEndDate,omitempty" toml:"DeliveryScheduleEndDate" yaml:"DeliveryScheduleEndDate,omitempty"`
	CustomerDeliveryScheduleNumber null.String `boil:"CustomerDeliveryScheduleNumber" json:"CustomerDeliveryScheduleNumber,omitempty" toml:"CustomerDeliveryScheduleNumber" yaml:"CustomerDeliveryScheduleNumber,omitempty"`
	DeliveryScheduleDate           null.String `boil:"DeliveryScheduleDate" json:"DeliveryScheduleDate,omitempty" toml:"DeliveryScheduleDate" yaml:"DeliveryScheduleDate,omitempty"`
	LastDeliveryDocPostingDate     null.String `boil:"LastDeliveryDocPostingDate" json:"LastDeliveryDocPostingDate,omitempty" toml:"LastDeliveryDocPostingDate" yaml:"LastDeliveryDocPostingDate,omitempty"`
	LastDeliveryDocument           null.String `boil:"LastDeliveryDocument" json:"LastDeliveryDocument,omitempty" toml:"LastDeliveryDocument" yaml:"LastDeliveryDocument,omitempty"`
	LastIntDeliveryScheduleNumber  null.String `boil:"LastIntDeliveryScheduleNumber" json:"LastIntDeliveryScheduleNumber,omitempty" toml:"LastIntDeliveryScheduleNumber" yaml:"LastIntDeliveryScheduleNumber,omitempty"`
	CreationDate                   null.String `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	DeliveryScheduleCreationDate   null.String `boil:"DeliveryScheduleCreationDate" json:"DeliveryScheduleCreationDate,omitempty" toml:"DeliveryScheduleCreationDate" yaml:"DeliveryScheduleCreationDate,omitempty"`
	LastReceiptQuantity            null.String `boil:"LastReceiptQuantity" json:"LastReceiptQuantity,omitempty" toml:"LastReceiptQuantity" yaml:"LastReceiptQuantity,omitempty"`
	CumulativeReceiptQuantity      null.String `boil:"CumulativeReceiptQuantity" json:"CumulativeReceiptQuantity,omitempty" toml:"CumulativeReceiptQuantity" yaml:"CumulativeReceiptQuantity,omitempty"`
	CumulativeIssuedQuantity       null.String `boil:"CumulativeIssuedQuantity" json:"CumulativeIssuedQuantity,omitempty" toml:"CumulativeIssuedQuantity" yaml:"CumulativeIssuedQuantity,omitempty"`
	CumulativeDeliveredQuantity    null.String `boil:"CumulativeDeliveredQuantity" json:"CumulativeDeliveredQuantity,omitempty" toml:"CumulativeDeliveredQuantity" yaml:"CumulativeDeliveredQuantity,omitempty"`
	OrderQuantityUnit              null.String `boil:"OrderQuantityUnit" json:"OrderQuantityUnit,omitempty" toml:"OrderQuantityUnit" yaml:"OrderQuantityUnit,omitempty"`
	LastChangeDate                 null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`

	R *sapSalesSchedulingAgreementItemDeliveryScheduleDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapSalesSchedulingAgreementItemDeliveryScheduleDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapSalesSchedulingAgreementItemDeliveryScheduleDatumColumns = struct {
	SalesSchedulingAgreement       string
	SalesSchedulingAgreementItem   string
	IntDeliveryScheduleNumber      string
	SchedulingAgreementReleaseType string
	DeliveryScheduleStartDate      string
	DeliveryScheduleEndDate        string
	CustomerDeliveryScheduleNumber string
	DeliveryScheduleDate           string
	LastDeliveryDocPostingDate     string
	LastDeliveryDocument           string
	LastIntDeliveryScheduleNumber  string
	CreationDate                   string
	DeliveryScheduleCreationDate   string
	LastReceiptQuantity            string
	CumulativeReceiptQuantity      string
	CumulativeIssuedQuantity       string
	CumulativeDeliveredQuantity    string
	OrderQuantityUnit              string
	LastChangeDate                 string
}{
	SalesSchedulingAgreement:       "SalesSchedulingAgreement",
	SalesSchedulingAgreementItem:   "SalesSchedulingAgreementItem",
	IntDeliveryScheduleNumber:      "IntDeliveryScheduleNumber",
	SchedulingAgreementReleaseType: "SchedulingAgreementReleaseType",
	DeliveryScheduleStartDate:      "DeliveryScheduleStartDate",
	DeliveryScheduleEndDate:        "DeliveryScheduleEndDate",
	CustomerDeliveryScheduleNumber: "CustomerDeliveryScheduleNumber",
	DeliveryScheduleDate:           "DeliveryScheduleDate",
	LastDeliveryDocPostingDate:     "LastDeliveryDocPostingDate",
	LastDeliveryDocument:           "LastDeliveryDocument",
	LastIntDeliveryScheduleNumber:  "LastIntDeliveryScheduleNumber",
	CreationDate:                   "CreationDate",
	DeliveryScheduleCreationDate:   "DeliveryScheduleCreationDate",
	LastReceiptQuantity:            "LastReceiptQuantity",
	CumulativeReceiptQuantity:      "CumulativeReceiptQuantity",
	CumulativeIssuedQuantity:       "CumulativeIssuedQuantity",
	CumulativeDeliveredQuantity:    "CumulativeDeliveredQuantity",
	OrderQuantityUnit:              "OrderQuantityUnit",
	LastChangeDate:                 "LastChangeDate",
}

var SapSalesSchedulingAgreementItemDeliveryScheduleDatumTableColumns = struct {
	SalesSchedulingAgreement       string
	SalesSchedulingAgreementItem   string
	IntDeliveryScheduleNumber      string
	SchedulingAgreementReleaseType string
	DeliveryScheduleStartDate      string
	DeliveryScheduleEndDate        string
	CustomerDeliveryScheduleNumber string
	DeliveryScheduleDate           string
	LastDeliveryDocPostingDate     string
	LastDeliveryDocument           string
	LastIntDeliveryScheduleNumber  string
	CreationDate                   string
	DeliveryScheduleCreationDate   string
	LastReceiptQuantity            string
	CumulativeReceiptQuantity      string
	CumulativeIssuedQuantity       string
	CumulativeDeliveredQuantity    string
	OrderQuantityUnit              string
	LastChangeDate                 string
}{
	SalesSchedulingAgreement:       "sap_sales_scheduling_agreement_item_delivery_schedule_data.SalesSchedulingAgreement",
	SalesSchedulingAgreementItem:   "sap_sales_scheduling_agreement_item_delivery_schedule_data.SalesSchedulingAgreementItem",
	IntDeliveryScheduleNumber:      "sap_sales_scheduling_agreement_item_delivery_schedule_data.IntDeliveryScheduleNumber",
	SchedulingAgreementReleaseType: "sap_sales_scheduling_agreement_item_delivery_schedule_data.SchedulingAgreementReleaseType",
	DeliveryScheduleStartDate:      "sap_sales_scheduling_agreement_item_delivery_schedule_data.DeliveryScheduleStartDate",
	DeliveryScheduleEndDate:        "sap_sales_scheduling_agreement_item_delivery_schedule_data.DeliveryScheduleEndDate",
	CustomerDeliveryScheduleNumber: "sap_sales_scheduling_agreement_item_delivery_schedule_data.CustomerDeliveryScheduleNumber",
	DeliveryScheduleDate:           "sap_sales_scheduling_agreement_item_delivery_schedule_data.DeliveryScheduleDate",
	LastDeliveryDocPostingDate:     "sap_sales_scheduling_agreement_item_delivery_schedule_data.LastDeliveryDocPostingDate",
	LastDeliveryDocument:           "sap_sales_scheduling_agreement_item_delivery_schedule_data.LastDeliveryDocument",
	LastIntDeliveryScheduleNumber:  "sap_sales_scheduling_agreement_item_delivery_schedule_data.LastIntDeliveryScheduleNumber",
	CreationDate:                   "sap_sales_scheduling_agreement_item_delivery_schedule_data.CreationDate",
	DeliveryScheduleCreationDate:   "sap_sales_scheduling_agreement_item_delivery_schedule_data.DeliveryScheduleCreationDate",
	LastReceiptQuantity:            "sap_sales_scheduling_agreement_item_delivery_schedule_data.LastReceiptQuantity",
	CumulativeReceiptQuantity:      "sap_sales_scheduling_agreement_item_delivery_schedule_data.CumulativeReceiptQuantity",
	CumulativeIssuedQuantity:       "sap_sales_scheduling_agreement_item_delivery_schedule_data.CumulativeIssuedQuantity",
	CumulativeDeliveredQuantity:    "sap_sales_scheduling_agreement_item_delivery_schedule_data.CumulativeDeliveredQuantity",
	OrderQuantityUnit:              "sap_sales_scheduling_agreement_item_delivery_schedule_data.OrderQuantityUnit",
	LastChangeDate:                 "sap_sales_scheduling_agreement_item_delivery_schedule_data.LastChangeDate",
}

// Generated where

var SapSalesSchedulingAgreementItemDeliveryScheduleDatumWhere = struct {
	SalesSchedulingAgreement       whereHelperstring
	SalesSchedulingAgreementItem   whereHelperstring
	IntDeliveryScheduleNumber      whereHelperstring
	SchedulingAgreementReleaseType whereHelpernull_String
	DeliveryScheduleStartDate      whereHelpernull_String
	DeliveryScheduleEndDate        whereHelpernull_String
	CustomerDeliveryScheduleNumber whereHelpernull_String
	DeliveryScheduleDate           whereHelpernull_String
	LastDeliveryDocPostingDate     whereHelpernull_String
	LastDeliveryDocument           whereHelpernull_String
	LastIntDeliveryScheduleNumber  whereHelpernull_String
	CreationDate                   whereHelpernull_String
	DeliveryScheduleCreationDate   whereHelpernull_String
	LastReceiptQuantity            whereHelpernull_String
	CumulativeReceiptQuantity      whereHelpernull_String
	CumulativeIssuedQuantity       whereHelpernull_String
	CumulativeDeliveredQuantity    whereHelpernull_String
	OrderQuantityUnit              whereHelpernull_String
	LastChangeDate                 whereHelpernull_String
}{
	SalesSchedulingAgreement:       whereHelperstring{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`SalesSchedulingAgreement`"},
	SalesSchedulingAgreementItem:   whereHelperstring{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`SalesSchedulingAgreementItem`"},
	IntDeliveryScheduleNumber:      whereHelperstring{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`IntDeliveryScheduleNumber`"},
	SchedulingAgreementReleaseType: whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`SchedulingAgreementReleaseType`"},
	DeliveryScheduleStartDate:      whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`DeliveryScheduleStartDate`"},
	DeliveryScheduleEndDate:        whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`DeliveryScheduleEndDate`"},
	CustomerDeliveryScheduleNumber: whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`CustomerDeliveryScheduleNumber`"},
	DeliveryScheduleDate:           whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`DeliveryScheduleDate`"},
	LastDeliveryDocPostingDate:     whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`LastDeliveryDocPostingDate`"},
	LastDeliveryDocument:           whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`LastDeliveryDocument`"},
	LastIntDeliveryScheduleNumber:  whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`LastIntDeliveryScheduleNumber`"},
	CreationDate:                   whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`CreationDate`"},
	DeliveryScheduleCreationDate:   whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`DeliveryScheduleCreationDate`"},
	LastReceiptQuantity:            whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`LastReceiptQuantity`"},
	CumulativeReceiptQuantity:      whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`CumulativeReceiptQuantity`"},
	CumulativeIssuedQuantity:       whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`CumulativeIssuedQuantity`"},
	CumulativeDeliveredQuantity:    whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`CumulativeDeliveredQuantity`"},
	OrderQuantityUnit:              whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`OrderQuantityUnit`"},
	LastChangeDate:                 whereHelpernull_String{field: "`sap_sales_scheduling_agreement_item_delivery_schedule_data`.`LastChangeDate`"},
}

// SapSalesSchedulingAgreementItemDeliveryScheduleDatumRels is where relationship names are stored.
var SapSalesSchedulingAgreementItemDeliveryScheduleDatumRels = struct {
	SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum string
}{
	SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum: "SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum",
}

// sapSalesSchedulingAgreementItemDeliveryScheduleDatumR is where relationships are stored.
type sapSalesSchedulingAgreementItemDeliveryScheduleDatumR struct {
	SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum *SapSalesSchedulingAgreementHeaderDatum `boil:"SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum" json:"SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum" toml:"SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum" yaml:"SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum"`
}

// NewStruct creates a new relationship struct
func (*sapSalesSchedulingAgreementItemDeliveryScheduleDatumR) NewStruct() *sapSalesSchedulingAgreementItemDeliveryScheduleDatumR {
	return &sapSalesSchedulingAgreementItemDeliveryScheduleDatumR{}
}

// sapSalesSchedulingAgreementItemDeliveryScheduleDatumL is where Load methods for each relationship are stored.
type sapSalesSchedulingAgreementItemDeliveryScheduleDatumL struct{}

var (
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumAllColumns            = []string{"SalesSchedulingAgreement", "SalesSchedulingAgreementItem", "IntDeliveryScheduleNumber", "SchedulingAgreementReleaseType", "DeliveryScheduleStartDate", "DeliveryScheduleEndDate", "CustomerDeliveryScheduleNumber", "DeliveryScheduleDate", "LastDeliveryDocPostingDate", "LastDeliveryDocument", "LastIntDeliveryScheduleNumber", "CreationDate", "DeliveryScheduleCreationDate", "LastReceiptQuantity", "CumulativeReceiptQuantity", "CumulativeIssuedQuantity", "CumulativeDeliveredQuantity", "OrderQuantityUnit", "LastChangeDate"}
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumColumnsWithoutDefault = []string{"SalesSchedulingAgreement", "SalesSchedulingAgreementItem", "IntDeliveryScheduleNumber", "SchedulingAgreementReleaseType", "DeliveryScheduleStartDate", "DeliveryScheduleEndDate", "CustomerDeliveryScheduleNumber", "DeliveryScheduleDate", "LastDeliveryDocPostingDate", "LastDeliveryDocument", "LastIntDeliveryScheduleNumber", "CreationDate", "DeliveryScheduleCreationDate", "LastReceiptQuantity", "CumulativeReceiptQuantity", "CumulativeIssuedQuantity", "CumulativeDeliveredQuantity", "OrderQuantityUnit", "LastChangeDate"}
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumColumnsWithDefault    = []string{}
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns     = []string{"SalesSchedulingAgreement", "SalesSchedulingAgreementItem", "IntDeliveryScheduleNumber"}
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumGeneratedColumns      = []string{}
)

type (
	// SapSalesSchedulingAgreementItemDeliveryScheduleDatumSlice is an alias for a slice of pointers to SapSalesSchedulingAgreementItemDeliveryScheduleDatum.
	// This should almost always be used instead of []SapSalesSchedulingAgreementItemDeliveryScheduleDatum.
	SapSalesSchedulingAgreementItemDeliveryScheduleDatumSlice []*SapSalesSchedulingAgreementItemDeliveryScheduleDatum
	// SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook is the signature for custom SapSalesSchedulingAgreementItemDeliveryScheduleDatum hook methods
	SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook func(context.Context, boil.ContextExecutor, *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) error

	sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumType                 = reflect.TypeOf(&SapSalesSchedulingAgreementItemDeliveryScheduleDatum{})
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumMapping              = queries.MakeStructMapping(sapSalesSchedulingAgreementItemDeliveryScheduleDatumType)
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyMapping, _ = queries.BindMapping(sapSalesSchedulingAgreementItemDeliveryScheduleDatumType, sapSalesSchedulingAgreementItemDeliveryScheduleDatumMapping, sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns)
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumInsertCacheMut       sync.RWMutex
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumInsertCache          = make(map[string]insertCache)
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpdateCacheMut       sync.RWMutex
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpdateCache          = make(map[string]updateCache)
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpsertCacheMut       sync.RWMutex
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterSelectHooks []SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook

var sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeInsertHooks []SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook
var sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterInsertHooks []SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook

var sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeUpdateHooks []SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook
var sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterUpdateHooks []SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook

var sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeDeleteHooks []SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook
var sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterDeleteHooks []SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook

var sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeUpsertHooks []SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook
var sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterUpsertHooks []SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapSalesSchedulingAgreementItemDeliveryScheduleDatumHook registers your hook function for all future operations.
func AddSapSalesSchedulingAgreementItemDeliveryScheduleDatumHook(hookPoint boil.HookPoint, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook SapSalesSchedulingAgreementItemDeliveryScheduleDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterSelectHooks = append(sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterSelectHooks, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook)
	case boil.BeforeInsertHook:
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeInsertHooks = append(sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeInsertHooks, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook)
	case boil.AfterInsertHook:
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterInsertHooks = append(sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterInsertHooks, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook)
	case boil.BeforeUpdateHook:
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeUpdateHooks = append(sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeUpdateHooks, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook)
	case boil.AfterUpdateHook:
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterUpdateHooks = append(sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterUpdateHooks, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook)
	case boil.BeforeDeleteHook:
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeDeleteHooks = append(sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeDeleteHooks, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook)
	case boil.AfterDeleteHook:
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterDeleteHooks = append(sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterDeleteHooks, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook)
	case boil.BeforeUpsertHook:
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeUpsertHooks = append(sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeUpsertHooks, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook)
	case boil.AfterUpsertHook:
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterUpsertHooks = append(sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterUpsertHooks, sapSalesSchedulingAgreementItemDeliveryScheduleDatumHook)
	}
}

// One returns a single sapSalesSchedulingAgreementItemDeliveryScheduleDatum record from the query.
func (q sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapSalesSchedulingAgreementItemDeliveryScheduleDatum, error) {
	o := &SapSalesSchedulingAgreementItemDeliveryScheduleDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapSalesSchedulingAgreementItemDeliveryScheduleDatum records from the query.
func (q sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapSalesSchedulingAgreementItemDeliveryScheduleDatumSlice, error) {
	var o []*SapSalesSchedulingAgreementItemDeliveryScheduleDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapSalesSchedulingAgreementItemDeliveryScheduleDatum slice")
	}

	if len(sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapSalesSchedulingAgreementItemDeliveryScheduleDatum records in the query.
func (q sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_sales_scheduling_agreement_item_delivery_schedule_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_sales_scheduling_agreement_item_delivery_schedule_data exists")
	}

	return count > 0, nil
}

// SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum pointed to by the foreign key.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum(mods ...qm.QueryMod) sapSalesSchedulingAgreementHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`SalesSchedulingAgreement` = ?", o.SalesSchedulingAgreement),
	}

	queryMods = append(queryMods, mods...)

	query := SapSalesSchedulingAgreementHeaderData(queryMods...)
	queries.SetFrom(query.Query, "`sap_sales_scheduling_agreement_header_data`")

	return query
}

// LoadSalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (sapSalesSchedulingAgreementItemDeliveryScheduleDatumL) LoadSalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapSalesSchedulingAgreementItemDeliveryScheduleDatum interface{}, mods queries.Applicator) error {
	var slice []*SapSalesSchedulingAgreementItemDeliveryScheduleDatum
	var object *SapSalesSchedulingAgreementItemDeliveryScheduleDatum

	if singular {
		object = maybeSapSalesSchedulingAgreementItemDeliveryScheduleDatum.(*SapSalesSchedulingAgreementItemDeliveryScheduleDatum)
	} else {
		slice = *maybeSapSalesSchedulingAgreementItemDeliveryScheduleDatum.(*[]*SapSalesSchedulingAgreementItemDeliveryScheduleDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapSalesSchedulingAgreementItemDeliveryScheduleDatumR{}
		}
		args = append(args, object.SalesSchedulingAgreement)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapSalesSchedulingAgreementItemDeliveryScheduleDatumR{}
			}

			for _, a := range args {
				if a == obj.SalesSchedulingAgreement {
					continue Outer
				}
			}

			args = append(args, obj.SalesSchedulingAgreement)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_sales_scheduling_agreement_header_data`),
		qm.WhereIn(`sap_sales_scheduling_agreement_header_data.SalesSchedulingAgreement in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SapSalesSchedulingAgreementHeaderDatum")
	}

	var resultSlice []*SapSalesSchedulingAgreementHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SapSalesSchedulingAgreementHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for sap_sales_scheduling_agreement_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_sales_scheduling_agreement_header_data")
	}

	if len(sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum = foreign
		if foreign.R == nil {
			foreign.R = &sapSalesSchedulingAgreementHeaderDatumR{}
		}
		foreign.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemDeliveryScheduleData = append(foreign.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemDeliveryScheduleData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.SalesSchedulingAgreement == foreign.SalesSchedulingAgreement {
				local.R.SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum = foreign
				if foreign.R == nil {
					foreign.R = &sapSalesSchedulingAgreementHeaderDatumR{}
				}
				foreign.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemDeliveryScheduleData = append(foreign.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemDeliveryScheduleData, local)
				break
			}
		}
	}

	return nil
}

// SetSalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum of the sapSalesSchedulingAgreementItemDeliveryScheduleDatum to the related item.
// Sets o.R.SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum to related.
// Adds o to related.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemDeliveryScheduleData.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) SetSalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SapSalesSchedulingAgreementHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `sap_sales_scheduling_agreement_item_delivery_schedule_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"SalesSchedulingAgreement"}),
		strmangle.WhereClause("`", "`", 0, sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.SalesSchedulingAgreement, o.SalesSchedulingAgreement, o.SalesSchedulingAgreementItem, o.IntDeliveryScheduleNumber}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.SalesSchedulingAgreement = related.SalesSchedulingAgreement
	if o.R == nil {
		o.R = &sapSalesSchedulingAgreementItemDeliveryScheduleDatumR{
			SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum: related,
		}
	} else {
		o.R.SalesSchedulingAgreementSapSalesSchedulingAgreementHeaderDatum = related
	}

	if related.R == nil {
		related.R = &sapSalesSchedulingAgreementHeaderDatumR{
			SalesSchedulingAgreementSapSalesSchedulingAgreementItemDeliveryScheduleData: SapSalesSchedulingAgreementItemDeliveryScheduleDatumSlice{o},
		}
	} else {
		related.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemDeliveryScheduleData = append(related.R.SalesSchedulingAgreementSapSalesSchedulingAgreementItemDeliveryScheduleData, o)
	}

	return nil
}

// SapSalesSchedulingAgreementItemDeliveryScheduleData retrieves all the records using an executor.
func SapSalesSchedulingAgreementItemDeliveryScheduleData(mods ...qm.QueryMod) sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery {
	mods = append(mods, qm.From("`sap_sales_scheduling_agreement_item_delivery_schedule_data`"))
	return sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery{NewQuery(mods...)}
}

// FindSapSalesSchedulingAgreementItemDeliveryScheduleDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapSalesSchedulingAgreementItemDeliveryScheduleDatum(ctx context.Context, exec boil.ContextExecutor, salesSchedulingAgreement string, salesSchedulingAgreementItem string, intDeliveryScheduleNumber string, selectCols ...string) (*SapSalesSchedulingAgreementItemDeliveryScheduleDatum, error) {
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumObj := &SapSalesSchedulingAgreementItemDeliveryScheduleDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_sales_scheduling_agreement_item_delivery_schedule_data` where `SalesSchedulingAgreement`=? AND `SalesSchedulingAgreementItem`=? AND `IntDeliveryScheduleNumber`=?", sel,
	)

	q := queries.Raw(query, salesSchedulingAgreement, salesSchedulingAgreementItem, intDeliveryScheduleNumber)

	err := q.Bind(ctx, exec, sapSalesSchedulingAgreementItemDeliveryScheduleDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	if err = sapSalesSchedulingAgreementItemDeliveryScheduleDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapSalesSchedulingAgreementItemDeliveryScheduleDatumObj, err
	}

	return sapSalesSchedulingAgreementItemDeliveryScheduleDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_sales_scheduling_agreement_item_delivery_schedule_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapSalesSchedulingAgreementItemDeliveryScheduleDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumInsertCacheMut.RLock()
	cache, cached := sapSalesSchedulingAgreementItemDeliveryScheduleDatumInsertCache[key]
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumAllColumns,
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumColumnsWithDefault,
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDeliveryScheduleDatumType, sapSalesSchedulingAgreementItemDeliveryScheduleDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDeliveryScheduleDatumType, sapSalesSchedulingAgreementItemDeliveryScheduleDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_sales_scheduling_agreement_item_delivery_schedule_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_sales_scheduling_agreement_item_delivery_schedule_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_sales_scheduling_agreement_item_delivery_schedule_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.SalesSchedulingAgreement,
		o.SalesSchedulingAgreementItem,
		o.IntDeliveryScheduleNumber,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

CacheNoHooks:
	if !cached {
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumInsertCacheMut.Lock()
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumInsertCache[key] = cache
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapSalesSchedulingAgreementItemDeliveryScheduleDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpdateCacheMut.RLock()
	cache, cached := sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpdateCache[key]
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumAllColumns,
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_sales_scheduling_agreement_item_delivery_schedule_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_sales_scheduling_agreement_item_delivery_schedule_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDeliveryScheduleDatumType, sapSalesSchedulingAgreementItemDeliveryScheduleDatumMapping, append(wl, sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_sales_scheduling_agreement_item_delivery_schedule_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	if !cached {
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpdateCacheMut.Lock()
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpdateCache[key] = cache
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapSalesSchedulingAgreementItemDeliveryScheduleDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_sales_scheduling_agreement_item_delivery_schedule_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapSalesSchedulingAgreementItemDeliveryScheduleDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapSalesSchedulingAgreementItemDeliveryScheduleDatum")
	}
	return rowsAff, nil
}

var mySQLSapSalesSchedulingAgreementItemDeliveryScheduleDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_sales_scheduling_agreement_item_delivery_schedule_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapSalesSchedulingAgreementItemDeliveryScheduleDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapSalesSchedulingAgreementItemDeliveryScheduleDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpsertCacheMut.RLock()
	cache, cached := sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpsertCache[key]
	sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumAllColumns,
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumColumnsWithDefault,
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumAllColumns,
			sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_sales_scheduling_agreement_item_delivery_schedule_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_sales_scheduling_agreement_item_delivery_schedule_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_sales_scheduling_agreement_item_delivery_schedule_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDeliveryScheduleDatumType, sapSalesSchedulingAgreementItemDeliveryScheduleDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapSalesSchedulingAgreementItemDeliveryScheduleDatumType, sapSalesSchedulingAgreementItemDeliveryScheduleDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapSalesSchedulingAgreementItemDeliveryScheduleDatumType, sapSalesSchedulingAgreementItemDeliveryScheduleDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

CacheNoHooks:
	if !cached {
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpsertCacheMut.Lock()
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpsertCache[key] = cache
		sapSalesSchedulingAgreementItemDeliveryScheduleDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapSalesSchedulingAgreementItemDeliveryScheduleDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapSalesSchedulingAgreementItemDeliveryScheduleDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_sales_scheduling_agreement_item_delivery_schedule_data` WHERE `SalesSchedulingAgreement`=? AND `SalesSchedulingAgreementItem`=? AND `IntDeliveryScheduleNumber`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapSalesSchedulingAgreementItemDeliveryScheduleDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapSalesSchedulingAgreementItemDeliveryScheduleDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapSalesSchedulingAgreementItemDeliveryScheduleDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_sales_scheduling_agreement_item_delivery_schedule_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapSalesSchedulingAgreementItemDeliveryScheduleDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_sales_scheduling_agreement_item_delivery_schedule_data")
	}

	if len(sapSalesSchedulingAgreementItemDeliveryScheduleDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapSalesSchedulingAgreementItemDeliveryScheduleDatum(ctx, exec, o.SalesSchedulingAgreement, o.SalesSchedulingAgreementItem, o.IntDeliveryScheduleNumber)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapSalesSchedulingAgreementItemDeliveryScheduleDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapSalesSchedulingAgreementItemDeliveryScheduleDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_sales_scheduling_agreement_item_delivery_schedule_data`.* FROM `sap_sales_scheduling_agreement_item_delivery_schedule_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapSalesSchedulingAgreementItemDeliveryScheduleDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapSalesSchedulingAgreementItemDeliveryScheduleDatumSlice")
	}

	*o = slice

	return nil
}

// SapSalesSchedulingAgreementItemDeliveryScheduleDatumExists checks if the SapSalesSchedulingAgreementItemDeliveryScheduleDatum row exists.
func SapSalesSchedulingAgreementItemDeliveryScheduleDatumExists(ctx context.Context, exec boil.ContextExecutor, salesSchedulingAgreement string, salesSchedulingAgreementItem string, intDeliveryScheduleNumber string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_sales_scheduling_agreement_item_delivery_schedule_data` where `SalesSchedulingAgreement`=? AND `SalesSchedulingAgreementItem`=? AND `IntDeliveryScheduleNumber`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, salesSchedulingAgreement, salesSchedulingAgreementItem, intDeliveryScheduleNumber)
	}
	row := exec.QueryRowContext(ctx, sql, salesSchedulingAgreement, salesSchedulingAgreementItem, intDeliveryScheduleNumber)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_sales_scheduling_agreement_item_delivery_schedule_data exists")
	}

	return exists, nil
}
