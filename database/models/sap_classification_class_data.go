// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapClassificationClassDatum is an object representing the database table.
type SapClassificationClassDatum struct {
	ClassInternalID          string      `boil:"ClassInternalID" json:"ClassInternalID" toml:"ClassInternalID" yaml:"ClassInternalID"`
	DeleteMc                 null.Bool   `boil:"DeleteMc" json:"DeleteMc,omitempty" toml:"DeleteMc" yaml:"DeleteMc,omitempty"`
	UpdateMc                 null.Bool   `boil:"UpdateMc" json:"UpdateMc,omitempty" toml:"UpdateMc" yaml:"UpdateMc,omitempty"`
	ToClassCharacteristicOc  null.Bool   `boil:"ToClassCharacteristicOc" json:"ToClassCharacteristicOc,omitempty" toml:"ToClassCharacteristicOc" yaml:"ToClassCharacteristicOc,omitempty"`
	ToClassDescriptionOc     null.Bool   `boil:"ToClassDescriptionOc" json:"ToClassDescriptionOc,omitempty" toml:"ToClassDescriptionOc" yaml:"ToClassDescriptionOc,omitempty"`
	ToClassKeywordOc         null.Bool   `boil:"ToClassKeywordOc" json:"ToClassKeywordOc,omitempty" toml:"ToClassKeywordOc" yaml:"ToClassKeywordOc,omitempty"`
	ToClassTextOc            null.Bool   `boil:"ToClassTextOc" json:"ToClassTextOc,omitempty" toml:"ToClassTextOc" yaml:"ToClassTextOc,omitempty"`
	ClassType                null.String `boil:"ClassType" json:"ClassType,omitempty" toml:"ClassType" yaml:"ClassType,omitempty"`
	ClassTypeName            null.String `boil:"ClassTypeName" json:"ClassTypeName,omitempty" toml:"ClassTypeName" yaml:"ClassTypeName,omitempty"`
	Class                    null.String `boil:"Class" json:"Class,omitempty" toml:"Class" yaml:"Class,omitempty"`
	ClassStatus              null.String `boil:"ClassStatus" json:"ClassStatus,omitempty" toml:"ClassStatus" yaml:"ClassStatus,omitempty"`
	ClassStatusName          null.String `boil:"ClassStatusName" json:"ClassStatusName,omitempty" toml:"ClassStatusName" yaml:"ClassStatusName,omitempty"`
	ClassGroup               null.String `boil:"ClassGroup" json:"ClassGroup,omitempty" toml:"ClassGroup" yaml:"ClassGroup,omitempty"`
	ClassGroupName           null.String `boil:"ClassGroupName" json:"ClassGroupName,omitempty" toml:"ClassGroupName" yaml:"ClassGroupName,omitempty"`
	ClassSearchAuthGrp       null.String `boil:"ClassSearchAuthGrp" json:"ClassSearchAuthGrp,omitempty" toml:"ClassSearchAuthGrp" yaml:"ClassSearchAuthGrp,omitempty"`
	ClassClassfctnAuthGrp    null.String `boil:"ClassClassfctnAuthGrp" json:"ClassClassfctnAuthGrp,omitempty" toml:"ClassClassfctnAuthGrp" yaml:"ClassClassfctnAuthGrp,omitempty"`
	ClassMaintAuthGrp        null.String `boil:"ClassMaintAuthGrp" json:"ClassMaintAuthGrp,omitempty" toml:"ClassMaintAuthGrp" yaml:"ClassMaintAuthGrp,omitempty"`
	CreationDate             null.String `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	LastChangeDate           null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	ValidityStartDate        null.String `boil:"ValidityStartDate" json:"ValidityStartDate,omitempty" toml:"ValidityStartDate" yaml:"ValidityStartDate,omitempty"`
	ValidityEndDate          null.String `boil:"ValidityEndDate" json:"ValidityEndDate,omitempty" toml:"ValidityEndDate" yaml:"ValidityEndDate,omitempty"`
	ClassLastChangedDateTime null.String `boil:"ClassLastChangedDateTime" json:"ClassLastChangedDateTime,omitempty" toml:"ClassLastChangedDateTime" yaml:"ClassLastChangedDateTime,omitempty"`
	KeyDate                  null.String `boil:"KeyDate" json:"KeyDate,omitempty" toml:"KeyDate" yaml:"KeyDate,omitempty"`

	R *sapClassificationClassDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapClassificationClassDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapClassificationClassDatumColumns = struct {
	ClassInternalID          string
	DeleteMc                 string
	UpdateMc                 string
	ToClassCharacteristicOc  string
	ToClassDescriptionOc     string
	ToClassKeywordOc         string
	ToClassTextOc            string
	ClassType                string
	ClassTypeName            string
	Class                    string
	ClassStatus              string
	ClassStatusName          string
	ClassGroup               string
	ClassGroupName           string
	ClassSearchAuthGrp       string
	ClassClassfctnAuthGrp    string
	ClassMaintAuthGrp        string
	CreationDate             string
	LastChangeDate           string
	ValidityStartDate        string
	ValidityEndDate          string
	ClassLastChangedDateTime string
	KeyDate                  string
}{
	ClassInternalID:          "ClassInternalID",
	DeleteMc:                 "DeleteMc",
	UpdateMc:                 "UpdateMc",
	ToClassCharacteristicOc:  "ToClassCharacteristicOc",
	ToClassDescriptionOc:     "ToClassDescriptionOc",
	ToClassKeywordOc:         "ToClassKeywordOc",
	ToClassTextOc:            "ToClassTextOc",
	ClassType:                "ClassType",
	ClassTypeName:            "ClassTypeName",
	Class:                    "Class",
	ClassStatus:              "ClassStatus",
	ClassStatusName:          "ClassStatusName",
	ClassGroup:               "ClassGroup",
	ClassGroupName:           "ClassGroupName",
	ClassSearchAuthGrp:       "ClassSearchAuthGrp",
	ClassClassfctnAuthGrp:    "ClassClassfctnAuthGrp",
	ClassMaintAuthGrp:        "ClassMaintAuthGrp",
	CreationDate:             "CreationDate",
	LastChangeDate:           "LastChangeDate",
	ValidityStartDate:        "ValidityStartDate",
	ValidityEndDate:          "ValidityEndDate",
	ClassLastChangedDateTime: "ClassLastChangedDateTime",
	KeyDate:                  "KeyDate",
}

var SapClassificationClassDatumTableColumns = struct {
	ClassInternalID          string
	DeleteMc                 string
	UpdateMc                 string
	ToClassCharacteristicOc  string
	ToClassDescriptionOc     string
	ToClassKeywordOc         string
	ToClassTextOc            string
	ClassType                string
	ClassTypeName            string
	Class                    string
	ClassStatus              string
	ClassStatusName          string
	ClassGroup               string
	ClassGroupName           string
	ClassSearchAuthGrp       string
	ClassClassfctnAuthGrp    string
	ClassMaintAuthGrp        string
	CreationDate             string
	LastChangeDate           string
	ValidityStartDate        string
	ValidityEndDate          string
	ClassLastChangedDateTime string
	KeyDate                  string
}{
	ClassInternalID:          "sap_classification_class_data.ClassInternalID",
	DeleteMc:                 "sap_classification_class_data.DeleteMc",
	UpdateMc:                 "sap_classification_class_data.UpdateMc",
	ToClassCharacteristicOc:  "sap_classification_class_data.ToClassCharacteristicOc",
	ToClassDescriptionOc:     "sap_classification_class_data.ToClassDescriptionOc",
	ToClassKeywordOc:         "sap_classification_class_data.ToClassKeywordOc",
	ToClassTextOc:            "sap_classification_class_data.ToClassTextOc",
	ClassType:                "sap_classification_class_data.ClassType",
	ClassTypeName:            "sap_classification_class_data.ClassTypeName",
	Class:                    "sap_classification_class_data.Class",
	ClassStatus:              "sap_classification_class_data.ClassStatus",
	ClassStatusName:          "sap_classification_class_data.ClassStatusName",
	ClassGroup:               "sap_classification_class_data.ClassGroup",
	ClassGroupName:           "sap_classification_class_data.ClassGroupName",
	ClassSearchAuthGrp:       "sap_classification_class_data.ClassSearchAuthGrp",
	ClassClassfctnAuthGrp:    "sap_classification_class_data.ClassClassfctnAuthGrp",
	ClassMaintAuthGrp:        "sap_classification_class_data.ClassMaintAuthGrp",
	CreationDate:             "sap_classification_class_data.CreationDate",
	LastChangeDate:           "sap_classification_class_data.LastChangeDate",
	ValidityStartDate:        "sap_classification_class_data.ValidityStartDate",
	ValidityEndDate:          "sap_classification_class_data.ValidityEndDate",
	ClassLastChangedDateTime: "sap_classification_class_data.ClassLastChangedDateTime",
	KeyDate:                  "sap_classification_class_data.KeyDate",
}

// Generated where

var SapClassificationClassDatumWhere = struct {
	ClassInternalID          whereHelperstring
	DeleteMc                 whereHelpernull_Bool
	UpdateMc                 whereHelpernull_Bool
	ToClassCharacteristicOc  whereHelpernull_Bool
	ToClassDescriptionOc     whereHelpernull_Bool
	ToClassKeywordOc         whereHelpernull_Bool
	ToClassTextOc            whereHelpernull_Bool
	ClassType                whereHelpernull_String
	ClassTypeName            whereHelpernull_String
	Class                    whereHelpernull_String
	ClassStatus              whereHelpernull_String
	ClassStatusName          whereHelpernull_String
	ClassGroup               whereHelpernull_String
	ClassGroupName           whereHelpernull_String
	ClassSearchAuthGrp       whereHelpernull_String
	ClassClassfctnAuthGrp    whereHelpernull_String
	ClassMaintAuthGrp        whereHelpernull_String
	CreationDate             whereHelpernull_String
	LastChangeDate           whereHelpernull_String
	ValidityStartDate        whereHelpernull_String
	ValidityEndDate          whereHelpernull_String
	ClassLastChangedDateTime whereHelpernull_String
	KeyDate                  whereHelpernull_String
}{
	ClassInternalID:          whereHelperstring{field: "`sap_classification_class_data`.`ClassInternalID`"},
	DeleteMc:                 whereHelpernull_Bool{field: "`sap_classification_class_data`.`DeleteMc`"},
	UpdateMc:                 whereHelpernull_Bool{field: "`sap_classification_class_data`.`UpdateMc`"},
	ToClassCharacteristicOc:  whereHelpernull_Bool{field: "`sap_classification_class_data`.`ToClassCharacteristicOc`"},
	ToClassDescriptionOc:     whereHelpernull_Bool{field: "`sap_classification_class_data`.`ToClassDescriptionOc`"},
	ToClassKeywordOc:         whereHelpernull_Bool{field: "`sap_classification_class_data`.`ToClassKeywordOc`"},
	ToClassTextOc:            whereHelpernull_Bool{field: "`sap_classification_class_data`.`ToClassTextOc`"},
	ClassType:                whereHelpernull_String{field: "`sap_classification_class_data`.`ClassType`"},
	ClassTypeName:            whereHelpernull_String{field: "`sap_classification_class_data`.`ClassTypeName`"},
	Class:                    whereHelpernull_String{field: "`sap_classification_class_data`.`Class`"},
	ClassStatus:              whereHelpernull_String{field: "`sap_classification_class_data`.`ClassStatus`"},
	ClassStatusName:          whereHelpernull_String{field: "`sap_classification_class_data`.`ClassStatusName`"},
	ClassGroup:               whereHelpernull_String{field: "`sap_classification_class_data`.`ClassGroup`"},
	ClassGroupName:           whereHelpernull_String{field: "`sap_classification_class_data`.`ClassGroupName`"},
	ClassSearchAuthGrp:       whereHelpernull_String{field: "`sap_classification_class_data`.`ClassSearchAuthGrp`"},
	ClassClassfctnAuthGrp:    whereHelpernull_String{field: "`sap_classification_class_data`.`ClassClassfctnAuthGrp`"},
	ClassMaintAuthGrp:        whereHelpernull_String{field: "`sap_classification_class_data`.`ClassMaintAuthGrp`"},
	CreationDate:             whereHelpernull_String{field: "`sap_classification_class_data`.`CreationDate`"},
	LastChangeDate:           whereHelpernull_String{field: "`sap_classification_class_data`.`LastChangeDate`"},
	ValidityStartDate:        whereHelpernull_String{field: "`sap_classification_class_data`.`ValidityStartDate`"},
	ValidityEndDate:          whereHelpernull_String{field: "`sap_classification_class_data`.`ValidityEndDate`"},
	ClassLastChangedDateTime: whereHelpernull_String{field: "`sap_classification_class_data`.`ClassLastChangedDateTime`"},
	KeyDate:                  whereHelpernull_String{field: "`sap_classification_class_data`.`KeyDate`"},
}

// SapClassificationClassDatumRels is where relationship names are stored.
var SapClassificationClassDatumRels = struct {
	ClassInternalIDSapClassificationCharacteristicData   string
	ClassInternalIDSapClassificationClassDescriptionData string
}{
	ClassInternalIDSapClassificationCharacteristicData:   "ClassInternalIDSapClassificationCharacteristicData",
	ClassInternalIDSapClassificationClassDescriptionData: "ClassInternalIDSapClassificationClassDescriptionData",
}

// sapClassificationClassDatumR is where relationships are stored.
type sapClassificationClassDatumR struct {
	ClassInternalIDSapClassificationCharacteristicData   SapClassificationCharacteristicDatumSlice   `boil:"ClassInternalIDSapClassificationCharacteristicData" json:"ClassInternalIDSapClassificationCharacteristicData" toml:"ClassInternalIDSapClassificationCharacteristicData" yaml:"ClassInternalIDSapClassificationCharacteristicData"`
	ClassInternalIDSapClassificationClassDescriptionData SapClassificationClassDescriptionDatumSlice `boil:"ClassInternalIDSapClassificationClassDescriptionData" json:"ClassInternalIDSapClassificationClassDescriptionData" toml:"ClassInternalIDSapClassificationClassDescriptionData" yaml:"ClassInternalIDSapClassificationClassDescriptionData"`
}

// NewStruct creates a new relationship struct
func (*sapClassificationClassDatumR) NewStruct() *sapClassificationClassDatumR {
	return &sapClassificationClassDatumR{}
}

// sapClassificationClassDatumL is where Load methods for each relationship are stored.
type sapClassificationClassDatumL struct{}

var (
	sapClassificationClassDatumAllColumns            = []string{"ClassInternalID", "DeleteMc", "UpdateMc", "ToClassCharacteristicOc", "ToClassDescriptionOc", "ToClassKeywordOc", "ToClassTextOc", "ClassType", "ClassTypeName", "Class", "ClassStatus", "ClassStatusName", "ClassGroup", "ClassGroupName", "ClassSearchAuthGrp", "ClassClassfctnAuthGrp", "ClassMaintAuthGrp", "CreationDate", "LastChangeDate", "ValidityStartDate", "ValidityEndDate", "ClassLastChangedDateTime", "KeyDate"}
	sapClassificationClassDatumColumnsWithoutDefault = []string{"ClassInternalID", "DeleteMc", "UpdateMc", "ToClassCharacteristicOc", "ToClassDescriptionOc", "ToClassKeywordOc", "ToClassTextOc", "ClassType", "ClassTypeName", "Class", "ClassStatus", "ClassStatusName", "ClassGroup", "ClassGroupName", "ClassSearchAuthGrp", "ClassClassfctnAuthGrp", "ClassMaintAuthGrp", "CreationDate", "LastChangeDate", "ValidityStartDate", "ValidityEndDate", "ClassLastChangedDateTime", "KeyDate"}
	sapClassificationClassDatumColumnsWithDefault    = []string{}
	sapClassificationClassDatumPrimaryKeyColumns     = []string{"ClassInternalID"}
	sapClassificationClassDatumGeneratedColumns      = []string{}
)

type (
	// SapClassificationClassDatumSlice is an alias for a slice of pointers to SapClassificationClassDatum.
	// This should almost always be used instead of []SapClassificationClassDatum.
	SapClassificationClassDatumSlice []*SapClassificationClassDatum
	// SapClassificationClassDatumHook is the signature for custom SapClassificationClassDatum hook methods
	SapClassificationClassDatumHook func(context.Context, boil.ContextExecutor, *SapClassificationClassDatum) error

	sapClassificationClassDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapClassificationClassDatumType                 = reflect.TypeOf(&SapClassificationClassDatum{})
	sapClassificationClassDatumMapping              = queries.MakeStructMapping(sapClassificationClassDatumType)
	sapClassificationClassDatumPrimaryKeyMapping, _ = queries.BindMapping(sapClassificationClassDatumType, sapClassificationClassDatumMapping, sapClassificationClassDatumPrimaryKeyColumns)
	sapClassificationClassDatumInsertCacheMut       sync.RWMutex
	sapClassificationClassDatumInsertCache          = make(map[string]insertCache)
	sapClassificationClassDatumUpdateCacheMut       sync.RWMutex
	sapClassificationClassDatumUpdateCache          = make(map[string]updateCache)
	sapClassificationClassDatumUpsertCacheMut       sync.RWMutex
	sapClassificationClassDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapClassificationClassDatumAfterSelectHooks []SapClassificationClassDatumHook

var sapClassificationClassDatumBeforeInsertHooks []SapClassificationClassDatumHook
var sapClassificationClassDatumAfterInsertHooks []SapClassificationClassDatumHook

var sapClassificationClassDatumBeforeUpdateHooks []SapClassificationClassDatumHook
var sapClassificationClassDatumAfterUpdateHooks []SapClassificationClassDatumHook

var sapClassificationClassDatumBeforeDeleteHooks []SapClassificationClassDatumHook
var sapClassificationClassDatumAfterDeleteHooks []SapClassificationClassDatumHook

var sapClassificationClassDatumBeforeUpsertHooks []SapClassificationClassDatumHook
var sapClassificationClassDatumAfterUpsertHooks []SapClassificationClassDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapClassificationClassDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationClassDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapClassificationClassDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationClassDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapClassificationClassDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationClassDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapClassificationClassDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationClassDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapClassificationClassDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationClassDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapClassificationClassDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationClassDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapClassificationClassDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationClassDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapClassificationClassDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationClassDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapClassificationClassDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapClassificationClassDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapClassificationClassDatumHook registers your hook function for all future operations.
func AddSapClassificationClassDatumHook(hookPoint boil.HookPoint, sapClassificationClassDatumHook SapClassificationClassDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapClassificationClassDatumAfterSelectHooks = append(sapClassificationClassDatumAfterSelectHooks, sapClassificationClassDatumHook)
	case boil.BeforeInsertHook:
		sapClassificationClassDatumBeforeInsertHooks = append(sapClassificationClassDatumBeforeInsertHooks, sapClassificationClassDatumHook)
	case boil.AfterInsertHook:
		sapClassificationClassDatumAfterInsertHooks = append(sapClassificationClassDatumAfterInsertHooks, sapClassificationClassDatumHook)
	case boil.BeforeUpdateHook:
		sapClassificationClassDatumBeforeUpdateHooks = append(sapClassificationClassDatumBeforeUpdateHooks, sapClassificationClassDatumHook)
	case boil.AfterUpdateHook:
		sapClassificationClassDatumAfterUpdateHooks = append(sapClassificationClassDatumAfterUpdateHooks, sapClassificationClassDatumHook)
	case boil.BeforeDeleteHook:
		sapClassificationClassDatumBeforeDeleteHooks = append(sapClassificationClassDatumBeforeDeleteHooks, sapClassificationClassDatumHook)
	case boil.AfterDeleteHook:
		sapClassificationClassDatumAfterDeleteHooks = append(sapClassificationClassDatumAfterDeleteHooks, sapClassificationClassDatumHook)
	case boil.BeforeUpsertHook:
		sapClassificationClassDatumBeforeUpsertHooks = append(sapClassificationClassDatumBeforeUpsertHooks, sapClassificationClassDatumHook)
	case boil.AfterUpsertHook:
		sapClassificationClassDatumAfterUpsertHooks = append(sapClassificationClassDatumAfterUpsertHooks, sapClassificationClassDatumHook)
	}
}

// One returns a single sapClassificationClassDatum record from the query.
func (q sapClassificationClassDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapClassificationClassDatum, error) {
	o := &SapClassificationClassDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_classification_class_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapClassificationClassDatum records from the query.
func (q sapClassificationClassDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapClassificationClassDatumSlice, error) {
	var o []*SapClassificationClassDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapClassificationClassDatum slice")
	}

	if len(sapClassificationClassDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapClassificationClassDatum records in the query.
func (q sapClassificationClassDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_classification_class_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapClassificationClassDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_classification_class_data exists")
	}

	return count > 0, nil
}

// ClassInternalIDSapClassificationCharacteristicData retrieves all the sap_classification_characteristic_datum's SapClassificationCharacteristicData with an executor via ClassInternalID column.
func (o *SapClassificationClassDatum) ClassInternalIDSapClassificationCharacteristicData(mods ...qm.QueryMod) sapClassificationCharacteristicDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_classification_characteristic_data`.`ClassInternalID`=?", o.ClassInternalID),
	)

	query := SapClassificationCharacteristicData(queryMods...)
	queries.SetFrom(query.Query, "`sap_classification_characteristic_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_classification_characteristic_data`.*"})
	}

	return query
}

// ClassInternalIDSapClassificationClassDescriptionData retrieves all the sap_classification_class_description_datum's SapClassificationClassDescriptionData with an executor via ClassInternalID column.
func (o *SapClassificationClassDatum) ClassInternalIDSapClassificationClassDescriptionData(mods ...qm.QueryMod) sapClassificationClassDescriptionDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_classification_class_description_data`.`ClassInternalID`=?", o.ClassInternalID),
	)

	query := SapClassificationClassDescriptionData(queryMods...)
	queries.SetFrom(query.Query, "`sap_classification_class_description_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_classification_class_description_data`.*"})
	}

	return query
}

// LoadClassInternalIDSapClassificationCharacteristicData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapClassificationClassDatumL) LoadClassInternalIDSapClassificationCharacteristicData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapClassificationClassDatum interface{}, mods queries.Applicator) error {
	var slice []*SapClassificationClassDatum
	var object *SapClassificationClassDatum

	if singular {
		object = maybeSapClassificationClassDatum.(*SapClassificationClassDatum)
	} else {
		slice = *maybeSapClassificationClassDatum.(*[]*SapClassificationClassDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapClassificationClassDatumR{}
		}
		args = append(args, object.ClassInternalID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapClassificationClassDatumR{}
			}

			for _, a := range args {
				if a == obj.ClassInternalID {
					continue Outer
				}
			}

			args = append(args, obj.ClassInternalID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_classification_characteristic_data`),
		qm.WhereIn(`sap_classification_characteristic_data.ClassInternalID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_classification_characteristic_data")
	}

	var resultSlice []*SapClassificationCharacteristicDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_classification_characteristic_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_classification_characteristic_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_classification_characteristic_data")
	}

	if len(sapClassificationCharacteristicDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ClassInternalIDSapClassificationCharacteristicData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapClassificationCharacteristicDatumR{}
			}
			foreign.R.ClassInternalIDSapClassificationClassDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ClassInternalID == foreign.ClassInternalID {
				local.R.ClassInternalIDSapClassificationCharacteristicData = append(local.R.ClassInternalIDSapClassificationCharacteristicData, foreign)
				if foreign.R == nil {
					foreign.R = &sapClassificationCharacteristicDatumR{}
				}
				foreign.R.ClassInternalIDSapClassificationClassDatum = local
				break
			}
		}
	}

	return nil
}

// LoadClassInternalIDSapClassificationClassDescriptionData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapClassificationClassDatumL) LoadClassInternalIDSapClassificationClassDescriptionData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapClassificationClassDatum interface{}, mods queries.Applicator) error {
	var slice []*SapClassificationClassDatum
	var object *SapClassificationClassDatum

	if singular {
		object = maybeSapClassificationClassDatum.(*SapClassificationClassDatum)
	} else {
		slice = *maybeSapClassificationClassDatum.(*[]*SapClassificationClassDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapClassificationClassDatumR{}
		}
		args = append(args, object.ClassInternalID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapClassificationClassDatumR{}
			}

			for _, a := range args {
				if a == obj.ClassInternalID {
					continue Outer
				}
			}

			args = append(args, obj.ClassInternalID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_classification_class_description_data`),
		qm.WhereIn(`sap_classification_class_description_data.ClassInternalID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_classification_class_description_data")
	}

	var resultSlice []*SapClassificationClassDescriptionDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_classification_class_description_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_classification_class_description_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_classification_class_description_data")
	}

	if len(sapClassificationClassDescriptionDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ClassInternalIDSapClassificationClassDescriptionData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapClassificationClassDescriptionDatumR{}
			}
			foreign.R.ClassInternalIDSapClassificationClassDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ClassInternalID == foreign.ClassInternalID {
				local.R.ClassInternalIDSapClassificationClassDescriptionData = append(local.R.ClassInternalIDSapClassificationClassDescriptionData, foreign)
				if foreign.R == nil {
					foreign.R = &sapClassificationClassDescriptionDatumR{}
				}
				foreign.R.ClassInternalIDSapClassificationClassDatum = local
				break
			}
		}
	}

	return nil
}

// AddClassInternalIDSapClassificationCharacteristicData adds the given related objects to the existing relationships
// of the sap_classification_class_datum, optionally inserting them as new records.
// Appends related to o.R.ClassInternalIDSapClassificationCharacteristicData.
// Sets related.R.ClassInternalIDSapClassificationClassDatum appropriately.
func (o *SapClassificationClassDatum) AddClassInternalIDSapClassificationCharacteristicData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapClassificationCharacteristicDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ClassInternalID = o.ClassInternalID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_classification_characteristic_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ClassInternalID"}),
				strmangle.WhereClause("`", "`", 0, sapClassificationCharacteristicDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ClassInternalID, rel.ClassInternalID, rel.CharcInternalID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ClassInternalID = o.ClassInternalID
		}
	}

	if o.R == nil {
		o.R = &sapClassificationClassDatumR{
			ClassInternalIDSapClassificationCharacteristicData: related,
		}
	} else {
		o.R.ClassInternalIDSapClassificationCharacteristicData = append(o.R.ClassInternalIDSapClassificationCharacteristicData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapClassificationCharacteristicDatumR{
				ClassInternalIDSapClassificationClassDatum: o,
			}
		} else {
			rel.R.ClassInternalIDSapClassificationClassDatum = o
		}
	}
	return nil
}

// AddClassInternalIDSapClassificationClassDescriptionData adds the given related objects to the existing relationships
// of the sap_classification_class_datum, optionally inserting them as new records.
// Appends related to o.R.ClassInternalIDSapClassificationClassDescriptionData.
// Sets related.R.ClassInternalIDSapClassificationClassDatum appropriately.
func (o *SapClassificationClassDatum) AddClassInternalIDSapClassificationClassDescriptionData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapClassificationClassDescriptionDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ClassInternalID = o.ClassInternalID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_classification_class_description_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ClassInternalID"}),
				strmangle.WhereClause("`", "`", 0, sapClassificationClassDescriptionDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ClassInternalID, rel.ClassInternalID, rel.Language}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ClassInternalID = o.ClassInternalID
		}
	}

	if o.R == nil {
		o.R = &sapClassificationClassDatumR{
			ClassInternalIDSapClassificationClassDescriptionData: related,
		}
	} else {
		o.R.ClassInternalIDSapClassificationClassDescriptionData = append(o.R.ClassInternalIDSapClassificationClassDescriptionData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapClassificationClassDescriptionDatumR{
				ClassInternalIDSapClassificationClassDatum: o,
			}
		} else {
			rel.R.ClassInternalIDSapClassificationClassDatum = o
		}
	}
	return nil
}

// SapClassificationClassData retrieves all the records using an executor.
func SapClassificationClassData(mods ...qm.QueryMod) sapClassificationClassDatumQuery {
	mods = append(mods, qm.From("`sap_classification_class_data`"))
	return sapClassificationClassDatumQuery{NewQuery(mods...)}
}

// FindSapClassificationClassDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapClassificationClassDatum(ctx context.Context, exec boil.ContextExecutor, classInternalID string, selectCols ...string) (*SapClassificationClassDatum, error) {
	sapClassificationClassDatumObj := &SapClassificationClassDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_classification_class_data` where `ClassInternalID`=?", sel,
	)

	q := queries.Raw(query, classInternalID)

	err := q.Bind(ctx, exec, sapClassificationClassDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_classification_class_data")
	}

	if err = sapClassificationClassDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapClassificationClassDatumObj, err
	}

	return sapClassificationClassDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapClassificationClassDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_classification_class_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapClassificationClassDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapClassificationClassDatumInsertCacheMut.RLock()
	cache, cached := sapClassificationClassDatumInsertCache[key]
	sapClassificationClassDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapClassificationClassDatumAllColumns,
			sapClassificationClassDatumColumnsWithDefault,
			sapClassificationClassDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapClassificationClassDatumType, sapClassificationClassDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapClassificationClassDatumType, sapClassificationClassDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_classification_class_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_classification_class_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_classification_class_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapClassificationClassDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_classification_class_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ClassInternalID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_classification_class_data")
	}

CacheNoHooks:
	if !cached {
		sapClassificationClassDatumInsertCacheMut.Lock()
		sapClassificationClassDatumInsertCache[key] = cache
		sapClassificationClassDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapClassificationClassDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapClassificationClassDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapClassificationClassDatumUpdateCacheMut.RLock()
	cache, cached := sapClassificationClassDatumUpdateCache[key]
	sapClassificationClassDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapClassificationClassDatumAllColumns,
			sapClassificationClassDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_classification_class_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_classification_class_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapClassificationClassDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapClassificationClassDatumType, sapClassificationClassDatumMapping, append(wl, sapClassificationClassDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_classification_class_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_classification_class_data")
	}

	if !cached {
		sapClassificationClassDatumUpdateCacheMut.Lock()
		sapClassificationClassDatumUpdateCache[key] = cache
		sapClassificationClassDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapClassificationClassDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_classification_class_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_classification_class_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapClassificationClassDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapClassificationClassDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_classification_class_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapClassificationClassDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapClassificationClassDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapClassificationClassDatum")
	}
	return rowsAff, nil
}

var mySQLSapClassificationClassDatumUniqueColumns = []string{
	"ClassInternalID",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapClassificationClassDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_classification_class_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapClassificationClassDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapClassificationClassDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapClassificationClassDatumUpsertCacheMut.RLock()
	cache, cached := sapClassificationClassDatumUpsertCache[key]
	sapClassificationClassDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapClassificationClassDatumAllColumns,
			sapClassificationClassDatumColumnsWithDefault,
			sapClassificationClassDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapClassificationClassDatumAllColumns,
			sapClassificationClassDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_classification_class_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_classification_class_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_classification_class_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapClassificationClassDatumType, sapClassificationClassDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapClassificationClassDatumType, sapClassificationClassDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_classification_class_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapClassificationClassDatumType, sapClassificationClassDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_classification_class_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_classification_class_data")
	}

CacheNoHooks:
	if !cached {
		sapClassificationClassDatumUpsertCacheMut.Lock()
		sapClassificationClassDatumUpsertCache[key] = cache
		sapClassificationClassDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapClassificationClassDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapClassificationClassDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapClassificationClassDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapClassificationClassDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_classification_class_data` WHERE `ClassInternalID`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_classification_class_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_classification_class_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapClassificationClassDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapClassificationClassDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_classification_class_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_classification_class_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapClassificationClassDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapClassificationClassDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapClassificationClassDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_classification_class_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapClassificationClassDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapClassificationClassDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_classification_class_data")
	}

	if len(sapClassificationClassDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapClassificationClassDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapClassificationClassDatum(ctx, exec, o.ClassInternalID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapClassificationClassDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapClassificationClassDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapClassificationClassDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_classification_class_data`.* FROM `sap_classification_class_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapClassificationClassDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapClassificationClassDatumSlice")
	}

	*o = slice

	return nil
}

// SapClassificationClassDatumExists checks if the SapClassificationClassDatum row exists.
func SapClassificationClassDatumExists(ctx context.Context, exec boil.ContextExecutor, classInternalID string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_classification_class_data` where `ClassInternalID`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, classInternalID)
	}
	row := exec.QueryRowContext(ctx, sql, classInternalID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_classification_class_data exists")
	}

	return exists, nil
}
