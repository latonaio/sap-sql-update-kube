// Code generated by SQLBoiler 4.8.3 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapProductMasterGeneralDatum is an object representing the database table.
type SapProductMasterGeneralDatum struct {
	Product             string      `boil:"Product" json:"Product" toml:"Product" yaml:"Product"`
	IndustrySector      null.String `boil:"IndustrySector" json:"IndustrySector,omitempty" toml:"IndustrySector" yaml:"IndustrySector,omitempty"`
	ProductType         null.String `boil:"ProductType" json:"ProductType,omitempty" toml:"ProductType" yaml:"ProductType,omitempty"`
	BaseUnit            null.String `boil:"BaseUnit" json:"BaseUnit,omitempty" toml:"BaseUnit" yaml:"BaseUnit,omitempty"`
	ValidityStartDate   null.String `boil:"ValidityStartDate" json:"ValidityStartDate,omitempty" toml:"ValidityStartDate" yaml:"ValidityStartDate,omitempty"`
	ProductGroup        null.String `boil:"ProductGroup" json:"ProductGroup,omitempty" toml:"ProductGroup" yaml:"ProductGroup,omitempty"`
	Division            null.String `boil:"Division" json:"Division,omitempty" toml:"Division" yaml:"Division,omitempty"`
	GrossWeight         null.String `boil:"GrossWeight" json:"GrossWeight,omitempty" toml:"GrossWeight" yaml:"GrossWeight,omitempty"`
	WeightUnit          null.String `boil:"WeightUnit" json:"WeightUnit,omitempty" toml:"WeightUnit" yaml:"WeightUnit,omitempty"`
	SizeOrDimensionText null.String `boil:"SizeOrDimensionText" json:"SizeOrDimensionText,omitempty" toml:"SizeOrDimensionText" yaml:"SizeOrDimensionText,omitempty"`
	ProductStandardID   null.String `boil:"ProductStandardID" json:"ProductStandardID,omitempty" toml:"ProductStandardID" yaml:"ProductStandardID,omitempty"`
	CreationDate        null.String `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	LastChangeDate      null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	IsMarkedForDeletion null.Bool   `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`
	NetWeight           null.String `boil:"NetWeight" json:"NetWeight,omitempty" toml:"NetWeight" yaml:"NetWeight,omitempty"`
	ChangeNumber        null.String `boil:"ChangeNumber" json:"ChangeNumber,omitempty" toml:"ChangeNumber" yaml:"ChangeNumber,omitempty"`

	R *sapProductMasterGeneralDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapProductMasterGeneralDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapProductMasterGeneralDatumColumns = struct {
	Product             string
	IndustrySector      string
	ProductType         string
	BaseUnit            string
	ValidityStartDate   string
	ProductGroup        string
	Division            string
	GrossWeight         string
	WeightUnit          string
	SizeOrDimensionText string
	ProductStandardID   string
	CreationDate        string
	LastChangeDate      string
	IsMarkedForDeletion string
	NetWeight           string
	ChangeNumber        string
}{
	Product:             "Product",
	IndustrySector:      "IndustrySector",
	ProductType:         "ProductType",
	BaseUnit:            "BaseUnit",
	ValidityStartDate:   "ValidityStartDate",
	ProductGroup:        "ProductGroup",
	Division:            "Division",
	GrossWeight:         "GrossWeight",
	WeightUnit:          "WeightUnit",
	SizeOrDimensionText: "SizeOrDimensionText",
	ProductStandardID:   "ProductStandardID",
	CreationDate:        "CreationDate",
	LastChangeDate:      "LastChangeDate",
	IsMarkedForDeletion: "IsMarkedForDeletion",
	NetWeight:           "NetWeight",
	ChangeNumber:        "ChangeNumber",
}

var SapProductMasterGeneralDatumTableColumns = struct {
	Product             string
	IndustrySector      string
	ProductType         string
	BaseUnit            string
	ValidityStartDate   string
	ProductGroup        string
	Division            string
	GrossWeight         string
	WeightUnit          string
	SizeOrDimensionText string
	ProductStandardID   string
	CreationDate        string
	LastChangeDate      string
	IsMarkedForDeletion string
	NetWeight           string
	ChangeNumber        string
}{
	Product:             "sap_product_master_general_data.Product",
	IndustrySector:      "sap_product_master_general_data.IndustrySector",
	ProductType:         "sap_product_master_general_data.ProductType",
	BaseUnit:            "sap_product_master_general_data.BaseUnit",
	ValidityStartDate:   "sap_product_master_general_data.ValidityStartDate",
	ProductGroup:        "sap_product_master_general_data.ProductGroup",
	Division:            "sap_product_master_general_data.Division",
	GrossWeight:         "sap_product_master_general_data.GrossWeight",
	WeightUnit:          "sap_product_master_general_data.WeightUnit",
	SizeOrDimensionText: "sap_product_master_general_data.SizeOrDimensionText",
	ProductStandardID:   "sap_product_master_general_data.ProductStandardID",
	CreationDate:        "sap_product_master_general_data.CreationDate",
	LastChangeDate:      "sap_product_master_general_data.LastChangeDate",
	IsMarkedForDeletion: "sap_product_master_general_data.IsMarkedForDeletion",
	NetWeight:           "sap_product_master_general_data.NetWeight",
	ChangeNumber:        "sap_product_master_general_data.ChangeNumber",
}

// Generated where

var SapProductMasterGeneralDatumWhere = struct {
	Product             whereHelperstring
	IndustrySector      whereHelpernull_String
	ProductType         whereHelpernull_String
	BaseUnit            whereHelpernull_String
	ValidityStartDate   whereHelpernull_String
	ProductGroup        whereHelpernull_String
	Division            whereHelpernull_String
	GrossWeight         whereHelpernull_String
	WeightUnit          whereHelpernull_String
	SizeOrDimensionText whereHelpernull_String
	ProductStandardID   whereHelpernull_String
	CreationDate        whereHelpernull_String
	LastChangeDate      whereHelpernull_String
	IsMarkedForDeletion whereHelpernull_Bool
	NetWeight           whereHelpernull_String
	ChangeNumber        whereHelpernull_String
}{
	Product:             whereHelperstring{field: "`sap_product_master_general_data`.`Product`"},
	IndustrySector:      whereHelpernull_String{field: "`sap_product_master_general_data`.`IndustrySector`"},
	ProductType:         whereHelpernull_String{field: "`sap_product_master_general_data`.`ProductType`"},
	BaseUnit:            whereHelpernull_String{field: "`sap_product_master_general_data`.`BaseUnit`"},
	ValidityStartDate:   whereHelpernull_String{field: "`sap_product_master_general_data`.`ValidityStartDate`"},
	ProductGroup:        whereHelpernull_String{field: "`sap_product_master_general_data`.`ProductGroup`"},
	Division:            whereHelpernull_String{field: "`sap_product_master_general_data`.`Division`"},
	GrossWeight:         whereHelpernull_String{field: "`sap_product_master_general_data`.`GrossWeight`"},
	WeightUnit:          whereHelpernull_String{field: "`sap_product_master_general_data`.`WeightUnit`"},
	SizeOrDimensionText: whereHelpernull_String{field: "`sap_product_master_general_data`.`SizeOrDimensionText`"},
	ProductStandardID:   whereHelpernull_String{field: "`sap_product_master_general_data`.`ProductStandardID`"},
	CreationDate:        whereHelpernull_String{field: "`sap_product_master_general_data`.`CreationDate`"},
	LastChangeDate:      whereHelpernull_String{field: "`sap_product_master_general_data`.`LastChangeDate`"},
	IsMarkedForDeletion: whereHelpernull_Bool{field: "`sap_product_master_general_data`.`IsMarkedForDeletion`"},
	NetWeight:           whereHelpernull_String{field: "`sap_product_master_general_data`.`NetWeight`"},
	ChangeNumber:        whereHelpernull_String{field: "`sap_product_master_general_data`.`ChangeNumber`"},
}

// SapProductMasterGeneralDatumRels is where relationship names are stored.
var SapProductMasterGeneralDatumRels = struct {
	ProductSapProductMasterAccountingData         string
	ProductSapProductMasterMRPAreaData            string
	ProductSapProductMasterPlantData              string
	ProductSapProductMasterProcurementData        string
	ProductSapProductMasterProductDescriptionData string
	ProductSapProductMasterQualityData            string
	ProductSapProductMasterSalesOrganizationData  string
	ProductSapProductMasterSalesPlantData         string
	ProductSapProductMasterWorkSchedulingData     string
}{
	ProductSapProductMasterAccountingData:         "ProductSapProductMasterAccountingData",
	ProductSapProductMasterMRPAreaData:            "ProductSapProductMasterMRPAreaData",
	ProductSapProductMasterPlantData:              "ProductSapProductMasterPlantData",
	ProductSapProductMasterProcurementData:        "ProductSapProductMasterProcurementData",
	ProductSapProductMasterProductDescriptionData: "ProductSapProductMasterProductDescriptionData",
	ProductSapProductMasterQualityData:            "ProductSapProductMasterQualityData",
	ProductSapProductMasterSalesOrganizationData:  "ProductSapProductMasterSalesOrganizationData",
	ProductSapProductMasterSalesPlantData:         "ProductSapProductMasterSalesPlantData",
	ProductSapProductMasterWorkSchedulingData:     "ProductSapProductMasterWorkSchedulingData",
}

// sapProductMasterGeneralDatumR is where relationships are stored.
type sapProductMasterGeneralDatumR struct {
	ProductSapProductMasterAccountingData         SapProductMasterAccountingDatumSlice         `boil:"ProductSapProductMasterAccountingData" json:"ProductSapProductMasterAccountingData" toml:"ProductSapProductMasterAccountingData" yaml:"ProductSapProductMasterAccountingData"`
	ProductSapProductMasterMRPAreaData            SapProductMasterMRPAreaDatumSlice            `boil:"ProductSapProductMasterMRPAreaData" json:"ProductSapProductMasterMRPAreaData" toml:"ProductSapProductMasterMRPAreaData" yaml:"ProductSapProductMasterMRPAreaData"`
	ProductSapProductMasterPlantData              SapProductMasterPlantDatumSlice              `boil:"ProductSapProductMasterPlantData" json:"ProductSapProductMasterPlantData" toml:"ProductSapProductMasterPlantData" yaml:"ProductSapProductMasterPlantData"`
	ProductSapProductMasterProcurementData        SapProductMasterProcurementDatumSlice        `boil:"ProductSapProductMasterProcurementData" json:"ProductSapProductMasterProcurementData" toml:"ProductSapProductMasterProcurementData" yaml:"ProductSapProductMasterProcurementData"`
	ProductSapProductMasterProductDescriptionData SapProductMasterProductDescriptionDatumSlice `boil:"ProductSapProductMasterProductDescriptionData" json:"ProductSapProductMasterProductDescriptionData" toml:"ProductSapProductMasterProductDescriptionData" yaml:"ProductSapProductMasterProductDescriptionData"`
	ProductSapProductMasterQualityData            SapProductMasterQualityDatumSlice            `boil:"ProductSapProductMasterQualityData" json:"ProductSapProductMasterQualityData" toml:"ProductSapProductMasterQualityData" yaml:"ProductSapProductMasterQualityData"`
	ProductSapProductMasterSalesOrganizationData  SapProductMasterSalesOrganizationDatumSlice  `boil:"ProductSapProductMasterSalesOrganizationData" json:"ProductSapProductMasterSalesOrganizationData" toml:"ProductSapProductMasterSalesOrganizationData" yaml:"ProductSapProductMasterSalesOrganizationData"`
	ProductSapProductMasterSalesPlantData         SapProductMasterSalesPlantDatumSlice         `boil:"ProductSapProductMasterSalesPlantData" json:"ProductSapProductMasterSalesPlantData" toml:"ProductSapProductMasterSalesPlantData" yaml:"ProductSapProductMasterSalesPlantData"`
	ProductSapProductMasterWorkSchedulingData     SapProductMasterWorkSchedulingDatumSlice     `boil:"ProductSapProductMasterWorkSchedulingData" json:"ProductSapProductMasterWorkSchedulingData" toml:"ProductSapProductMasterWorkSchedulingData" yaml:"ProductSapProductMasterWorkSchedulingData"`
}

// NewStruct creates a new relationship struct
func (*sapProductMasterGeneralDatumR) NewStruct() *sapProductMasterGeneralDatumR {
	return &sapProductMasterGeneralDatumR{}
}

// sapProductMasterGeneralDatumL is where Load methods for each relationship are stored.
type sapProductMasterGeneralDatumL struct{}

var (
	sapProductMasterGeneralDatumAllColumns            = []string{"Product", "IndustrySector", "ProductType", "BaseUnit", "ValidityStartDate", "ProductGroup", "Division", "GrossWeight", "WeightUnit", "SizeOrDimensionText", "ProductStandardID", "CreationDate", "LastChangeDate", "IsMarkedForDeletion", "NetWeight", "ChangeNumber"}
	sapProductMasterGeneralDatumColumnsWithoutDefault = []string{"Product", "IndustrySector", "ProductType", "BaseUnit", "ValidityStartDate", "ProductGroup", "Division", "GrossWeight", "WeightUnit", "SizeOrDimensionText", "ProductStandardID", "CreationDate", "LastChangeDate", "IsMarkedForDeletion", "NetWeight", "ChangeNumber"}
	sapProductMasterGeneralDatumColumnsWithDefault    = []string{}
	sapProductMasterGeneralDatumPrimaryKeyColumns     = []string{"Product"}
)

type (
	// SapProductMasterGeneralDatumSlice is an alias for a slice of pointers to SapProductMasterGeneralDatum.
	// This should almost always be used instead of []SapProductMasterGeneralDatum.
	SapProductMasterGeneralDatumSlice []*SapProductMasterGeneralDatum
	// SapProductMasterGeneralDatumHook is the signature for custom SapProductMasterGeneralDatum hook methods
	SapProductMasterGeneralDatumHook func(context.Context, boil.ContextExecutor, *SapProductMasterGeneralDatum) error

	sapProductMasterGeneralDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapProductMasterGeneralDatumType                 = reflect.TypeOf(&SapProductMasterGeneralDatum{})
	sapProductMasterGeneralDatumMapping              = queries.MakeStructMapping(sapProductMasterGeneralDatumType)
	sapProductMasterGeneralDatumPrimaryKeyMapping, _ = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, sapProductMasterGeneralDatumPrimaryKeyColumns)
	sapProductMasterGeneralDatumInsertCacheMut       sync.RWMutex
	sapProductMasterGeneralDatumInsertCache          = make(map[string]insertCache)
	sapProductMasterGeneralDatumUpdateCacheMut       sync.RWMutex
	sapProductMasterGeneralDatumUpdateCache          = make(map[string]updateCache)
	sapProductMasterGeneralDatumUpsertCacheMut       sync.RWMutex
	sapProductMasterGeneralDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapProductMasterGeneralDatumBeforeInsertHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumBeforeUpdateHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumBeforeDeleteHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumBeforeUpsertHooks []SapProductMasterGeneralDatumHook

var sapProductMasterGeneralDatumAfterInsertHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumAfterSelectHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumAfterUpdateHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumAfterDeleteHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumAfterUpsertHooks []SapProductMasterGeneralDatumHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapProductMasterGeneralDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapProductMasterGeneralDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapProductMasterGeneralDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapProductMasterGeneralDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapProductMasterGeneralDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapProductMasterGeneralDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapProductMasterGeneralDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapProductMasterGeneralDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapProductMasterGeneralDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapProductMasterGeneralDatumHook registers your hook function for all future operations.
func AddSapProductMasterGeneralDatumHook(hookPoint boil.HookPoint, sapProductMasterGeneralDatumHook SapProductMasterGeneralDatumHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		sapProductMasterGeneralDatumBeforeInsertHooks = append(sapProductMasterGeneralDatumBeforeInsertHooks, sapProductMasterGeneralDatumHook)
	case boil.BeforeUpdateHook:
		sapProductMasterGeneralDatumBeforeUpdateHooks = append(sapProductMasterGeneralDatumBeforeUpdateHooks, sapProductMasterGeneralDatumHook)
	case boil.BeforeDeleteHook:
		sapProductMasterGeneralDatumBeforeDeleteHooks = append(sapProductMasterGeneralDatumBeforeDeleteHooks, sapProductMasterGeneralDatumHook)
	case boil.BeforeUpsertHook:
		sapProductMasterGeneralDatumBeforeUpsertHooks = append(sapProductMasterGeneralDatumBeforeUpsertHooks, sapProductMasterGeneralDatumHook)
	case boil.AfterInsertHook:
		sapProductMasterGeneralDatumAfterInsertHooks = append(sapProductMasterGeneralDatumAfterInsertHooks, sapProductMasterGeneralDatumHook)
	case boil.AfterSelectHook:
		sapProductMasterGeneralDatumAfterSelectHooks = append(sapProductMasterGeneralDatumAfterSelectHooks, sapProductMasterGeneralDatumHook)
	case boil.AfterUpdateHook:
		sapProductMasterGeneralDatumAfterUpdateHooks = append(sapProductMasterGeneralDatumAfterUpdateHooks, sapProductMasterGeneralDatumHook)
	case boil.AfterDeleteHook:
		sapProductMasterGeneralDatumAfterDeleteHooks = append(sapProductMasterGeneralDatumAfterDeleteHooks, sapProductMasterGeneralDatumHook)
	case boil.AfterUpsertHook:
		sapProductMasterGeneralDatumAfterUpsertHooks = append(sapProductMasterGeneralDatumAfterUpsertHooks, sapProductMasterGeneralDatumHook)
	}
}

// One returns a single sapProductMasterGeneralDatum record from the query.
func (q sapProductMasterGeneralDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapProductMasterGeneralDatum, error) {
	o := &SapProductMasterGeneralDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_product_master_general_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapProductMasterGeneralDatum records from the query.
func (q sapProductMasterGeneralDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapProductMasterGeneralDatumSlice, error) {
	var o []*SapProductMasterGeneralDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapProductMasterGeneralDatum slice")
	}

	if len(sapProductMasterGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapProductMasterGeneralDatum records in the query.
func (q sapProductMasterGeneralDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_product_master_general_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapProductMasterGeneralDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_product_master_general_data exists")
	}

	return count > 0, nil
}

// ProductSapProductMasterAccountingData retrieves all the sap_product_master_accounting_datum's SapProductMasterAccountingData with an executor via Product column.
func (o *SapProductMasterGeneralDatum) ProductSapProductMasterAccountingData(mods ...qm.QueryMod) sapProductMasterAccountingDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_product_master_accounting_data`.`Product`=?", o.Product),
	)

	query := SapProductMasterAccountingData(queryMods...)
	queries.SetFrom(query.Query, "`sap_product_master_accounting_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_product_master_accounting_data`.*"})
	}

	return query
}

// ProductSapProductMasterMRPAreaData retrieves all the sap_product_master_mrp_area_datum's SapProductMasterMRPAreaData with an executor via Product column.
func (o *SapProductMasterGeneralDatum) ProductSapProductMasterMRPAreaData(mods ...qm.QueryMod) sapProductMasterMRPAreaDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_product_master_mrp_area_data`.`Product`=?", o.Product),
	)

	query := SapProductMasterMRPAreaData(queryMods...)
	queries.SetFrom(query.Query, "`sap_product_master_mrp_area_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_product_master_mrp_area_data`.*"})
	}

	return query
}

// ProductSapProductMasterPlantData retrieves all the sap_product_master_plant_datum's SapProductMasterPlantData with an executor via Product column.
func (o *SapProductMasterGeneralDatum) ProductSapProductMasterPlantData(mods ...qm.QueryMod) sapProductMasterPlantDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_product_master_plant_data`.`Product`=?", o.Product),
	)

	query := SapProductMasterPlantData(queryMods...)
	queries.SetFrom(query.Query, "`sap_product_master_plant_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_product_master_plant_data`.*"})
	}

	return query
}

// ProductSapProductMasterProcurementData retrieves all the sap_product_master_procurement_datum's SapProductMasterProcurementData with an executor via Product column.
func (o *SapProductMasterGeneralDatum) ProductSapProductMasterProcurementData(mods ...qm.QueryMod) sapProductMasterProcurementDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_product_master_procurement_data`.`Product`=?", o.Product),
	)

	query := SapProductMasterProcurementData(queryMods...)
	queries.SetFrom(query.Query, "`sap_product_master_procurement_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_product_master_procurement_data`.*"})
	}

	return query
}

// ProductSapProductMasterProductDescriptionData retrieves all the sap_product_master_product_description_datum's SapProductMasterProductDescriptionData with an executor via Product column.
func (o *SapProductMasterGeneralDatum) ProductSapProductMasterProductDescriptionData(mods ...qm.QueryMod) sapProductMasterProductDescriptionDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_product_master_product_description_data`.`Product`=?", o.Product),
	)

	query := SapProductMasterProductDescriptionData(queryMods...)
	queries.SetFrom(query.Query, "`sap_product_master_product_description_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_product_master_product_description_data`.*"})
	}

	return query
}

// ProductSapProductMasterQualityData retrieves all the sap_product_master_quality_datum's SapProductMasterQualityData with an executor via Product column.
func (o *SapProductMasterGeneralDatum) ProductSapProductMasterQualityData(mods ...qm.QueryMod) sapProductMasterQualityDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_product_master_quality_data`.`Product`=?", o.Product),
	)

	query := SapProductMasterQualityData(queryMods...)
	queries.SetFrom(query.Query, "`sap_product_master_quality_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_product_master_quality_data`.*"})
	}

	return query
}

// ProductSapProductMasterSalesOrganizationData retrieves all the sap_product_master_sales_organization_datum's SapProductMasterSalesOrganizationData with an executor via Product column.
func (o *SapProductMasterGeneralDatum) ProductSapProductMasterSalesOrganizationData(mods ...qm.QueryMod) sapProductMasterSalesOrganizationDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_product_master_sales_organization_data`.`Product`=?", o.Product),
	)

	query := SapProductMasterSalesOrganizationData(queryMods...)
	queries.SetFrom(query.Query, "`sap_product_master_sales_organization_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_product_master_sales_organization_data`.*"})
	}

	return query
}

// ProductSapProductMasterSalesPlantData retrieves all the sap_product_master_sales_plant_datum's SapProductMasterSalesPlantData with an executor via Product column.
func (o *SapProductMasterGeneralDatum) ProductSapProductMasterSalesPlantData(mods ...qm.QueryMod) sapProductMasterSalesPlantDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_product_master_sales_plant_data`.`Product`=?", o.Product),
	)

	query := SapProductMasterSalesPlantData(queryMods...)
	queries.SetFrom(query.Query, "`sap_product_master_sales_plant_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_product_master_sales_plant_data`.*"})
	}

	return query
}

// ProductSapProductMasterWorkSchedulingData retrieves all the sap_product_master_work_scheduling_datum's SapProductMasterWorkSchedulingData with an executor via Product column.
func (o *SapProductMasterGeneralDatum) ProductSapProductMasterWorkSchedulingData(mods ...qm.QueryMod) sapProductMasterWorkSchedulingDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sap_product_master_work_scheduling_data`.`Product`=?", o.Product),
	)

	query := SapProductMasterWorkSchedulingData(queryMods...)
	queries.SetFrom(query.Query, "`sap_product_master_work_scheduling_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sap_product_master_work_scheduling_data`.*"})
	}

	return query
}

// LoadProductSapProductMasterAccountingData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapProductMasterGeneralDatumL) LoadProductSapProductMasterAccountingData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapProductMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*SapProductMasterGeneralDatum
	var object *SapProductMasterGeneralDatum

	if singular {
		object = maybeSapProductMasterGeneralDatum.(*SapProductMasterGeneralDatum)
	} else {
		slice = *maybeSapProductMasterGeneralDatum.(*[]*SapProductMasterGeneralDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapProductMasterGeneralDatumR{}
		}
		args = append(args, object.Product)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapProductMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_product_master_accounting_data`),
		qm.WhereIn(`sap_product_master_accounting_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_product_master_accounting_data")
	}

	var resultSlice []*SapProductMasterAccountingDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_product_master_accounting_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_product_master_accounting_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_product_master_accounting_data")
	}

	if len(sapProductMasterAccountingDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductSapProductMasterAccountingData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapProductMasterAccountingDatumR{}
			}
			foreign.R.ProductSapProductMasterGeneralDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Product == foreign.Product {
				local.R.ProductSapProductMasterAccountingData = append(local.R.ProductSapProductMasterAccountingData, foreign)
				if foreign.R == nil {
					foreign.R = &sapProductMasterAccountingDatumR{}
				}
				foreign.R.ProductSapProductMasterGeneralDatum = local
				break
			}
		}
	}

	return nil
}

// LoadProductSapProductMasterMRPAreaData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapProductMasterGeneralDatumL) LoadProductSapProductMasterMRPAreaData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapProductMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*SapProductMasterGeneralDatum
	var object *SapProductMasterGeneralDatum

	if singular {
		object = maybeSapProductMasterGeneralDatum.(*SapProductMasterGeneralDatum)
	} else {
		slice = *maybeSapProductMasterGeneralDatum.(*[]*SapProductMasterGeneralDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapProductMasterGeneralDatumR{}
		}
		args = append(args, object.Product)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapProductMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_product_master_mrp_area_data`),
		qm.WhereIn(`sap_product_master_mrp_area_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_product_master_mrp_area_data")
	}

	var resultSlice []*SapProductMasterMRPAreaDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_product_master_mrp_area_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_product_master_mrp_area_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_product_master_mrp_area_data")
	}

	if len(sapProductMasterMRPAreaDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductSapProductMasterMRPAreaData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapProductMasterMRPAreaDatumR{}
			}
			foreign.R.ProductSapProductMasterGeneralDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Product == foreign.Product {
				local.R.ProductSapProductMasterMRPAreaData = append(local.R.ProductSapProductMasterMRPAreaData, foreign)
				if foreign.R == nil {
					foreign.R = &sapProductMasterMRPAreaDatumR{}
				}
				foreign.R.ProductSapProductMasterGeneralDatum = local
				break
			}
		}
	}

	return nil
}

// LoadProductSapProductMasterPlantData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapProductMasterGeneralDatumL) LoadProductSapProductMasterPlantData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapProductMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*SapProductMasterGeneralDatum
	var object *SapProductMasterGeneralDatum

	if singular {
		object = maybeSapProductMasterGeneralDatum.(*SapProductMasterGeneralDatum)
	} else {
		slice = *maybeSapProductMasterGeneralDatum.(*[]*SapProductMasterGeneralDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapProductMasterGeneralDatumR{}
		}
		args = append(args, object.Product)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapProductMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_product_master_plant_data`),
		qm.WhereIn(`sap_product_master_plant_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_product_master_plant_data")
	}

	var resultSlice []*SapProductMasterPlantDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_product_master_plant_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_product_master_plant_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_product_master_plant_data")
	}

	if len(sapProductMasterPlantDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductSapProductMasterPlantData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapProductMasterPlantDatumR{}
			}
			foreign.R.ProductSapProductMasterGeneralDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Product == foreign.Product {
				local.R.ProductSapProductMasterPlantData = append(local.R.ProductSapProductMasterPlantData, foreign)
				if foreign.R == nil {
					foreign.R = &sapProductMasterPlantDatumR{}
				}
				foreign.R.ProductSapProductMasterGeneralDatum = local
				break
			}
		}
	}

	return nil
}

// LoadProductSapProductMasterProcurementData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapProductMasterGeneralDatumL) LoadProductSapProductMasterProcurementData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapProductMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*SapProductMasterGeneralDatum
	var object *SapProductMasterGeneralDatum

	if singular {
		object = maybeSapProductMasterGeneralDatum.(*SapProductMasterGeneralDatum)
	} else {
		slice = *maybeSapProductMasterGeneralDatum.(*[]*SapProductMasterGeneralDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapProductMasterGeneralDatumR{}
		}
		args = append(args, object.Product)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapProductMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_product_master_procurement_data`),
		qm.WhereIn(`sap_product_master_procurement_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_product_master_procurement_data")
	}

	var resultSlice []*SapProductMasterProcurementDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_product_master_procurement_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_product_master_procurement_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_product_master_procurement_data")
	}

	if len(sapProductMasterProcurementDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductSapProductMasterProcurementData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapProductMasterProcurementDatumR{}
			}
			foreign.R.ProductSapProductMasterGeneralDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Product == foreign.Product {
				local.R.ProductSapProductMasterProcurementData = append(local.R.ProductSapProductMasterProcurementData, foreign)
				if foreign.R == nil {
					foreign.R = &sapProductMasterProcurementDatumR{}
				}
				foreign.R.ProductSapProductMasterGeneralDatum = local
				break
			}
		}
	}

	return nil
}

// LoadProductSapProductMasterProductDescriptionData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapProductMasterGeneralDatumL) LoadProductSapProductMasterProductDescriptionData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapProductMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*SapProductMasterGeneralDatum
	var object *SapProductMasterGeneralDatum

	if singular {
		object = maybeSapProductMasterGeneralDatum.(*SapProductMasterGeneralDatum)
	} else {
		slice = *maybeSapProductMasterGeneralDatum.(*[]*SapProductMasterGeneralDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapProductMasterGeneralDatumR{}
		}
		args = append(args, object.Product)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapProductMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_product_master_product_description_data`),
		qm.WhereIn(`sap_product_master_product_description_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_product_master_product_description_data")
	}

	var resultSlice []*SapProductMasterProductDescriptionDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_product_master_product_description_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_product_master_product_description_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_product_master_product_description_data")
	}

	if len(sapProductMasterProductDescriptionDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductSapProductMasterProductDescriptionData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapProductMasterProductDescriptionDatumR{}
			}
			foreign.R.ProductSapProductMasterGeneralDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Product == foreign.Product {
				local.R.ProductSapProductMasterProductDescriptionData = append(local.R.ProductSapProductMasterProductDescriptionData, foreign)
				if foreign.R == nil {
					foreign.R = &sapProductMasterProductDescriptionDatumR{}
				}
				foreign.R.ProductSapProductMasterGeneralDatum = local
				break
			}
		}
	}

	return nil
}

// LoadProductSapProductMasterQualityData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapProductMasterGeneralDatumL) LoadProductSapProductMasterQualityData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapProductMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*SapProductMasterGeneralDatum
	var object *SapProductMasterGeneralDatum

	if singular {
		object = maybeSapProductMasterGeneralDatum.(*SapProductMasterGeneralDatum)
	} else {
		slice = *maybeSapProductMasterGeneralDatum.(*[]*SapProductMasterGeneralDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapProductMasterGeneralDatumR{}
		}
		args = append(args, object.Product)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapProductMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_product_master_quality_data`),
		qm.WhereIn(`sap_product_master_quality_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_product_master_quality_data")
	}

	var resultSlice []*SapProductMasterQualityDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_product_master_quality_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_product_master_quality_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_product_master_quality_data")
	}

	if len(sapProductMasterQualityDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductSapProductMasterQualityData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapProductMasterQualityDatumR{}
			}
			foreign.R.ProductSapProductMasterGeneralDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Product == foreign.Product {
				local.R.ProductSapProductMasterQualityData = append(local.R.ProductSapProductMasterQualityData, foreign)
				if foreign.R == nil {
					foreign.R = &sapProductMasterQualityDatumR{}
				}
				foreign.R.ProductSapProductMasterGeneralDatum = local
				break
			}
		}
	}

	return nil
}

// LoadProductSapProductMasterSalesOrganizationData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapProductMasterGeneralDatumL) LoadProductSapProductMasterSalesOrganizationData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapProductMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*SapProductMasterGeneralDatum
	var object *SapProductMasterGeneralDatum

	if singular {
		object = maybeSapProductMasterGeneralDatum.(*SapProductMasterGeneralDatum)
	} else {
		slice = *maybeSapProductMasterGeneralDatum.(*[]*SapProductMasterGeneralDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapProductMasterGeneralDatumR{}
		}
		args = append(args, object.Product)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapProductMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_product_master_sales_organization_data`),
		qm.WhereIn(`sap_product_master_sales_organization_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_product_master_sales_organization_data")
	}

	var resultSlice []*SapProductMasterSalesOrganizationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_product_master_sales_organization_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_product_master_sales_organization_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_product_master_sales_organization_data")
	}

	if len(sapProductMasterSalesOrganizationDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductSapProductMasterSalesOrganizationData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapProductMasterSalesOrganizationDatumR{}
			}
			foreign.R.ProductSapProductMasterGeneralDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Product == foreign.Product {
				local.R.ProductSapProductMasterSalesOrganizationData = append(local.R.ProductSapProductMasterSalesOrganizationData, foreign)
				if foreign.R == nil {
					foreign.R = &sapProductMasterSalesOrganizationDatumR{}
				}
				foreign.R.ProductSapProductMasterGeneralDatum = local
				break
			}
		}
	}

	return nil
}

// LoadProductSapProductMasterSalesPlantData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapProductMasterGeneralDatumL) LoadProductSapProductMasterSalesPlantData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapProductMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*SapProductMasterGeneralDatum
	var object *SapProductMasterGeneralDatum

	if singular {
		object = maybeSapProductMasterGeneralDatum.(*SapProductMasterGeneralDatum)
	} else {
		slice = *maybeSapProductMasterGeneralDatum.(*[]*SapProductMasterGeneralDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapProductMasterGeneralDatumR{}
		}
		args = append(args, object.Product)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapProductMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_product_master_sales_plant_data`),
		qm.WhereIn(`sap_product_master_sales_plant_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_product_master_sales_plant_data")
	}

	var resultSlice []*SapProductMasterSalesPlantDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_product_master_sales_plant_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_product_master_sales_plant_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_product_master_sales_plant_data")
	}

	if len(sapProductMasterSalesPlantDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductSapProductMasterSalesPlantData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapProductMasterSalesPlantDatumR{}
			}
			foreign.R.ProductSapProductMasterGeneralDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Product == foreign.Product {
				local.R.ProductSapProductMasterSalesPlantData = append(local.R.ProductSapProductMasterSalesPlantData, foreign)
				if foreign.R == nil {
					foreign.R = &sapProductMasterSalesPlantDatumR{}
				}
				foreign.R.ProductSapProductMasterGeneralDatum = local
				break
			}
		}
	}

	return nil
}

// LoadProductSapProductMasterWorkSchedulingData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (sapProductMasterGeneralDatumL) LoadProductSapProductMasterWorkSchedulingData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapProductMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*SapProductMasterGeneralDatum
	var object *SapProductMasterGeneralDatum

	if singular {
		object = maybeSapProductMasterGeneralDatum.(*SapProductMasterGeneralDatum)
	} else {
		slice = *maybeSapProductMasterGeneralDatum.(*[]*SapProductMasterGeneralDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapProductMasterGeneralDatumR{}
		}
		args = append(args, object.Product)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapProductMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_product_master_work_scheduling_data`),
		qm.WhereIn(`sap_product_master_work_scheduling_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sap_product_master_work_scheduling_data")
	}

	var resultSlice []*SapProductMasterWorkSchedulingDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sap_product_master_work_scheduling_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sap_product_master_work_scheduling_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_product_master_work_scheduling_data")
	}

	if len(sapProductMasterWorkSchedulingDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductSapProductMasterWorkSchedulingData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sapProductMasterWorkSchedulingDatumR{}
			}
			foreign.R.ProductSapProductMasterGeneralDatum = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Product == foreign.Product {
				local.R.ProductSapProductMasterWorkSchedulingData = append(local.R.ProductSapProductMasterWorkSchedulingData, foreign)
				if foreign.R == nil {
					foreign.R = &sapProductMasterWorkSchedulingDatumR{}
				}
				foreign.R.ProductSapProductMasterGeneralDatum = local
				break
			}
		}
	}

	return nil
}

// AddProductSapProductMasterAccountingData adds the given related objects to the existing relationships
// of the sap_product_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.ProductSapProductMasterAccountingData.
// Sets related.R.ProductSapProductMasterGeneralDatum appropriately.
func (o *SapProductMasterGeneralDatum) AddProductSapProductMasterAccountingData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapProductMasterAccountingDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Product = o.Product
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_product_master_accounting_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
				strmangle.WhereClause("`", "`", 0, sapProductMasterAccountingDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Product, rel.Product, rel.ValuationArea}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Product = o.Product
		}
	}

	if o.R == nil {
		o.R = &sapProductMasterGeneralDatumR{
			ProductSapProductMasterAccountingData: related,
		}
	} else {
		o.R.ProductSapProductMasterAccountingData = append(o.R.ProductSapProductMasterAccountingData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapProductMasterAccountingDatumR{
				ProductSapProductMasterGeneralDatum: o,
			}
		} else {
			rel.R.ProductSapProductMasterGeneralDatum = o
		}
	}
	return nil
}

// AddProductSapProductMasterMRPAreaData adds the given related objects to the existing relationships
// of the sap_product_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.ProductSapProductMasterMRPAreaData.
// Sets related.R.ProductSapProductMasterGeneralDatum appropriately.
func (o *SapProductMasterGeneralDatum) AddProductSapProductMasterMRPAreaData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapProductMasterMRPAreaDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Product = o.Product
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_product_master_mrp_area_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
				strmangle.WhereClause("`", "`", 0, sapProductMasterMRPAreaDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Product, rel.Product, rel.Plant, rel.MRPArea}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Product = o.Product
		}
	}

	if o.R == nil {
		o.R = &sapProductMasterGeneralDatumR{
			ProductSapProductMasterMRPAreaData: related,
		}
	} else {
		o.R.ProductSapProductMasterMRPAreaData = append(o.R.ProductSapProductMasterMRPAreaData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapProductMasterMRPAreaDatumR{
				ProductSapProductMasterGeneralDatum: o,
			}
		} else {
			rel.R.ProductSapProductMasterGeneralDatum = o
		}
	}
	return nil
}

// AddProductSapProductMasterPlantData adds the given related objects to the existing relationships
// of the sap_product_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.ProductSapProductMasterPlantData.
// Sets related.R.ProductSapProductMasterGeneralDatum appropriately.
func (o *SapProductMasterGeneralDatum) AddProductSapProductMasterPlantData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapProductMasterPlantDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Product = o.Product
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_product_master_plant_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
				strmangle.WhereClause("`", "`", 0, sapProductMasterPlantDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Product, rel.Product, rel.Plant}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Product = o.Product
		}
	}

	if o.R == nil {
		o.R = &sapProductMasterGeneralDatumR{
			ProductSapProductMasterPlantData: related,
		}
	} else {
		o.R.ProductSapProductMasterPlantData = append(o.R.ProductSapProductMasterPlantData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapProductMasterPlantDatumR{
				ProductSapProductMasterGeneralDatum: o,
			}
		} else {
			rel.R.ProductSapProductMasterGeneralDatum = o
		}
	}
	return nil
}

// AddProductSapProductMasterProcurementData adds the given related objects to the existing relationships
// of the sap_product_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.ProductSapProductMasterProcurementData.
// Sets related.R.ProductSapProductMasterGeneralDatum appropriately.
func (o *SapProductMasterGeneralDatum) AddProductSapProductMasterProcurementData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapProductMasterProcurementDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Product = o.Product
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_product_master_procurement_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
				strmangle.WhereClause("`", "`", 0, sapProductMasterProcurementDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Product, rel.Product, rel.Plant}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Product = o.Product
		}
	}

	if o.R == nil {
		o.R = &sapProductMasterGeneralDatumR{
			ProductSapProductMasterProcurementData: related,
		}
	} else {
		o.R.ProductSapProductMasterProcurementData = append(o.R.ProductSapProductMasterProcurementData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapProductMasterProcurementDatumR{
				ProductSapProductMasterGeneralDatum: o,
			}
		} else {
			rel.R.ProductSapProductMasterGeneralDatum = o
		}
	}
	return nil
}

// AddProductSapProductMasterProductDescriptionData adds the given related objects to the existing relationships
// of the sap_product_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.ProductSapProductMasterProductDescriptionData.
// Sets related.R.ProductSapProductMasterGeneralDatum appropriately.
func (o *SapProductMasterGeneralDatum) AddProductSapProductMasterProductDescriptionData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapProductMasterProductDescriptionDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Product = o.Product
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_product_master_product_description_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
				strmangle.WhereClause("`", "`", 0, sapProductMasterProductDescriptionDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Product, rel.Product, rel.Language}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Product = o.Product
		}
	}

	if o.R == nil {
		o.R = &sapProductMasterGeneralDatumR{
			ProductSapProductMasterProductDescriptionData: related,
		}
	} else {
		o.R.ProductSapProductMasterProductDescriptionData = append(o.R.ProductSapProductMasterProductDescriptionData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapProductMasterProductDescriptionDatumR{
				ProductSapProductMasterGeneralDatum: o,
			}
		} else {
			rel.R.ProductSapProductMasterGeneralDatum = o
		}
	}
	return nil
}

// AddProductSapProductMasterQualityData adds the given related objects to the existing relationships
// of the sap_product_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.ProductSapProductMasterQualityData.
// Sets related.R.ProductSapProductMasterGeneralDatum appropriately.
func (o *SapProductMasterGeneralDatum) AddProductSapProductMasterQualityData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapProductMasterQualityDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Product = o.Product
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_product_master_quality_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
				strmangle.WhereClause("`", "`", 0, sapProductMasterQualityDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Product, rel.Product, rel.Plant}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Product = o.Product
		}
	}

	if o.R == nil {
		o.R = &sapProductMasterGeneralDatumR{
			ProductSapProductMasterQualityData: related,
		}
	} else {
		o.R.ProductSapProductMasterQualityData = append(o.R.ProductSapProductMasterQualityData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapProductMasterQualityDatumR{
				ProductSapProductMasterGeneralDatum: o,
			}
		} else {
			rel.R.ProductSapProductMasterGeneralDatum = o
		}
	}
	return nil
}

// AddProductSapProductMasterSalesOrganizationData adds the given related objects to the existing relationships
// of the sap_product_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.ProductSapProductMasterSalesOrganizationData.
// Sets related.R.ProductSapProductMasterGeneralDatum appropriately.
func (o *SapProductMasterGeneralDatum) AddProductSapProductMasterSalesOrganizationData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapProductMasterSalesOrganizationDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Product = o.Product
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_product_master_sales_organization_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
				strmangle.WhereClause("`", "`", 0, sapProductMasterSalesOrganizationDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Product, rel.Product, rel.ProductSalesOrg, rel.ProductDistributionChnl}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Product = o.Product
		}
	}

	if o.R == nil {
		o.R = &sapProductMasterGeneralDatumR{
			ProductSapProductMasterSalesOrganizationData: related,
		}
	} else {
		o.R.ProductSapProductMasterSalesOrganizationData = append(o.R.ProductSapProductMasterSalesOrganizationData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapProductMasterSalesOrganizationDatumR{
				ProductSapProductMasterGeneralDatum: o,
			}
		} else {
			rel.R.ProductSapProductMasterGeneralDatum = o
		}
	}
	return nil
}

// AddProductSapProductMasterSalesPlantData adds the given related objects to the existing relationships
// of the sap_product_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.ProductSapProductMasterSalesPlantData.
// Sets related.R.ProductSapProductMasterGeneralDatum appropriately.
func (o *SapProductMasterGeneralDatum) AddProductSapProductMasterSalesPlantData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapProductMasterSalesPlantDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Product = o.Product
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_product_master_sales_plant_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
				strmangle.WhereClause("`", "`", 0, sapProductMasterSalesPlantDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Product, rel.Product, rel.Plant}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Product = o.Product
		}
	}

	if o.R == nil {
		o.R = &sapProductMasterGeneralDatumR{
			ProductSapProductMasterSalesPlantData: related,
		}
	} else {
		o.R.ProductSapProductMasterSalesPlantData = append(o.R.ProductSapProductMasterSalesPlantData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapProductMasterSalesPlantDatumR{
				ProductSapProductMasterGeneralDatum: o,
			}
		} else {
			rel.R.ProductSapProductMasterGeneralDatum = o
		}
	}
	return nil
}

// AddProductSapProductMasterWorkSchedulingData adds the given related objects to the existing relationships
// of the sap_product_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.ProductSapProductMasterWorkSchedulingData.
// Sets related.R.ProductSapProductMasterGeneralDatum appropriately.
func (o *SapProductMasterGeneralDatum) AddProductSapProductMasterWorkSchedulingData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SapProductMasterWorkSchedulingDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Product = o.Product
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sap_product_master_work_scheduling_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
				strmangle.WhereClause("`", "`", 0, sapProductMasterWorkSchedulingDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Product, rel.Product, rel.Plant}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Product = o.Product
		}
	}

	if o.R == nil {
		o.R = &sapProductMasterGeneralDatumR{
			ProductSapProductMasterWorkSchedulingData: related,
		}
	} else {
		o.R.ProductSapProductMasterWorkSchedulingData = append(o.R.ProductSapProductMasterWorkSchedulingData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sapProductMasterWorkSchedulingDatumR{
				ProductSapProductMasterGeneralDatum: o,
			}
		} else {
			rel.R.ProductSapProductMasterGeneralDatum = o
		}
	}
	return nil
}

// SapProductMasterGeneralData retrieves all the records using an executor.
func SapProductMasterGeneralData(mods ...qm.QueryMod) sapProductMasterGeneralDatumQuery {
	mods = append(mods, qm.From("`sap_product_master_general_data`"))
	return sapProductMasterGeneralDatumQuery{NewQuery(mods...)}
}

// FindSapProductMasterGeneralDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapProductMasterGeneralDatum(ctx context.Context, exec boil.ContextExecutor, product string, selectCols ...string) (*SapProductMasterGeneralDatum, error) {
	sapProductMasterGeneralDatumObj := &SapProductMasterGeneralDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_product_master_general_data` where `Product`=?", sel,
	)

	q := queries.Raw(query, product)

	err := q.Bind(ctx, exec, sapProductMasterGeneralDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_product_master_general_data")
	}

	if err = sapProductMasterGeneralDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapProductMasterGeneralDatumObj, err
	}

	return sapProductMasterGeneralDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapProductMasterGeneralDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_product_master_general_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapProductMasterGeneralDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapProductMasterGeneralDatumInsertCacheMut.RLock()
	cache, cached := sapProductMasterGeneralDatumInsertCache[key]
	sapProductMasterGeneralDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapProductMasterGeneralDatumAllColumns,
			sapProductMasterGeneralDatumColumnsWithDefault,
			sapProductMasterGeneralDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_product_master_general_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_product_master_general_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_product_master_general_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapProductMasterGeneralDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_product_master_general_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.Product,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_product_master_general_data")
	}

CacheNoHooks:
	if !cached {
		sapProductMasterGeneralDatumInsertCacheMut.Lock()
		sapProductMasterGeneralDatumInsertCache[key] = cache
		sapProductMasterGeneralDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapProductMasterGeneralDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapProductMasterGeneralDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapProductMasterGeneralDatumUpdateCacheMut.RLock()
	cache, cached := sapProductMasterGeneralDatumUpdateCache[key]
	sapProductMasterGeneralDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapProductMasterGeneralDatumAllColumns,
			sapProductMasterGeneralDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_product_master_general_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_product_master_general_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapProductMasterGeneralDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, append(wl, sapProductMasterGeneralDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_product_master_general_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_product_master_general_data")
	}

	if !cached {
		sapProductMasterGeneralDatumUpdateCacheMut.Lock()
		sapProductMasterGeneralDatumUpdateCache[key] = cache
		sapProductMasterGeneralDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapProductMasterGeneralDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_product_master_general_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_product_master_general_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapProductMasterGeneralDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapProductMasterGeneralDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_product_master_general_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapProductMasterGeneralDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapProductMasterGeneralDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapProductMasterGeneralDatum")
	}
	return rowsAff, nil
}

var mySQLSapProductMasterGeneralDatumUniqueColumns = []string{
	"Product",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapProductMasterGeneralDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_product_master_general_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapProductMasterGeneralDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapProductMasterGeneralDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapProductMasterGeneralDatumUpsertCacheMut.RLock()
	cache, cached := sapProductMasterGeneralDatumUpsertCache[key]
	sapProductMasterGeneralDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapProductMasterGeneralDatumAllColumns,
			sapProductMasterGeneralDatumColumnsWithDefault,
			sapProductMasterGeneralDatumColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			sapProductMasterGeneralDatumAllColumns,
			sapProductMasterGeneralDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_product_master_general_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_product_master_general_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_product_master_general_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_product_master_general_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_product_master_general_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_product_master_general_data")
	}

CacheNoHooks:
	if !cached {
		sapProductMasterGeneralDatumUpsertCacheMut.Lock()
		sapProductMasterGeneralDatumUpsertCache[key] = cache
		sapProductMasterGeneralDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapProductMasterGeneralDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapProductMasterGeneralDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapProductMasterGeneralDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapProductMasterGeneralDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_product_master_general_data` WHERE `Product`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_product_master_general_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_product_master_general_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapProductMasterGeneralDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapProductMasterGeneralDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_product_master_general_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_product_master_general_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapProductMasterGeneralDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapProductMasterGeneralDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapProductMasterGeneralDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_product_master_general_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapProductMasterGeneralDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapProductMasterGeneralDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_product_master_general_data")
	}

	if len(sapProductMasterGeneralDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapProductMasterGeneralDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapProductMasterGeneralDatum(ctx, exec, o.Product)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapProductMasterGeneralDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapProductMasterGeneralDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapProductMasterGeneralDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_product_master_general_data`.* FROM `sap_product_master_general_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapProductMasterGeneralDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapProductMasterGeneralDatumSlice")
	}

	*o = slice

	return nil
}

// SapProductMasterGeneralDatumExists checks if the SapProductMasterGeneralDatum row exists.
func SapProductMasterGeneralDatumExists(ctx context.Context, exec boil.ContextExecutor, product string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_product_master_general_data` where `Product`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, product)
	}
	row := exec.QueryRowContext(ctx, sql, product)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_product_master_general_data exists")
	}

	return exists, nil
}
