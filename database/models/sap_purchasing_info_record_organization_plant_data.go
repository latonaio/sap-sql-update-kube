// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapPurchasingInfoRecordOrganizationPlantDatum is an object representing the database table.
type SapPurchasingInfoRecordOrganizationPlantDatum struct {
	PurchasingInfoRecord           string      `boil:"PurchasingInfoRecord" json:"PurchasingInfoRecord" toml:"PurchasingInfoRecord" yaml:"PurchasingInfoRecord"`
	PurchasingInfoRecordCategory   string      `boil:"PurchasingInfoRecordCategory" json:"PurchasingInfoRecordCategory" toml:"PurchasingInfoRecordCategory" yaml:"PurchasingInfoRecordCategory"`
	PurchasingOrganization         string      `boil:"PurchasingOrganization" json:"PurchasingOrganization" toml:"PurchasingOrganization" yaml:"PurchasingOrganization"`
	Plant                          string      `boil:"Plant" json:"Plant" toml:"Plant" yaml:"Plant"`
	Supplier                       null.String `boil:"Supplier" json:"Supplier,omitempty" toml:"Supplier" yaml:"Supplier,omitempty"`
	Material                       null.String `boil:"Material" json:"Material,omitempty" toml:"Material" yaml:"Material,omitempty"`
	MaterialGroup                  null.String `boil:"MaterialGroup" json:"MaterialGroup,omitempty" toml:"MaterialGroup" yaml:"MaterialGroup,omitempty"`
	PurgDocOrderQuantityUnit       null.String `boil:"PurgDocOrderQuantityUnit" json:"PurgDocOrderQuantityUnit,omitempty" toml:"PurgDocOrderQuantityUnit" yaml:"PurgDocOrderQuantityUnit,omitempty"`
	PurchasingGroup                null.String `boil:"PurchasingGroup" json:"PurchasingGroup,omitempty" toml:"PurchasingGroup" yaml:"PurchasingGroup,omitempty"`
	MinimumPurchaseOrderQuantity   null.String `boil:"MinimumPurchaseOrderQuantity" json:"MinimumPurchaseOrderQuantity,omitempty" toml:"MinimumPurchaseOrderQuantity" yaml:"MinimumPurchaseOrderQuantity,omitempty"`
	StandardPurchaseOrderQuantity  null.String `boil:"StandardPurchaseOrderQuantity" json:"StandardPurchaseOrderQuantity,omitempty" toml:"StandardPurchaseOrderQuantity" yaml:"StandardPurchaseOrderQuantity,omitempty"`
	MaterialPlannedDeliveryDurn    null.String `boil:"MaterialPlannedDeliveryDurn" json:"MaterialPlannedDeliveryDurn,omitempty" toml:"MaterialPlannedDeliveryDurn" yaml:"MaterialPlannedDeliveryDurn,omitempty"`
	OverdelivTolrtdLmtRatioInPct   null.String `boil:"OverdelivTolrtdLmtRatioInPct" json:"OverdelivTolrtdLmtRatioInPct,omitempty" toml:"OverdelivTolrtdLmtRatioInPct" yaml:"OverdelivTolrtdLmtRatioInPct,omitempty"`
	UnderdelivTolrtdLmtRatioInPct  null.String `boil:"UnderdelivTolrtdLmtRatioInPct" json:"UnderdelivTolrtdLmtRatioInPct,omitempty" toml:"UnderdelivTolrtdLmtRatioInPct" yaml:"UnderdelivTolrtdLmtRatioInPct,omitempty"`
	UnlimitedOverdeliveryIsAllowed null.Bool   `boil:"UnlimitedOverdeliveryIsAllowed" json:"UnlimitedOverdeliveryIsAllowed,omitempty" toml:"UnlimitedOverdeliveryIsAllowed" yaml:"UnlimitedOverdeliveryIsAllowed,omitempty"`
	LastReferencingPurchaseOrder   null.String `boil:"LastReferencingPurchaseOrder" json:"LastReferencingPurchaseOrder,omitempty" toml:"LastReferencingPurchaseOrder" yaml:"LastReferencingPurchaseOrder,omitempty"`
	LastReferencingPurOrderItem    null.String `boil:"LastReferencingPurOrderItem" json:"LastReferencingPurOrderItem,omitempty" toml:"LastReferencingPurOrderItem" yaml:"LastReferencingPurOrderItem,omitempty"`
	NetPriceAmount                 null.String `boil:"NetPriceAmount" json:"NetPriceAmount,omitempty" toml:"NetPriceAmount" yaml:"NetPriceAmount,omitempty"`
	MaterialPriceUnitQty           null.String `boil:"MaterialPriceUnitQty" json:"MaterialPriceUnitQty,omitempty" toml:"MaterialPriceUnitQty" yaml:"MaterialPriceUnitQty,omitempty"`
	PurchaseOrderPriceUnit         null.String `boil:"PurchaseOrderPriceUnit" json:"PurchaseOrderPriceUnit,omitempty" toml:"PurchaseOrderPriceUnit" yaml:"PurchaseOrderPriceUnit,omitempty"`
	PriceValidityEndDate           null.String `boil:"PriceValidityEndDate" json:"PriceValidityEndDate,omitempty" toml:"PriceValidityEndDate" yaml:"PriceValidityEndDate,omitempty"`
	InvoiceIsGoodsReceiptBased     null.Bool   `boil:"InvoiceIsGoodsReceiptBased" json:"InvoiceIsGoodsReceiptBased,omitempty" toml:"InvoiceIsGoodsReceiptBased" yaml:"InvoiceIsGoodsReceiptBased,omitempty"`
	TaxCode                        null.String `boil:"TaxCode" json:"TaxCode,omitempty" toml:"TaxCode" yaml:"TaxCode,omitempty"`
	IncotermsClassification        null.String `boil:"IncotermsClassification" json:"IncotermsClassification,omitempty" toml:"IncotermsClassification" yaml:"IncotermsClassification,omitempty"`
	MaximumOrderQuantity           null.String `boil:"MaximumOrderQuantity" json:"MaximumOrderQuantity,omitempty" toml:"MaximumOrderQuantity" yaml:"MaximumOrderQuantity,omitempty"`
	IsRelevantForAutomSrcg         null.String `boil:"IsRelevantForAutomSrcg" json:"IsRelevantForAutomSrcg,omitempty" toml:"IsRelevantForAutomSrcg" yaml:"IsRelevantForAutomSrcg,omitempty"`
	IsEvaluatedRcptSettlmtAllowed  null.Bool   `boil:"IsEvaluatedRcptSettlmtAllowed" json:"IsEvaluatedRcptSettlmtAllowed,omitempty" toml:"IsEvaluatedRcptSettlmtAllowed" yaml:"IsEvaluatedRcptSettlmtAllowed,omitempty"`
	IsPurOrderAllwdForInbDeliv     null.Bool   `boil:"IsPurOrderAllwdForInbDeliv" json:"IsPurOrderAllwdForInbDeliv,omitempty" toml:"IsPurOrderAllwdForInbDeliv" yaml:"IsPurOrderAllwdForInbDeliv,omitempty"`
	IsOrderAcknRqd                 null.Bool   `boil:"IsOrderAcknRqd" json:"IsOrderAcknRqd,omitempty" toml:"IsOrderAcknRqd" yaml:"IsOrderAcknRqd,omitempty"`
	IsMarkedForDeletion            null.Bool   `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *sapPurchasingInfoRecordOrganizationPlantDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapPurchasingInfoRecordOrganizationPlantDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapPurchasingInfoRecordOrganizationPlantDatumColumns = struct {
	PurchasingInfoRecord           string
	PurchasingInfoRecordCategory   string
	PurchasingOrganization         string
	Plant                          string
	Supplier                       string
	Material                       string
	MaterialGroup                  string
	PurgDocOrderQuantityUnit       string
	PurchasingGroup                string
	MinimumPurchaseOrderQuantity   string
	StandardPurchaseOrderQuantity  string
	MaterialPlannedDeliveryDurn    string
	OverdelivTolrtdLmtRatioInPct   string
	UnderdelivTolrtdLmtRatioInPct  string
	UnlimitedOverdeliveryIsAllowed string
	LastReferencingPurchaseOrder   string
	LastReferencingPurOrderItem    string
	NetPriceAmount                 string
	MaterialPriceUnitQty           string
	PurchaseOrderPriceUnit         string
	PriceValidityEndDate           string
	InvoiceIsGoodsReceiptBased     string
	TaxCode                        string
	IncotermsClassification        string
	MaximumOrderQuantity           string
	IsRelevantForAutomSrcg         string
	IsEvaluatedRcptSettlmtAllowed  string
	IsPurOrderAllwdForInbDeliv     string
	IsOrderAcknRqd                 string
	IsMarkedForDeletion            string
}{
	PurchasingInfoRecord:           "PurchasingInfoRecord",
	PurchasingInfoRecordCategory:   "PurchasingInfoRecordCategory",
	PurchasingOrganization:         "PurchasingOrganization",
	Plant:                          "Plant",
	Supplier:                       "Supplier",
	Material:                       "Material",
	MaterialGroup:                  "MaterialGroup",
	PurgDocOrderQuantityUnit:       "PurgDocOrderQuantityUnit",
	PurchasingGroup:                "PurchasingGroup",
	MinimumPurchaseOrderQuantity:   "MinimumPurchaseOrderQuantity",
	StandardPurchaseOrderQuantity:  "StandardPurchaseOrderQuantity",
	MaterialPlannedDeliveryDurn:    "MaterialPlannedDeliveryDurn",
	OverdelivTolrtdLmtRatioInPct:   "OverdelivTolrtdLmtRatioInPct",
	UnderdelivTolrtdLmtRatioInPct:  "UnderdelivTolrtdLmtRatioInPct",
	UnlimitedOverdeliveryIsAllowed: "UnlimitedOverdeliveryIsAllowed",
	LastReferencingPurchaseOrder:   "LastReferencingPurchaseOrder",
	LastReferencingPurOrderItem:    "LastReferencingPurOrderItem",
	NetPriceAmount:                 "NetPriceAmount",
	MaterialPriceUnitQty:           "MaterialPriceUnitQty",
	PurchaseOrderPriceUnit:         "PurchaseOrderPriceUnit",
	PriceValidityEndDate:           "PriceValidityEndDate",
	InvoiceIsGoodsReceiptBased:     "InvoiceIsGoodsReceiptBased",
	TaxCode:                        "TaxCode",
	IncotermsClassification:        "IncotermsClassification",
	MaximumOrderQuantity:           "MaximumOrderQuantity",
	IsRelevantForAutomSrcg:         "IsRelevantForAutomSrcg",
	IsEvaluatedRcptSettlmtAllowed:  "IsEvaluatedRcptSettlmtAllowed",
	IsPurOrderAllwdForInbDeliv:     "IsPurOrderAllwdForInbDeliv",
	IsOrderAcknRqd:                 "IsOrderAcknRqd",
	IsMarkedForDeletion:            "IsMarkedForDeletion",
}

var SapPurchasingInfoRecordOrganizationPlantDatumTableColumns = struct {
	PurchasingInfoRecord           string
	PurchasingInfoRecordCategory   string
	PurchasingOrganization         string
	Plant                          string
	Supplier                       string
	Material                       string
	MaterialGroup                  string
	PurgDocOrderQuantityUnit       string
	PurchasingGroup                string
	MinimumPurchaseOrderQuantity   string
	StandardPurchaseOrderQuantity  string
	MaterialPlannedDeliveryDurn    string
	OverdelivTolrtdLmtRatioInPct   string
	UnderdelivTolrtdLmtRatioInPct  string
	UnlimitedOverdeliveryIsAllowed string
	LastReferencingPurchaseOrder   string
	LastReferencingPurOrderItem    string
	NetPriceAmount                 string
	MaterialPriceUnitQty           string
	PurchaseOrderPriceUnit         string
	PriceValidityEndDate           string
	InvoiceIsGoodsReceiptBased     string
	TaxCode                        string
	IncotermsClassification        string
	MaximumOrderQuantity           string
	IsRelevantForAutomSrcg         string
	IsEvaluatedRcptSettlmtAllowed  string
	IsPurOrderAllwdForInbDeliv     string
	IsOrderAcknRqd                 string
	IsMarkedForDeletion            string
}{
	PurchasingInfoRecord:           "sap_purchasing_info_record_organization_plant_data.PurchasingInfoRecord",
	PurchasingInfoRecordCategory:   "sap_purchasing_info_record_organization_plant_data.PurchasingInfoRecordCategory",
	PurchasingOrganization:         "sap_purchasing_info_record_organization_plant_data.PurchasingOrganization",
	Plant:                          "sap_purchasing_info_record_organization_plant_data.Plant",
	Supplier:                       "sap_purchasing_info_record_organization_plant_data.Supplier",
	Material:                       "sap_purchasing_info_record_organization_plant_data.Material",
	MaterialGroup:                  "sap_purchasing_info_record_organization_plant_data.MaterialGroup",
	PurgDocOrderQuantityUnit:       "sap_purchasing_info_record_organization_plant_data.PurgDocOrderQuantityUnit",
	PurchasingGroup:                "sap_purchasing_info_record_organization_plant_data.PurchasingGroup",
	MinimumPurchaseOrderQuantity:   "sap_purchasing_info_record_organization_plant_data.MinimumPurchaseOrderQuantity",
	StandardPurchaseOrderQuantity:  "sap_purchasing_info_record_organization_plant_data.StandardPurchaseOrderQuantity",
	MaterialPlannedDeliveryDurn:    "sap_purchasing_info_record_organization_plant_data.MaterialPlannedDeliveryDurn",
	OverdelivTolrtdLmtRatioInPct:   "sap_purchasing_info_record_organization_plant_data.OverdelivTolrtdLmtRatioInPct",
	UnderdelivTolrtdLmtRatioInPct:  "sap_purchasing_info_record_organization_plant_data.UnderdelivTolrtdLmtRatioInPct",
	UnlimitedOverdeliveryIsAllowed: "sap_purchasing_info_record_organization_plant_data.UnlimitedOverdeliveryIsAllowed",
	LastReferencingPurchaseOrder:   "sap_purchasing_info_record_organization_plant_data.LastReferencingPurchaseOrder",
	LastReferencingPurOrderItem:    "sap_purchasing_info_record_organization_plant_data.LastReferencingPurOrderItem",
	NetPriceAmount:                 "sap_purchasing_info_record_organization_plant_data.NetPriceAmount",
	MaterialPriceUnitQty:           "sap_purchasing_info_record_organization_plant_data.MaterialPriceUnitQty",
	PurchaseOrderPriceUnit:         "sap_purchasing_info_record_organization_plant_data.PurchaseOrderPriceUnit",
	PriceValidityEndDate:           "sap_purchasing_info_record_organization_plant_data.PriceValidityEndDate",
	InvoiceIsGoodsReceiptBased:     "sap_purchasing_info_record_organization_plant_data.InvoiceIsGoodsReceiptBased",
	TaxCode:                        "sap_purchasing_info_record_organization_plant_data.TaxCode",
	IncotermsClassification:        "sap_purchasing_info_record_organization_plant_data.IncotermsClassification",
	MaximumOrderQuantity:           "sap_purchasing_info_record_organization_plant_data.MaximumOrderQuantity",
	IsRelevantForAutomSrcg:         "sap_purchasing_info_record_organization_plant_data.IsRelevantForAutomSrcg",
	IsEvaluatedRcptSettlmtAllowed:  "sap_purchasing_info_record_organization_plant_data.IsEvaluatedRcptSettlmtAllowed",
	IsPurOrderAllwdForInbDeliv:     "sap_purchasing_info_record_organization_plant_data.IsPurOrderAllwdForInbDeliv",
	IsOrderAcknRqd:                 "sap_purchasing_info_record_organization_plant_data.IsOrderAcknRqd",
	IsMarkedForDeletion:            "sap_purchasing_info_record_organization_plant_data.IsMarkedForDeletion",
}

// Generated where

var SapPurchasingInfoRecordOrganizationPlantDatumWhere = struct {
	PurchasingInfoRecord           whereHelperstring
	PurchasingInfoRecordCategory   whereHelperstring
	PurchasingOrganization         whereHelperstring
	Plant                          whereHelperstring
	Supplier                       whereHelpernull_String
	Material                       whereHelpernull_String
	MaterialGroup                  whereHelpernull_String
	PurgDocOrderQuantityUnit       whereHelpernull_String
	PurchasingGroup                whereHelpernull_String
	MinimumPurchaseOrderQuantity   whereHelpernull_String
	StandardPurchaseOrderQuantity  whereHelpernull_String
	MaterialPlannedDeliveryDurn    whereHelpernull_String
	OverdelivTolrtdLmtRatioInPct   whereHelpernull_String
	UnderdelivTolrtdLmtRatioInPct  whereHelpernull_String
	UnlimitedOverdeliveryIsAllowed whereHelpernull_Bool
	LastReferencingPurchaseOrder   whereHelpernull_String
	LastReferencingPurOrderItem    whereHelpernull_String
	NetPriceAmount                 whereHelpernull_String
	MaterialPriceUnitQty           whereHelpernull_String
	PurchaseOrderPriceUnit         whereHelpernull_String
	PriceValidityEndDate           whereHelpernull_String
	InvoiceIsGoodsReceiptBased     whereHelpernull_Bool
	TaxCode                        whereHelpernull_String
	IncotermsClassification        whereHelpernull_String
	MaximumOrderQuantity           whereHelpernull_String
	IsRelevantForAutomSrcg         whereHelpernull_String
	IsEvaluatedRcptSettlmtAllowed  whereHelpernull_Bool
	IsPurOrderAllwdForInbDeliv     whereHelpernull_Bool
	IsOrderAcknRqd                 whereHelpernull_Bool
	IsMarkedForDeletion            whereHelpernull_Bool
}{
	PurchasingInfoRecord:           whereHelperstring{field: "`sap_purchasing_info_record_organization_plant_data`.`PurchasingInfoRecord`"},
	PurchasingInfoRecordCategory:   whereHelperstring{field: "`sap_purchasing_info_record_organization_plant_data`.`PurchasingInfoRecordCategory`"},
	PurchasingOrganization:         whereHelperstring{field: "`sap_purchasing_info_record_organization_plant_data`.`PurchasingOrganization`"},
	Plant:                          whereHelperstring{field: "`sap_purchasing_info_record_organization_plant_data`.`Plant`"},
	Supplier:                       whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`Supplier`"},
	Material:                       whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`Material`"},
	MaterialGroup:                  whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`MaterialGroup`"},
	PurgDocOrderQuantityUnit:       whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`PurgDocOrderQuantityUnit`"},
	PurchasingGroup:                whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`PurchasingGroup`"},
	MinimumPurchaseOrderQuantity:   whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`MinimumPurchaseOrderQuantity`"},
	StandardPurchaseOrderQuantity:  whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`StandardPurchaseOrderQuantity`"},
	MaterialPlannedDeliveryDurn:    whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`MaterialPlannedDeliveryDurn`"},
	OverdelivTolrtdLmtRatioInPct:   whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`OverdelivTolrtdLmtRatioInPct`"},
	UnderdelivTolrtdLmtRatioInPct:  whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`UnderdelivTolrtdLmtRatioInPct`"},
	UnlimitedOverdeliveryIsAllowed: whereHelpernull_Bool{field: "`sap_purchasing_info_record_organization_plant_data`.`UnlimitedOverdeliveryIsAllowed`"},
	LastReferencingPurchaseOrder:   whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`LastReferencingPurchaseOrder`"},
	LastReferencingPurOrderItem:    whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`LastReferencingPurOrderItem`"},
	NetPriceAmount:                 whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`NetPriceAmount`"},
	MaterialPriceUnitQty:           whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`MaterialPriceUnitQty`"},
	PurchaseOrderPriceUnit:         whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`PurchaseOrderPriceUnit`"},
	PriceValidityEndDate:           whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`PriceValidityEndDate`"},
	InvoiceIsGoodsReceiptBased:     whereHelpernull_Bool{field: "`sap_purchasing_info_record_organization_plant_data`.`InvoiceIsGoodsReceiptBased`"},
	TaxCode:                        whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`TaxCode`"},
	IncotermsClassification:        whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`IncotermsClassification`"},
	MaximumOrderQuantity:           whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`MaximumOrderQuantity`"},
	IsRelevantForAutomSrcg:         whereHelpernull_String{field: "`sap_purchasing_info_record_organization_plant_data`.`IsRelevantForAutomSrcg`"},
	IsEvaluatedRcptSettlmtAllowed:  whereHelpernull_Bool{field: "`sap_purchasing_info_record_organization_plant_data`.`IsEvaluatedRcptSettlmtAllowed`"},
	IsPurOrderAllwdForInbDeliv:     whereHelpernull_Bool{field: "`sap_purchasing_info_record_organization_plant_data`.`IsPurOrderAllwdForInbDeliv`"},
	IsOrderAcknRqd:                 whereHelpernull_Bool{field: "`sap_purchasing_info_record_organization_plant_data`.`IsOrderAcknRqd`"},
	IsMarkedForDeletion:            whereHelpernull_Bool{field: "`sap_purchasing_info_record_organization_plant_data`.`IsMarkedForDeletion`"},
}

// SapPurchasingInfoRecordOrganizationPlantDatumRels is where relationship names are stored.
var SapPurchasingInfoRecordOrganizationPlantDatumRels = struct {
	PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum string
}{
	PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum: "PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum",
}

// sapPurchasingInfoRecordOrganizationPlantDatumR is where relationships are stored.
type sapPurchasingInfoRecordOrganizationPlantDatumR struct {
	PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum *SapPurchasingInfoRecordGeneralDatum `boil:"PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum" json:"PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum" toml:"PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum" yaml:"PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum"`
}

// NewStruct creates a new relationship struct
func (*sapPurchasingInfoRecordOrganizationPlantDatumR) NewStruct() *sapPurchasingInfoRecordOrganizationPlantDatumR {
	return &sapPurchasingInfoRecordOrganizationPlantDatumR{}
}

// sapPurchasingInfoRecordOrganizationPlantDatumL is where Load methods for each relationship are stored.
type sapPurchasingInfoRecordOrganizationPlantDatumL struct{}

var (
	sapPurchasingInfoRecordOrganizationPlantDatumAllColumns            = []string{"PurchasingInfoRecord", "PurchasingInfoRecordCategory", "PurchasingOrganization", "Plant", "Supplier", "Material", "MaterialGroup", "PurgDocOrderQuantityUnit", "PurchasingGroup", "MinimumPurchaseOrderQuantity", "StandardPurchaseOrderQuantity", "MaterialPlannedDeliveryDurn", "OverdelivTolrtdLmtRatioInPct", "UnderdelivTolrtdLmtRatioInPct", "UnlimitedOverdeliveryIsAllowed", "LastReferencingPurchaseOrder", "LastReferencingPurOrderItem", "NetPriceAmount", "MaterialPriceUnitQty", "PurchaseOrderPriceUnit", "PriceValidityEndDate", "InvoiceIsGoodsReceiptBased", "TaxCode", "IncotermsClassification", "MaximumOrderQuantity", "IsRelevantForAutomSrcg", "IsEvaluatedRcptSettlmtAllowed", "IsPurOrderAllwdForInbDeliv", "IsOrderAcknRqd", "IsMarkedForDeletion"}
	sapPurchasingInfoRecordOrganizationPlantDatumColumnsWithoutDefault = []string{"PurchasingInfoRecord", "PurchasingInfoRecordCategory", "PurchasingOrganization", "Plant", "Supplier", "Material", "MaterialGroup", "PurgDocOrderQuantityUnit", "PurchasingGroup", "MinimumPurchaseOrderQuantity", "StandardPurchaseOrderQuantity", "MaterialPlannedDeliveryDurn", "OverdelivTolrtdLmtRatioInPct", "UnderdelivTolrtdLmtRatioInPct", "UnlimitedOverdeliveryIsAllowed", "LastReferencingPurchaseOrder", "LastReferencingPurOrderItem", "NetPriceAmount", "MaterialPriceUnitQty", "PurchaseOrderPriceUnit", "PriceValidityEndDate", "InvoiceIsGoodsReceiptBased", "TaxCode", "IncotermsClassification", "MaximumOrderQuantity", "IsRelevantForAutomSrcg", "IsEvaluatedRcptSettlmtAllowed", "IsPurOrderAllwdForInbDeliv", "IsOrderAcknRqd", "IsMarkedForDeletion"}
	sapPurchasingInfoRecordOrganizationPlantDatumColumnsWithDefault    = []string{}
	sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns     = []string{"PurchasingInfoRecord", "PurchasingInfoRecordCategory", "PurchasingOrganization", "Plant"}
	sapPurchasingInfoRecordOrganizationPlantDatumGeneratedColumns      = []string{}
)

type (
	// SapPurchasingInfoRecordOrganizationPlantDatumSlice is an alias for a slice of pointers to SapPurchasingInfoRecordOrganizationPlantDatum.
	// This should almost always be used instead of []SapPurchasingInfoRecordOrganizationPlantDatum.
	SapPurchasingInfoRecordOrganizationPlantDatumSlice []*SapPurchasingInfoRecordOrganizationPlantDatum
	// SapPurchasingInfoRecordOrganizationPlantDatumHook is the signature for custom SapPurchasingInfoRecordOrganizationPlantDatum hook methods
	SapPurchasingInfoRecordOrganizationPlantDatumHook func(context.Context, boil.ContextExecutor, *SapPurchasingInfoRecordOrganizationPlantDatum) error

	sapPurchasingInfoRecordOrganizationPlantDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapPurchasingInfoRecordOrganizationPlantDatumType                 = reflect.TypeOf(&SapPurchasingInfoRecordOrganizationPlantDatum{})
	sapPurchasingInfoRecordOrganizationPlantDatumMapping              = queries.MakeStructMapping(sapPurchasingInfoRecordOrganizationPlantDatumType)
	sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyMapping, _ = queries.BindMapping(sapPurchasingInfoRecordOrganizationPlantDatumType, sapPurchasingInfoRecordOrganizationPlantDatumMapping, sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns)
	sapPurchasingInfoRecordOrganizationPlantDatumInsertCacheMut       sync.RWMutex
	sapPurchasingInfoRecordOrganizationPlantDatumInsertCache          = make(map[string]insertCache)
	sapPurchasingInfoRecordOrganizationPlantDatumUpdateCacheMut       sync.RWMutex
	sapPurchasingInfoRecordOrganizationPlantDatumUpdateCache          = make(map[string]updateCache)
	sapPurchasingInfoRecordOrganizationPlantDatumUpsertCacheMut       sync.RWMutex
	sapPurchasingInfoRecordOrganizationPlantDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapPurchasingInfoRecordOrganizationPlantDatumAfterSelectHooks []SapPurchasingInfoRecordOrganizationPlantDatumHook

var sapPurchasingInfoRecordOrganizationPlantDatumBeforeInsertHooks []SapPurchasingInfoRecordOrganizationPlantDatumHook
var sapPurchasingInfoRecordOrganizationPlantDatumAfterInsertHooks []SapPurchasingInfoRecordOrganizationPlantDatumHook

var sapPurchasingInfoRecordOrganizationPlantDatumBeforeUpdateHooks []SapPurchasingInfoRecordOrganizationPlantDatumHook
var sapPurchasingInfoRecordOrganizationPlantDatumAfterUpdateHooks []SapPurchasingInfoRecordOrganizationPlantDatumHook

var sapPurchasingInfoRecordOrganizationPlantDatumBeforeDeleteHooks []SapPurchasingInfoRecordOrganizationPlantDatumHook
var sapPurchasingInfoRecordOrganizationPlantDatumAfterDeleteHooks []SapPurchasingInfoRecordOrganizationPlantDatumHook

var sapPurchasingInfoRecordOrganizationPlantDatumBeforeUpsertHooks []SapPurchasingInfoRecordOrganizationPlantDatumHook
var sapPurchasingInfoRecordOrganizationPlantDatumAfterUpsertHooks []SapPurchasingInfoRecordOrganizationPlantDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchasingInfoRecordOrganizationPlantDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchasingInfoRecordOrganizationPlantDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchasingInfoRecordOrganizationPlantDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchasingInfoRecordOrganizationPlantDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchasingInfoRecordOrganizationPlantDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchasingInfoRecordOrganizationPlantDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchasingInfoRecordOrganizationPlantDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchasingInfoRecordOrganizationPlantDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapPurchasingInfoRecordOrganizationPlantDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapPurchasingInfoRecordOrganizationPlantDatumHook registers your hook function for all future operations.
func AddSapPurchasingInfoRecordOrganizationPlantDatumHook(hookPoint boil.HookPoint, sapPurchasingInfoRecordOrganizationPlantDatumHook SapPurchasingInfoRecordOrganizationPlantDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapPurchasingInfoRecordOrganizationPlantDatumAfterSelectHooks = append(sapPurchasingInfoRecordOrganizationPlantDatumAfterSelectHooks, sapPurchasingInfoRecordOrganizationPlantDatumHook)
	case boil.BeforeInsertHook:
		sapPurchasingInfoRecordOrganizationPlantDatumBeforeInsertHooks = append(sapPurchasingInfoRecordOrganizationPlantDatumBeforeInsertHooks, sapPurchasingInfoRecordOrganizationPlantDatumHook)
	case boil.AfterInsertHook:
		sapPurchasingInfoRecordOrganizationPlantDatumAfterInsertHooks = append(sapPurchasingInfoRecordOrganizationPlantDatumAfterInsertHooks, sapPurchasingInfoRecordOrganizationPlantDatumHook)
	case boil.BeforeUpdateHook:
		sapPurchasingInfoRecordOrganizationPlantDatumBeforeUpdateHooks = append(sapPurchasingInfoRecordOrganizationPlantDatumBeforeUpdateHooks, sapPurchasingInfoRecordOrganizationPlantDatumHook)
	case boil.AfterUpdateHook:
		sapPurchasingInfoRecordOrganizationPlantDatumAfterUpdateHooks = append(sapPurchasingInfoRecordOrganizationPlantDatumAfterUpdateHooks, sapPurchasingInfoRecordOrganizationPlantDatumHook)
	case boil.BeforeDeleteHook:
		sapPurchasingInfoRecordOrganizationPlantDatumBeforeDeleteHooks = append(sapPurchasingInfoRecordOrganizationPlantDatumBeforeDeleteHooks, sapPurchasingInfoRecordOrganizationPlantDatumHook)
	case boil.AfterDeleteHook:
		sapPurchasingInfoRecordOrganizationPlantDatumAfterDeleteHooks = append(sapPurchasingInfoRecordOrganizationPlantDatumAfterDeleteHooks, sapPurchasingInfoRecordOrganizationPlantDatumHook)
	case boil.BeforeUpsertHook:
		sapPurchasingInfoRecordOrganizationPlantDatumBeforeUpsertHooks = append(sapPurchasingInfoRecordOrganizationPlantDatumBeforeUpsertHooks, sapPurchasingInfoRecordOrganizationPlantDatumHook)
	case boil.AfterUpsertHook:
		sapPurchasingInfoRecordOrganizationPlantDatumAfterUpsertHooks = append(sapPurchasingInfoRecordOrganizationPlantDatumAfterUpsertHooks, sapPurchasingInfoRecordOrganizationPlantDatumHook)
	}
}

// One returns a single sapPurchasingInfoRecordOrganizationPlantDatum record from the query.
func (q sapPurchasingInfoRecordOrganizationPlantDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapPurchasingInfoRecordOrganizationPlantDatum, error) {
	o := &SapPurchasingInfoRecordOrganizationPlantDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_purchasing_info_record_organization_plant_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapPurchasingInfoRecordOrganizationPlantDatum records from the query.
func (q sapPurchasingInfoRecordOrganizationPlantDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapPurchasingInfoRecordOrganizationPlantDatumSlice, error) {
	var o []*SapPurchasingInfoRecordOrganizationPlantDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapPurchasingInfoRecordOrganizationPlantDatum slice")
	}

	if len(sapPurchasingInfoRecordOrganizationPlantDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapPurchasingInfoRecordOrganizationPlantDatum records in the query.
func (q sapPurchasingInfoRecordOrganizationPlantDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_purchasing_info_record_organization_plant_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapPurchasingInfoRecordOrganizationPlantDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_purchasing_info_record_organization_plant_data exists")
	}

	return count > 0, nil
}

// PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum pointed to by the foreign key.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum(mods ...qm.QueryMod) sapPurchasingInfoRecordGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`PurchasingInfoRecord` = ?", o.PurchasingInfoRecord),
	}

	queryMods = append(queryMods, mods...)

	query := SapPurchasingInfoRecordGeneralData(queryMods...)
	queries.SetFrom(query.Query, "`sap_purchasing_info_record_general_data`")

	return query
}

// LoadPurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (sapPurchasingInfoRecordOrganizationPlantDatumL) LoadPurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapPurchasingInfoRecordOrganizationPlantDatum interface{}, mods queries.Applicator) error {
	var slice []*SapPurchasingInfoRecordOrganizationPlantDatum
	var object *SapPurchasingInfoRecordOrganizationPlantDatum

	if singular {
		object = maybeSapPurchasingInfoRecordOrganizationPlantDatum.(*SapPurchasingInfoRecordOrganizationPlantDatum)
	} else {
		slice = *maybeSapPurchasingInfoRecordOrganizationPlantDatum.(*[]*SapPurchasingInfoRecordOrganizationPlantDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapPurchasingInfoRecordOrganizationPlantDatumR{}
		}
		args = append(args, object.PurchasingInfoRecord)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapPurchasingInfoRecordOrganizationPlantDatumR{}
			}

			for _, a := range args {
				if a == obj.PurchasingInfoRecord {
					continue Outer
				}
			}

			args = append(args, obj.PurchasingInfoRecord)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_purchasing_info_record_general_data`),
		qm.WhereIn(`sap_purchasing_info_record_general_data.PurchasingInfoRecord in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SapPurchasingInfoRecordGeneralDatum")
	}

	var resultSlice []*SapPurchasingInfoRecordGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SapPurchasingInfoRecordGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for sap_purchasing_info_record_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_purchasing_info_record_general_data")
	}

	if len(sapPurchasingInfoRecordOrganizationPlantDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &sapPurchasingInfoRecordGeneralDatumR{}
		}
		foreign.R.PurchasingInfoRecordSapPurchasingInfoRecordOrganizationPlantData = append(foreign.R.PurchasingInfoRecordSapPurchasingInfoRecordOrganizationPlantData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PurchasingInfoRecord == foreign.PurchasingInfoRecord {
				local.R.PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &sapPurchasingInfoRecordGeneralDatumR{}
				}
				foreign.R.PurchasingInfoRecordSapPurchasingInfoRecordOrganizationPlantData = append(foreign.R.PurchasingInfoRecordSapPurchasingInfoRecordOrganizationPlantData, local)
				break
			}
		}
	}

	return nil
}

// SetPurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum of the sapPurchasingInfoRecordOrganizationPlantDatum to the related item.
// Sets o.R.PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum to related.
// Adds o to related.R.PurchasingInfoRecordSapPurchasingInfoRecordOrganizationPlantData.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) SetPurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SapPurchasingInfoRecordGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `sap_purchasing_info_record_organization_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"PurchasingInfoRecord"}),
		strmangle.WhereClause("`", "`", 0, sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.PurchasingInfoRecord, o.PurchasingInfoRecord, o.PurchasingInfoRecordCategory, o.PurchasingOrganization, o.Plant}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PurchasingInfoRecord = related.PurchasingInfoRecord
	if o.R == nil {
		o.R = &sapPurchasingInfoRecordOrganizationPlantDatumR{
			PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum: related,
		}
	} else {
		o.R.PurchasingInfoRecordSapPurchasingInfoRecordGeneralDatum = related
	}

	if related.R == nil {
		related.R = &sapPurchasingInfoRecordGeneralDatumR{
			PurchasingInfoRecordSapPurchasingInfoRecordOrganizationPlantData: SapPurchasingInfoRecordOrganizationPlantDatumSlice{o},
		}
	} else {
		related.R.PurchasingInfoRecordSapPurchasingInfoRecordOrganizationPlantData = append(related.R.PurchasingInfoRecordSapPurchasingInfoRecordOrganizationPlantData, o)
	}

	return nil
}

// SapPurchasingInfoRecordOrganizationPlantData retrieves all the records using an executor.
func SapPurchasingInfoRecordOrganizationPlantData(mods ...qm.QueryMod) sapPurchasingInfoRecordOrganizationPlantDatumQuery {
	mods = append(mods, qm.From("`sap_purchasing_info_record_organization_plant_data`"))
	return sapPurchasingInfoRecordOrganizationPlantDatumQuery{NewQuery(mods...)}
}

// FindSapPurchasingInfoRecordOrganizationPlantDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapPurchasingInfoRecordOrganizationPlantDatum(ctx context.Context, exec boil.ContextExecutor, purchasingInfoRecord string, purchasingInfoRecordCategory string, purchasingOrganization string, plant string, selectCols ...string) (*SapPurchasingInfoRecordOrganizationPlantDatum, error) {
	sapPurchasingInfoRecordOrganizationPlantDatumObj := &SapPurchasingInfoRecordOrganizationPlantDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_purchasing_info_record_organization_plant_data` where `PurchasingInfoRecord`=? AND `PurchasingInfoRecordCategory`=? AND `PurchasingOrganization`=? AND `Plant`=?", sel,
	)

	q := queries.Raw(query, purchasingInfoRecord, purchasingInfoRecordCategory, purchasingOrganization, plant)

	err := q.Bind(ctx, exec, sapPurchasingInfoRecordOrganizationPlantDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_purchasing_info_record_organization_plant_data")
	}

	if err = sapPurchasingInfoRecordOrganizationPlantDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapPurchasingInfoRecordOrganizationPlantDatumObj, err
	}

	return sapPurchasingInfoRecordOrganizationPlantDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_purchasing_info_record_organization_plant_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapPurchasingInfoRecordOrganizationPlantDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapPurchasingInfoRecordOrganizationPlantDatumInsertCacheMut.RLock()
	cache, cached := sapPurchasingInfoRecordOrganizationPlantDatumInsertCache[key]
	sapPurchasingInfoRecordOrganizationPlantDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapPurchasingInfoRecordOrganizationPlantDatumAllColumns,
			sapPurchasingInfoRecordOrganizationPlantDatumColumnsWithDefault,
			sapPurchasingInfoRecordOrganizationPlantDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapPurchasingInfoRecordOrganizationPlantDatumType, sapPurchasingInfoRecordOrganizationPlantDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapPurchasingInfoRecordOrganizationPlantDatumType, sapPurchasingInfoRecordOrganizationPlantDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_purchasing_info_record_organization_plant_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_purchasing_info_record_organization_plant_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_purchasing_info_record_organization_plant_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_purchasing_info_record_organization_plant_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PurchasingInfoRecord,
		o.PurchasingInfoRecordCategory,
		o.PurchasingOrganization,
		o.Plant,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_purchasing_info_record_organization_plant_data")
	}

CacheNoHooks:
	if !cached {
		sapPurchasingInfoRecordOrganizationPlantDatumInsertCacheMut.Lock()
		sapPurchasingInfoRecordOrganizationPlantDatumInsertCache[key] = cache
		sapPurchasingInfoRecordOrganizationPlantDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapPurchasingInfoRecordOrganizationPlantDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapPurchasingInfoRecordOrganizationPlantDatumUpdateCacheMut.RLock()
	cache, cached := sapPurchasingInfoRecordOrganizationPlantDatumUpdateCache[key]
	sapPurchasingInfoRecordOrganizationPlantDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapPurchasingInfoRecordOrganizationPlantDatumAllColumns,
			sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_purchasing_info_record_organization_plant_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_purchasing_info_record_organization_plant_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapPurchasingInfoRecordOrganizationPlantDatumType, sapPurchasingInfoRecordOrganizationPlantDatumMapping, append(wl, sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_purchasing_info_record_organization_plant_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_purchasing_info_record_organization_plant_data")
	}

	if !cached {
		sapPurchasingInfoRecordOrganizationPlantDatumUpdateCacheMut.Lock()
		sapPurchasingInfoRecordOrganizationPlantDatumUpdateCache[key] = cache
		sapPurchasingInfoRecordOrganizationPlantDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapPurchasingInfoRecordOrganizationPlantDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_purchasing_info_record_organization_plant_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_purchasing_info_record_organization_plant_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapPurchasingInfoRecordOrganizationPlantDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_purchasing_info_record_organization_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapPurchasingInfoRecordOrganizationPlantDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapPurchasingInfoRecordOrganizationPlantDatum")
	}
	return rowsAff, nil
}

var mySQLSapPurchasingInfoRecordOrganizationPlantDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_purchasing_info_record_organization_plant_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapPurchasingInfoRecordOrganizationPlantDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapPurchasingInfoRecordOrganizationPlantDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapPurchasingInfoRecordOrganizationPlantDatumUpsertCacheMut.RLock()
	cache, cached := sapPurchasingInfoRecordOrganizationPlantDatumUpsertCache[key]
	sapPurchasingInfoRecordOrganizationPlantDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapPurchasingInfoRecordOrganizationPlantDatumAllColumns,
			sapPurchasingInfoRecordOrganizationPlantDatumColumnsWithDefault,
			sapPurchasingInfoRecordOrganizationPlantDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapPurchasingInfoRecordOrganizationPlantDatumAllColumns,
			sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_purchasing_info_record_organization_plant_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_purchasing_info_record_organization_plant_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_purchasing_info_record_organization_plant_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapPurchasingInfoRecordOrganizationPlantDatumType, sapPurchasingInfoRecordOrganizationPlantDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapPurchasingInfoRecordOrganizationPlantDatumType, sapPurchasingInfoRecordOrganizationPlantDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_purchasing_info_record_organization_plant_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapPurchasingInfoRecordOrganizationPlantDatumType, sapPurchasingInfoRecordOrganizationPlantDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_purchasing_info_record_organization_plant_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_purchasing_info_record_organization_plant_data")
	}

CacheNoHooks:
	if !cached {
		sapPurchasingInfoRecordOrganizationPlantDatumUpsertCacheMut.Lock()
		sapPurchasingInfoRecordOrganizationPlantDatumUpsertCache[key] = cache
		sapPurchasingInfoRecordOrganizationPlantDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapPurchasingInfoRecordOrganizationPlantDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapPurchasingInfoRecordOrganizationPlantDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_purchasing_info_record_organization_plant_data` WHERE `PurchasingInfoRecord`=? AND `PurchasingInfoRecordCategory`=? AND `PurchasingOrganization`=? AND `Plant`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_purchasing_info_record_organization_plant_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_purchasing_info_record_organization_plant_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapPurchasingInfoRecordOrganizationPlantDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapPurchasingInfoRecordOrganizationPlantDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_purchasing_info_record_organization_plant_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_purchasing_info_record_organization_plant_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapPurchasingInfoRecordOrganizationPlantDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapPurchasingInfoRecordOrganizationPlantDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_purchasing_info_record_organization_plant_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapPurchasingInfoRecordOrganizationPlantDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_purchasing_info_record_organization_plant_data")
	}

	if len(sapPurchasingInfoRecordOrganizationPlantDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapPurchasingInfoRecordOrganizationPlantDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapPurchasingInfoRecordOrganizationPlantDatum(ctx, exec, o.PurchasingInfoRecord, o.PurchasingInfoRecordCategory, o.PurchasingOrganization, o.Plant)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapPurchasingInfoRecordOrganizationPlantDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapPurchasingInfoRecordOrganizationPlantDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_purchasing_info_record_organization_plant_data`.* FROM `sap_purchasing_info_record_organization_plant_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapPurchasingInfoRecordOrganizationPlantDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapPurchasingInfoRecordOrganizationPlantDatumSlice")
	}

	*o = slice

	return nil
}

// SapPurchasingInfoRecordOrganizationPlantDatumExists checks if the SapPurchasingInfoRecordOrganizationPlantDatum row exists.
func SapPurchasingInfoRecordOrganizationPlantDatumExists(ctx context.Context, exec boil.ContextExecutor, purchasingInfoRecord string, purchasingInfoRecordCategory string, purchasingOrganization string, plant string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_purchasing_info_record_organization_plant_data` where `PurchasingInfoRecord`=? AND `PurchasingInfoRecordCategory`=? AND `PurchasingOrganization`=? AND `Plant`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, purchasingInfoRecord, purchasingInfoRecordCategory, purchasingOrganization, plant)
	}
	row := exec.QueryRowContext(ctx, sql, purchasingInfoRecord, purchasingInfoRecordCategory, purchasingOrganization, plant)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_purchasing_info_record_organization_plant_data exists")
	}

	return exists, nil
}
