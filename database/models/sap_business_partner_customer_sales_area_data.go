// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapBusinessPartnerCustomerSalesAreaDatum is an object representing the database table.
type SapBusinessPartnerCustomerSalesAreaDatum struct {
	Customer                       string      `boil:"Customer" json:"Customer" toml:"Customer" yaml:"Customer"`
	SalesOrganization              string      `boil:"SalesOrganization" json:"SalesOrganization" toml:"SalesOrganization" yaml:"SalesOrganization"`
	DistributionChannel            string      `boil:"DistributionChannel" json:"DistributionChannel" toml:"DistributionChannel" yaml:"DistributionChannel"`
	Division                       string      `boil:"Division" json:"Division" toml:"Division" yaml:"Division"`
	CompleteDeliveryIsDefined      null.Bool   `boil:"CompleteDeliveryIsDefined" json:"CompleteDeliveryIsDefined,omitempty" toml:"CompleteDeliveryIsDefined" yaml:"CompleteDeliveryIsDefined,omitempty"`
	Currency                       null.String `boil:"Currency" json:"Currency,omitempty" toml:"Currency" yaml:"Currency,omitempty"`
	CustomerAccountAssignmentGroup null.String `boil:"CustomerAccountAssignmentGroup" json:"CustomerAccountAssignmentGroup,omitempty" toml:"CustomerAccountAssignmentGroup" yaml:"CustomerAccountAssignmentGroup,omitempty"`
	CustomerPaymentTerms           null.String `boil:"CustomerPaymentTerms" json:"CustomerPaymentTerms,omitempty" toml:"CustomerPaymentTerms" yaml:"CustomerPaymentTerms,omitempty"`
	CustomerPriceGroup             null.String `boil:"CustomerPriceGroup" json:"CustomerPriceGroup,omitempty" toml:"CustomerPriceGroup" yaml:"CustomerPriceGroup,omitempty"`
	CustomerPricingProcedure       null.String `boil:"CustomerPricingProcedure" json:"CustomerPricingProcedure,omitempty" toml:"CustomerPricingProcedure" yaml:"CustomerPricingProcedure,omitempty"`
	DeliveryPriority               null.String `boil:"DeliveryPriority" json:"DeliveryPriority,omitempty" toml:"DeliveryPriority" yaml:"DeliveryPriority,omitempty"`
	IncotermsClassification        null.String `boil:"IncotermsClassification" json:"IncotermsClassification,omitempty" toml:"IncotermsClassification" yaml:"IncotermsClassification,omitempty"`
	InvoiceDate                    null.String `boil:"InvoiceDate" json:"InvoiceDate,omitempty" toml:"InvoiceDate" yaml:"InvoiceDate,omitempty"`
	OrderCombinationIsAllowed      null.Bool   `boil:"OrderCombinationIsAllowed" json:"OrderCombinationIsAllowed,omitempty" toml:"OrderCombinationIsAllowed" yaml:"OrderCombinationIsAllowed,omitempty"`
	PartialDeliveryIsAllowed       null.Bool   `boil:"PartialDeliveryIsAllowed" json:"PartialDeliveryIsAllowed,omitempty" toml:"PartialDeliveryIsAllowed" yaml:"PartialDeliveryIsAllowed,omitempty"`
	PriceListType                  null.String `boil:"PriceListType" json:"PriceListType,omitempty" toml:"PriceListType" yaml:"PriceListType,omitempty"`
	SalesGroup                     null.String `boil:"SalesGroup" json:"SalesGroup,omitempty" toml:"SalesGroup" yaml:"SalesGroup,omitempty"`
	SalesOffice                    null.String `boil:"SalesOffice" json:"SalesOffice,omitempty" toml:"SalesOffice" yaml:"SalesOffice,omitempty"`
	ShippingCondition              null.String `boil:"ShippingCondition" json:"ShippingCondition,omitempty" toml:"ShippingCondition" yaml:"ShippingCondition,omitempty"`
	SupplyingPlant                 null.String `boil:"SupplyingPlant" json:"SupplyingPlant,omitempty" toml:"SupplyingPlant" yaml:"SupplyingPlant,omitempty"`
	SalesDistrict                  null.String `boil:"SalesDistrict" json:"SalesDistrict,omitempty" toml:"SalesDistrict" yaml:"SalesDistrict,omitempty"`
	InvoiceListSchedule            null.String `boil:"InvoiceListSchedule" json:"InvoiceListSchedule,omitempty" toml:"InvoiceListSchedule" yaml:"InvoiceListSchedule,omitempty"`
	ExchangeRateType               null.String `boil:"ExchangeRateType" json:"ExchangeRateType,omitempty" toml:"ExchangeRateType" yaml:"ExchangeRateType,omitempty"`
	OrderIsBlockedForCustomer      null.String `boil:"OrderIsBlockedForCustomer" json:"OrderIsBlockedForCustomer,omitempty" toml:"OrderIsBlockedForCustomer" yaml:"OrderIsBlockedForCustomer,omitempty"`
	DeliveryIsBlockedForCustomer   null.String `boil:"DeliveryIsBlockedForCustomer" json:"DeliveryIsBlockedForCustomer,omitempty" toml:"DeliveryIsBlockedForCustomer" yaml:"DeliveryIsBlockedForCustomer,omitempty"`
	BillingIsBlockedForCustomer    null.String `boil:"BillingIsBlockedForCustomer" json:"BillingIsBlockedForCustomer,omitempty" toml:"BillingIsBlockedForCustomer" yaml:"BillingIsBlockedForCustomer,omitempty"`
	DeletionIndicator              null.Bool   `boil:"DeletionIndicator" json:"DeletionIndicator,omitempty" toml:"DeletionIndicator" yaml:"DeletionIndicator,omitempty"`

	R *sapBusinessPartnerCustomerSalesAreaDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapBusinessPartnerCustomerSalesAreaDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapBusinessPartnerCustomerSalesAreaDatumColumns = struct {
	Customer                       string
	SalesOrganization              string
	DistributionChannel            string
	Division                       string
	CompleteDeliveryIsDefined      string
	Currency                       string
	CustomerAccountAssignmentGroup string
	CustomerPaymentTerms           string
	CustomerPriceGroup             string
	CustomerPricingProcedure       string
	DeliveryPriority               string
	IncotermsClassification        string
	InvoiceDate                    string
	OrderCombinationIsAllowed      string
	PartialDeliveryIsAllowed       string
	PriceListType                  string
	SalesGroup                     string
	SalesOffice                    string
	ShippingCondition              string
	SupplyingPlant                 string
	SalesDistrict                  string
	InvoiceListSchedule            string
	ExchangeRateType               string
	OrderIsBlockedForCustomer      string
	DeliveryIsBlockedForCustomer   string
	BillingIsBlockedForCustomer    string
	DeletionIndicator              string
}{
	Customer:                       "Customer",
	SalesOrganization:              "SalesOrganization",
	DistributionChannel:            "DistributionChannel",
	Division:                       "Division",
	CompleteDeliveryIsDefined:      "CompleteDeliveryIsDefined",
	Currency:                       "Currency",
	CustomerAccountAssignmentGroup: "CustomerAccountAssignmentGroup",
	CustomerPaymentTerms:           "CustomerPaymentTerms",
	CustomerPriceGroup:             "CustomerPriceGroup",
	CustomerPricingProcedure:       "CustomerPricingProcedure",
	DeliveryPriority:               "DeliveryPriority",
	IncotermsClassification:        "IncotermsClassification",
	InvoiceDate:                    "InvoiceDate",
	OrderCombinationIsAllowed:      "OrderCombinationIsAllowed",
	PartialDeliveryIsAllowed:       "PartialDeliveryIsAllowed",
	PriceListType:                  "PriceListType",
	SalesGroup:                     "SalesGroup",
	SalesOffice:                    "SalesOffice",
	ShippingCondition:              "ShippingCondition",
	SupplyingPlant:                 "SupplyingPlant",
	SalesDistrict:                  "SalesDistrict",
	InvoiceListSchedule:            "InvoiceListSchedule",
	ExchangeRateType:               "ExchangeRateType",
	OrderIsBlockedForCustomer:      "OrderIsBlockedForCustomer",
	DeliveryIsBlockedForCustomer:   "DeliveryIsBlockedForCustomer",
	BillingIsBlockedForCustomer:    "BillingIsBlockedForCustomer",
	DeletionIndicator:              "DeletionIndicator",
}

var SapBusinessPartnerCustomerSalesAreaDatumTableColumns = struct {
	Customer                       string
	SalesOrganization              string
	DistributionChannel            string
	Division                       string
	CompleteDeliveryIsDefined      string
	Currency                       string
	CustomerAccountAssignmentGroup string
	CustomerPaymentTerms           string
	CustomerPriceGroup             string
	CustomerPricingProcedure       string
	DeliveryPriority               string
	IncotermsClassification        string
	InvoiceDate                    string
	OrderCombinationIsAllowed      string
	PartialDeliveryIsAllowed       string
	PriceListType                  string
	SalesGroup                     string
	SalesOffice                    string
	ShippingCondition              string
	SupplyingPlant                 string
	SalesDistrict                  string
	InvoiceListSchedule            string
	ExchangeRateType               string
	OrderIsBlockedForCustomer      string
	DeliveryIsBlockedForCustomer   string
	BillingIsBlockedForCustomer    string
	DeletionIndicator              string
}{
	Customer:                       "sap_business_partner_customer_sales_area_data.Customer",
	SalesOrganization:              "sap_business_partner_customer_sales_area_data.SalesOrganization",
	DistributionChannel:            "sap_business_partner_customer_sales_area_data.DistributionChannel",
	Division:                       "sap_business_partner_customer_sales_area_data.Division",
	CompleteDeliveryIsDefined:      "sap_business_partner_customer_sales_area_data.CompleteDeliveryIsDefined",
	Currency:                       "sap_business_partner_customer_sales_area_data.Currency",
	CustomerAccountAssignmentGroup: "sap_business_partner_customer_sales_area_data.CustomerAccountAssignmentGroup",
	CustomerPaymentTerms:           "sap_business_partner_customer_sales_area_data.CustomerPaymentTerms",
	CustomerPriceGroup:             "sap_business_partner_customer_sales_area_data.CustomerPriceGroup",
	CustomerPricingProcedure:       "sap_business_partner_customer_sales_area_data.CustomerPricingProcedure",
	DeliveryPriority:               "sap_business_partner_customer_sales_area_data.DeliveryPriority",
	IncotermsClassification:        "sap_business_partner_customer_sales_area_data.IncotermsClassification",
	InvoiceDate:                    "sap_business_partner_customer_sales_area_data.InvoiceDate",
	OrderCombinationIsAllowed:      "sap_business_partner_customer_sales_area_data.OrderCombinationIsAllowed",
	PartialDeliveryIsAllowed:       "sap_business_partner_customer_sales_area_data.PartialDeliveryIsAllowed",
	PriceListType:                  "sap_business_partner_customer_sales_area_data.PriceListType",
	SalesGroup:                     "sap_business_partner_customer_sales_area_data.SalesGroup",
	SalesOffice:                    "sap_business_partner_customer_sales_area_data.SalesOffice",
	ShippingCondition:              "sap_business_partner_customer_sales_area_data.ShippingCondition",
	SupplyingPlant:                 "sap_business_partner_customer_sales_area_data.SupplyingPlant",
	SalesDistrict:                  "sap_business_partner_customer_sales_area_data.SalesDistrict",
	InvoiceListSchedule:            "sap_business_partner_customer_sales_area_data.InvoiceListSchedule",
	ExchangeRateType:               "sap_business_partner_customer_sales_area_data.ExchangeRateType",
	OrderIsBlockedForCustomer:      "sap_business_partner_customer_sales_area_data.OrderIsBlockedForCustomer",
	DeliveryIsBlockedForCustomer:   "sap_business_partner_customer_sales_area_data.DeliveryIsBlockedForCustomer",
	BillingIsBlockedForCustomer:    "sap_business_partner_customer_sales_area_data.BillingIsBlockedForCustomer",
	DeletionIndicator:              "sap_business_partner_customer_sales_area_data.DeletionIndicator",
}

// Generated where

var SapBusinessPartnerCustomerSalesAreaDatumWhere = struct {
	Customer                       whereHelperstring
	SalesOrganization              whereHelperstring
	DistributionChannel            whereHelperstring
	Division                       whereHelperstring
	CompleteDeliveryIsDefined      whereHelpernull_Bool
	Currency                       whereHelpernull_String
	CustomerAccountAssignmentGroup whereHelpernull_String
	CustomerPaymentTerms           whereHelpernull_String
	CustomerPriceGroup             whereHelpernull_String
	CustomerPricingProcedure       whereHelpernull_String
	DeliveryPriority               whereHelpernull_String
	IncotermsClassification        whereHelpernull_String
	InvoiceDate                    whereHelpernull_String
	OrderCombinationIsAllowed      whereHelpernull_Bool
	PartialDeliveryIsAllowed       whereHelpernull_Bool
	PriceListType                  whereHelpernull_String
	SalesGroup                     whereHelpernull_String
	SalesOffice                    whereHelpernull_String
	ShippingCondition              whereHelpernull_String
	SupplyingPlant                 whereHelpernull_String
	SalesDistrict                  whereHelpernull_String
	InvoiceListSchedule            whereHelpernull_String
	ExchangeRateType               whereHelpernull_String
	OrderIsBlockedForCustomer      whereHelpernull_String
	DeliveryIsBlockedForCustomer   whereHelpernull_String
	BillingIsBlockedForCustomer    whereHelpernull_String
	DeletionIndicator              whereHelpernull_Bool
}{
	Customer:                       whereHelperstring{field: "`sap_business_partner_customer_sales_area_data`.`Customer`"},
	SalesOrganization:              whereHelperstring{field: "`sap_business_partner_customer_sales_area_data`.`SalesOrganization`"},
	DistributionChannel:            whereHelperstring{field: "`sap_business_partner_customer_sales_area_data`.`DistributionChannel`"},
	Division:                       whereHelperstring{field: "`sap_business_partner_customer_sales_area_data`.`Division`"},
	CompleteDeliveryIsDefined:      whereHelpernull_Bool{field: "`sap_business_partner_customer_sales_area_data`.`CompleteDeliveryIsDefined`"},
	Currency:                       whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`Currency`"},
	CustomerAccountAssignmentGroup: whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`CustomerAccountAssignmentGroup`"},
	CustomerPaymentTerms:           whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`CustomerPaymentTerms`"},
	CustomerPriceGroup:             whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`CustomerPriceGroup`"},
	CustomerPricingProcedure:       whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`CustomerPricingProcedure`"},
	DeliveryPriority:               whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`DeliveryPriority`"},
	IncotermsClassification:        whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`IncotermsClassification`"},
	InvoiceDate:                    whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`InvoiceDate`"},
	OrderCombinationIsAllowed:      whereHelpernull_Bool{field: "`sap_business_partner_customer_sales_area_data`.`OrderCombinationIsAllowed`"},
	PartialDeliveryIsAllowed:       whereHelpernull_Bool{field: "`sap_business_partner_customer_sales_area_data`.`PartialDeliveryIsAllowed`"},
	PriceListType:                  whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`PriceListType`"},
	SalesGroup:                     whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`SalesGroup`"},
	SalesOffice:                    whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`SalesOffice`"},
	ShippingCondition:              whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`ShippingCondition`"},
	SupplyingPlant:                 whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`SupplyingPlant`"},
	SalesDistrict:                  whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`SalesDistrict`"},
	InvoiceListSchedule:            whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`InvoiceListSchedule`"},
	ExchangeRateType:               whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`ExchangeRateType`"},
	OrderIsBlockedForCustomer:      whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`OrderIsBlockedForCustomer`"},
	DeliveryIsBlockedForCustomer:   whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`DeliveryIsBlockedForCustomer`"},
	BillingIsBlockedForCustomer:    whereHelpernull_String{field: "`sap_business_partner_customer_sales_area_data`.`BillingIsBlockedForCustomer`"},
	DeletionIndicator:              whereHelpernull_Bool{field: "`sap_business_partner_customer_sales_area_data`.`DeletionIndicator`"},
}

// SapBusinessPartnerCustomerSalesAreaDatumRels is where relationship names are stored.
var SapBusinessPartnerCustomerSalesAreaDatumRels = struct {
	CustomerSapBusinessPartnerGeneralDatum string
}{
	CustomerSapBusinessPartnerGeneralDatum: "CustomerSapBusinessPartnerGeneralDatum",
}

// sapBusinessPartnerCustomerSalesAreaDatumR is where relationships are stored.
type sapBusinessPartnerCustomerSalesAreaDatumR struct {
	CustomerSapBusinessPartnerGeneralDatum *SapBusinessPartnerGeneralDatum `boil:"CustomerSapBusinessPartnerGeneralDatum" json:"CustomerSapBusinessPartnerGeneralDatum" toml:"CustomerSapBusinessPartnerGeneralDatum" yaml:"CustomerSapBusinessPartnerGeneralDatum"`
}

// NewStruct creates a new relationship struct
func (*sapBusinessPartnerCustomerSalesAreaDatumR) NewStruct() *sapBusinessPartnerCustomerSalesAreaDatumR {
	return &sapBusinessPartnerCustomerSalesAreaDatumR{}
}

// sapBusinessPartnerCustomerSalesAreaDatumL is where Load methods for each relationship are stored.
type sapBusinessPartnerCustomerSalesAreaDatumL struct{}

var (
	sapBusinessPartnerCustomerSalesAreaDatumAllColumns            = []string{"Customer", "SalesOrganization", "DistributionChannel", "Division", "CompleteDeliveryIsDefined", "Currency", "CustomerAccountAssignmentGroup", "CustomerPaymentTerms", "CustomerPriceGroup", "CustomerPricingProcedure", "DeliveryPriority", "IncotermsClassification", "InvoiceDate", "OrderCombinationIsAllowed", "PartialDeliveryIsAllowed", "PriceListType", "SalesGroup", "SalesOffice", "ShippingCondition", "SupplyingPlant", "SalesDistrict", "InvoiceListSchedule", "ExchangeRateType", "OrderIsBlockedForCustomer", "DeliveryIsBlockedForCustomer", "BillingIsBlockedForCustomer", "DeletionIndicator"}
	sapBusinessPartnerCustomerSalesAreaDatumColumnsWithoutDefault = []string{"Customer", "SalesOrganization", "DistributionChannel", "Division", "CompleteDeliveryIsDefined", "Currency", "CustomerAccountAssignmentGroup", "CustomerPaymentTerms", "CustomerPriceGroup", "CustomerPricingProcedure", "DeliveryPriority", "IncotermsClassification", "InvoiceDate", "OrderCombinationIsAllowed", "PartialDeliveryIsAllowed", "PriceListType", "SalesGroup", "SalesOffice", "ShippingCondition", "SupplyingPlant", "SalesDistrict", "InvoiceListSchedule", "ExchangeRateType", "OrderIsBlockedForCustomer", "DeliveryIsBlockedForCustomer", "BillingIsBlockedForCustomer", "DeletionIndicator"}
	sapBusinessPartnerCustomerSalesAreaDatumColumnsWithDefault    = []string{}
	sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns     = []string{"Customer", "SalesOrganization", "DistributionChannel", "Division"}
	sapBusinessPartnerCustomerSalesAreaDatumGeneratedColumns      = []string{}
)

type (
	// SapBusinessPartnerCustomerSalesAreaDatumSlice is an alias for a slice of pointers to SapBusinessPartnerCustomerSalesAreaDatum.
	// This should almost always be used instead of []SapBusinessPartnerCustomerSalesAreaDatum.
	SapBusinessPartnerCustomerSalesAreaDatumSlice []*SapBusinessPartnerCustomerSalesAreaDatum
	// SapBusinessPartnerCustomerSalesAreaDatumHook is the signature for custom SapBusinessPartnerCustomerSalesAreaDatum hook methods
	SapBusinessPartnerCustomerSalesAreaDatumHook func(context.Context, boil.ContextExecutor, *SapBusinessPartnerCustomerSalesAreaDatum) error

	sapBusinessPartnerCustomerSalesAreaDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapBusinessPartnerCustomerSalesAreaDatumType                 = reflect.TypeOf(&SapBusinessPartnerCustomerSalesAreaDatum{})
	sapBusinessPartnerCustomerSalesAreaDatumMapping              = queries.MakeStructMapping(sapBusinessPartnerCustomerSalesAreaDatumType)
	sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyMapping, _ = queries.BindMapping(sapBusinessPartnerCustomerSalesAreaDatumType, sapBusinessPartnerCustomerSalesAreaDatumMapping, sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns)
	sapBusinessPartnerCustomerSalesAreaDatumInsertCacheMut       sync.RWMutex
	sapBusinessPartnerCustomerSalesAreaDatumInsertCache          = make(map[string]insertCache)
	sapBusinessPartnerCustomerSalesAreaDatumUpdateCacheMut       sync.RWMutex
	sapBusinessPartnerCustomerSalesAreaDatumUpdateCache          = make(map[string]updateCache)
	sapBusinessPartnerCustomerSalesAreaDatumUpsertCacheMut       sync.RWMutex
	sapBusinessPartnerCustomerSalesAreaDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapBusinessPartnerCustomerSalesAreaDatumAfterSelectHooks []SapBusinessPartnerCustomerSalesAreaDatumHook

var sapBusinessPartnerCustomerSalesAreaDatumBeforeInsertHooks []SapBusinessPartnerCustomerSalesAreaDatumHook
var sapBusinessPartnerCustomerSalesAreaDatumAfterInsertHooks []SapBusinessPartnerCustomerSalesAreaDatumHook

var sapBusinessPartnerCustomerSalesAreaDatumBeforeUpdateHooks []SapBusinessPartnerCustomerSalesAreaDatumHook
var sapBusinessPartnerCustomerSalesAreaDatumAfterUpdateHooks []SapBusinessPartnerCustomerSalesAreaDatumHook

var sapBusinessPartnerCustomerSalesAreaDatumBeforeDeleteHooks []SapBusinessPartnerCustomerSalesAreaDatumHook
var sapBusinessPartnerCustomerSalesAreaDatumAfterDeleteHooks []SapBusinessPartnerCustomerSalesAreaDatumHook

var sapBusinessPartnerCustomerSalesAreaDatumBeforeUpsertHooks []SapBusinessPartnerCustomerSalesAreaDatumHook
var sapBusinessPartnerCustomerSalesAreaDatumAfterUpsertHooks []SapBusinessPartnerCustomerSalesAreaDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBusinessPartnerCustomerSalesAreaDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBusinessPartnerCustomerSalesAreaDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBusinessPartnerCustomerSalesAreaDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBusinessPartnerCustomerSalesAreaDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBusinessPartnerCustomerSalesAreaDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBusinessPartnerCustomerSalesAreaDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBusinessPartnerCustomerSalesAreaDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBusinessPartnerCustomerSalesAreaDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapBusinessPartnerCustomerSalesAreaDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapBusinessPartnerCustomerSalesAreaDatumHook registers your hook function for all future operations.
func AddSapBusinessPartnerCustomerSalesAreaDatumHook(hookPoint boil.HookPoint, sapBusinessPartnerCustomerSalesAreaDatumHook SapBusinessPartnerCustomerSalesAreaDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapBusinessPartnerCustomerSalesAreaDatumAfterSelectHooks = append(sapBusinessPartnerCustomerSalesAreaDatumAfterSelectHooks, sapBusinessPartnerCustomerSalesAreaDatumHook)
	case boil.BeforeInsertHook:
		sapBusinessPartnerCustomerSalesAreaDatumBeforeInsertHooks = append(sapBusinessPartnerCustomerSalesAreaDatumBeforeInsertHooks, sapBusinessPartnerCustomerSalesAreaDatumHook)
	case boil.AfterInsertHook:
		sapBusinessPartnerCustomerSalesAreaDatumAfterInsertHooks = append(sapBusinessPartnerCustomerSalesAreaDatumAfterInsertHooks, sapBusinessPartnerCustomerSalesAreaDatumHook)
	case boil.BeforeUpdateHook:
		sapBusinessPartnerCustomerSalesAreaDatumBeforeUpdateHooks = append(sapBusinessPartnerCustomerSalesAreaDatumBeforeUpdateHooks, sapBusinessPartnerCustomerSalesAreaDatumHook)
	case boil.AfterUpdateHook:
		sapBusinessPartnerCustomerSalesAreaDatumAfterUpdateHooks = append(sapBusinessPartnerCustomerSalesAreaDatumAfterUpdateHooks, sapBusinessPartnerCustomerSalesAreaDatumHook)
	case boil.BeforeDeleteHook:
		sapBusinessPartnerCustomerSalesAreaDatumBeforeDeleteHooks = append(sapBusinessPartnerCustomerSalesAreaDatumBeforeDeleteHooks, sapBusinessPartnerCustomerSalesAreaDatumHook)
	case boil.AfterDeleteHook:
		sapBusinessPartnerCustomerSalesAreaDatumAfterDeleteHooks = append(sapBusinessPartnerCustomerSalesAreaDatumAfterDeleteHooks, sapBusinessPartnerCustomerSalesAreaDatumHook)
	case boil.BeforeUpsertHook:
		sapBusinessPartnerCustomerSalesAreaDatumBeforeUpsertHooks = append(sapBusinessPartnerCustomerSalesAreaDatumBeforeUpsertHooks, sapBusinessPartnerCustomerSalesAreaDatumHook)
	case boil.AfterUpsertHook:
		sapBusinessPartnerCustomerSalesAreaDatumAfterUpsertHooks = append(sapBusinessPartnerCustomerSalesAreaDatumAfterUpsertHooks, sapBusinessPartnerCustomerSalesAreaDatumHook)
	}
}

// One returns a single sapBusinessPartnerCustomerSalesAreaDatum record from the query.
func (q sapBusinessPartnerCustomerSalesAreaDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapBusinessPartnerCustomerSalesAreaDatum, error) {
	o := &SapBusinessPartnerCustomerSalesAreaDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_business_partner_customer_sales_area_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapBusinessPartnerCustomerSalesAreaDatum records from the query.
func (q sapBusinessPartnerCustomerSalesAreaDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapBusinessPartnerCustomerSalesAreaDatumSlice, error) {
	var o []*SapBusinessPartnerCustomerSalesAreaDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapBusinessPartnerCustomerSalesAreaDatum slice")
	}

	if len(sapBusinessPartnerCustomerSalesAreaDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapBusinessPartnerCustomerSalesAreaDatum records in the query.
func (q sapBusinessPartnerCustomerSalesAreaDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_business_partner_customer_sales_area_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapBusinessPartnerCustomerSalesAreaDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_business_partner_customer_sales_area_data exists")
	}

	return count > 0, nil
}

// CustomerSapBusinessPartnerGeneralDatum pointed to by the foreign key.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) CustomerSapBusinessPartnerGeneralDatum(mods ...qm.QueryMod) sapBusinessPartnerGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.Customer),
	}

	queryMods = append(queryMods, mods...)

	query := SapBusinessPartnerGeneralData(queryMods...)
	queries.SetFrom(query.Query, "`sap_business_partner_general_data`")

	return query
}

// LoadCustomerSapBusinessPartnerGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (sapBusinessPartnerCustomerSalesAreaDatumL) LoadCustomerSapBusinessPartnerGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSapBusinessPartnerCustomerSalesAreaDatum interface{}, mods queries.Applicator) error {
	var slice []*SapBusinessPartnerCustomerSalesAreaDatum
	var object *SapBusinessPartnerCustomerSalesAreaDatum

	if singular {
		object = maybeSapBusinessPartnerCustomerSalesAreaDatum.(*SapBusinessPartnerCustomerSalesAreaDatum)
	} else {
		slice = *maybeSapBusinessPartnerCustomerSalesAreaDatum.(*[]*SapBusinessPartnerCustomerSalesAreaDatum)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &sapBusinessPartnerCustomerSalesAreaDatumR{}
		}
		args = append(args, object.Customer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &sapBusinessPartnerCustomerSalesAreaDatumR{}
			}

			for _, a := range args {
				if a == obj.Customer {
					continue Outer
				}
			}

			args = append(args, obj.Customer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sap_business_partner_general_data`),
		qm.WhereIn(`sap_business_partner_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SapBusinessPartnerGeneralDatum")
	}

	var resultSlice []*SapBusinessPartnerGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SapBusinessPartnerGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for sap_business_partner_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sap_business_partner_general_data")
	}

	if len(sapBusinessPartnerCustomerSalesAreaDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CustomerSapBusinessPartnerGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &sapBusinessPartnerGeneralDatumR{}
		}
		foreign.R.CustomerSapBusinessPartnerCustomerSalesAreaData = append(foreign.R.CustomerSapBusinessPartnerCustomerSalesAreaData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Customer == foreign.BusinessPartner {
				local.R.CustomerSapBusinessPartnerGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &sapBusinessPartnerGeneralDatumR{}
				}
				foreign.R.CustomerSapBusinessPartnerCustomerSalesAreaData = append(foreign.R.CustomerSapBusinessPartnerCustomerSalesAreaData, local)
				break
			}
		}
	}

	return nil
}

// SetCustomerSapBusinessPartnerGeneralDatum of the sapBusinessPartnerCustomerSalesAreaDatum to the related item.
// Sets o.R.CustomerSapBusinessPartnerGeneralDatum to related.
// Adds o to related.R.CustomerSapBusinessPartnerCustomerSalesAreaData.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) SetCustomerSapBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SapBusinessPartnerGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `sap_business_partner_customer_sales_area_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Customer"}),
		strmangle.WhereClause("`", "`", 0, sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.Customer, o.SalesOrganization, o.DistributionChannel, o.Division}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Customer = related.BusinessPartner
	if o.R == nil {
		o.R = &sapBusinessPartnerCustomerSalesAreaDatumR{
			CustomerSapBusinessPartnerGeneralDatum: related,
		}
	} else {
		o.R.CustomerSapBusinessPartnerGeneralDatum = related
	}

	if related.R == nil {
		related.R = &sapBusinessPartnerGeneralDatumR{
			CustomerSapBusinessPartnerCustomerSalesAreaData: SapBusinessPartnerCustomerSalesAreaDatumSlice{o},
		}
	} else {
		related.R.CustomerSapBusinessPartnerCustomerSalesAreaData = append(related.R.CustomerSapBusinessPartnerCustomerSalesAreaData, o)
	}

	return nil
}

// SapBusinessPartnerCustomerSalesAreaData retrieves all the records using an executor.
func SapBusinessPartnerCustomerSalesAreaData(mods ...qm.QueryMod) sapBusinessPartnerCustomerSalesAreaDatumQuery {
	mods = append(mods, qm.From("`sap_business_partner_customer_sales_area_data`"))
	return sapBusinessPartnerCustomerSalesAreaDatumQuery{NewQuery(mods...)}
}

// FindSapBusinessPartnerCustomerSalesAreaDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapBusinessPartnerCustomerSalesAreaDatum(ctx context.Context, exec boil.ContextExecutor, customer string, salesOrganization string, distributionChannel string, division string, selectCols ...string) (*SapBusinessPartnerCustomerSalesAreaDatum, error) {
	sapBusinessPartnerCustomerSalesAreaDatumObj := &SapBusinessPartnerCustomerSalesAreaDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_business_partner_customer_sales_area_data` where `Customer`=? AND `SalesOrganization`=? AND `DistributionChannel`=? AND `Division`=?", sel,
	)

	q := queries.Raw(query, customer, salesOrganization, distributionChannel, division)

	err := q.Bind(ctx, exec, sapBusinessPartnerCustomerSalesAreaDatumObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_business_partner_customer_sales_area_data")
	}

	if err = sapBusinessPartnerCustomerSalesAreaDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapBusinessPartnerCustomerSalesAreaDatumObj, err
	}

	return sapBusinessPartnerCustomerSalesAreaDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_business_partner_customer_sales_area_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapBusinessPartnerCustomerSalesAreaDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapBusinessPartnerCustomerSalesAreaDatumInsertCacheMut.RLock()
	cache, cached := sapBusinessPartnerCustomerSalesAreaDatumInsertCache[key]
	sapBusinessPartnerCustomerSalesAreaDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapBusinessPartnerCustomerSalesAreaDatumAllColumns,
			sapBusinessPartnerCustomerSalesAreaDatumColumnsWithDefault,
			sapBusinessPartnerCustomerSalesAreaDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapBusinessPartnerCustomerSalesAreaDatumType, sapBusinessPartnerCustomerSalesAreaDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapBusinessPartnerCustomerSalesAreaDatumType, sapBusinessPartnerCustomerSalesAreaDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_business_partner_customer_sales_area_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_business_partner_customer_sales_area_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_business_partner_customer_sales_area_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_business_partner_customer_sales_area_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.Customer,
		o.SalesOrganization,
		o.DistributionChannel,
		o.Division,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_business_partner_customer_sales_area_data")
	}

CacheNoHooks:
	if !cached {
		sapBusinessPartnerCustomerSalesAreaDatumInsertCacheMut.Lock()
		sapBusinessPartnerCustomerSalesAreaDatumInsertCache[key] = cache
		sapBusinessPartnerCustomerSalesAreaDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapBusinessPartnerCustomerSalesAreaDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapBusinessPartnerCustomerSalesAreaDatumUpdateCacheMut.RLock()
	cache, cached := sapBusinessPartnerCustomerSalesAreaDatumUpdateCache[key]
	sapBusinessPartnerCustomerSalesAreaDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapBusinessPartnerCustomerSalesAreaDatumAllColumns,
			sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_business_partner_customer_sales_area_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_business_partner_customer_sales_area_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapBusinessPartnerCustomerSalesAreaDatumType, sapBusinessPartnerCustomerSalesAreaDatumMapping, append(wl, sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_business_partner_customer_sales_area_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_business_partner_customer_sales_area_data")
	}

	if !cached {
		sapBusinessPartnerCustomerSalesAreaDatumUpdateCacheMut.Lock()
		sapBusinessPartnerCustomerSalesAreaDatumUpdateCache[key] = cache
		sapBusinessPartnerCustomerSalesAreaDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapBusinessPartnerCustomerSalesAreaDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_business_partner_customer_sales_area_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_business_partner_customer_sales_area_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapBusinessPartnerCustomerSalesAreaDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_business_partner_customer_sales_area_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapBusinessPartnerCustomerSalesAreaDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapBusinessPartnerCustomerSalesAreaDatum")
	}
	return rowsAff, nil
}

var mySQLSapBusinessPartnerCustomerSalesAreaDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_business_partner_customer_sales_area_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapBusinessPartnerCustomerSalesAreaDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapBusinessPartnerCustomerSalesAreaDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapBusinessPartnerCustomerSalesAreaDatumUpsertCacheMut.RLock()
	cache, cached := sapBusinessPartnerCustomerSalesAreaDatumUpsertCache[key]
	sapBusinessPartnerCustomerSalesAreaDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapBusinessPartnerCustomerSalesAreaDatumAllColumns,
			sapBusinessPartnerCustomerSalesAreaDatumColumnsWithDefault,
			sapBusinessPartnerCustomerSalesAreaDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapBusinessPartnerCustomerSalesAreaDatumAllColumns,
			sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_business_partner_customer_sales_area_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_business_partner_customer_sales_area_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_business_partner_customer_sales_area_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapBusinessPartnerCustomerSalesAreaDatumType, sapBusinessPartnerCustomerSalesAreaDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapBusinessPartnerCustomerSalesAreaDatumType, sapBusinessPartnerCustomerSalesAreaDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_business_partner_customer_sales_area_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapBusinessPartnerCustomerSalesAreaDatumType, sapBusinessPartnerCustomerSalesAreaDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_business_partner_customer_sales_area_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_business_partner_customer_sales_area_data")
	}

CacheNoHooks:
	if !cached {
		sapBusinessPartnerCustomerSalesAreaDatumUpsertCacheMut.Lock()
		sapBusinessPartnerCustomerSalesAreaDatumUpsertCache[key] = cache
		sapBusinessPartnerCustomerSalesAreaDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapBusinessPartnerCustomerSalesAreaDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapBusinessPartnerCustomerSalesAreaDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_business_partner_customer_sales_area_data` WHERE `Customer`=? AND `SalesOrganization`=? AND `DistributionChannel`=? AND `Division`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_business_partner_customer_sales_area_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_business_partner_customer_sales_area_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapBusinessPartnerCustomerSalesAreaDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapBusinessPartnerCustomerSalesAreaDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_business_partner_customer_sales_area_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_business_partner_customer_sales_area_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapBusinessPartnerCustomerSalesAreaDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapBusinessPartnerCustomerSalesAreaDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_business_partner_customer_sales_area_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapBusinessPartnerCustomerSalesAreaDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_business_partner_customer_sales_area_data")
	}

	if len(sapBusinessPartnerCustomerSalesAreaDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapBusinessPartnerCustomerSalesAreaDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapBusinessPartnerCustomerSalesAreaDatum(ctx, exec, o.Customer, o.SalesOrganization, o.DistributionChannel, o.Division)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapBusinessPartnerCustomerSalesAreaDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapBusinessPartnerCustomerSalesAreaDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_business_partner_customer_sales_area_data`.* FROM `sap_business_partner_customer_sales_area_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapBusinessPartnerCustomerSalesAreaDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapBusinessPartnerCustomerSalesAreaDatumSlice")
	}

	*o = slice

	return nil
}

// SapBusinessPartnerCustomerSalesAreaDatumExists checks if the SapBusinessPartnerCustomerSalesAreaDatum row exists.
func SapBusinessPartnerCustomerSalesAreaDatumExists(ctx context.Context, exec boil.ContextExecutor, customer string, salesOrganization string, distributionChannel string, division string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_business_partner_customer_sales_area_data` where `Customer`=? AND `SalesOrganization`=? AND `DistributionChannel`=? AND `Division`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, customer, salesOrganization, distributionChannel, division)
	}
	row := exec.QueryRowContext(ctx, sql, customer, salesOrganization, distributionChannel, division)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_business_partner_customer_sales_area_data exists")
	}

	return exists, nil
}
